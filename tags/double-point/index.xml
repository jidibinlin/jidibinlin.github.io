<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>double-point - Tag - LoveIt</title>
        <link>https://jidibinlin.github.io/tags/double-point/</link>
        <description>double-point - Tag - LoveIt</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>2694273649@qq.com (jidibinlin)</managingEditor>
            <webMaster>2694273649@qq.com (jidibinlin)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 02 Apr 2022 21:25:00 &#43;0800</lastBuildDate><atom:link href="https://jidibinlin.github.io/tags/double-point/" rel="self" type="application/rss+xml" /><item>
    <title>leetcode-盛水最多的容器</title>
    <link>https://jidibinlin.github.io/container_with_most_water/</link>
    <pubDate>Sat, 02 Apr 2022 21:25:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jidibinlin.github.io/container_with_most_water/</guid>
    <description><![CDATA[1 Description https://leetcode-cn.com/problems/container-with-most-water/
 2 analyze problem 这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最优解优于全局最优解，则刷新全局最优解。
 2.1 slove step   分配两个指针，分别指向数组的头尾
1 2  [1,8,6,2,5,4,8,3,7] l r     计算面积并与全局最优解做比较，如果大于全局最优解，刷新全局最优解。并且移动对应数字较小的那个指针(向对应数字较大的方向移动)
1 2  [1,8,6,2,5,4,8,3,7] l r     重复上述操作直到指针相遇
  2.2 certify 需要该解法需要证明的是，为什么每次移动对应值较小的指针是正确的。 双指针代表的是 可以作为容器边界的所有位置的范围 移动指针就代表这个指针不可能再作为容器的边界了。 为什么指向较小值的指针不可能再作为容器的边界了 。 假设当前左指针和右指针指向的数分别为\(x\) 和\(y\), 不失一般性，我们假设 \(x \leq y\) 两个指针之间的距离为t。那么，他们组成的容器的容量为： \[\begin{equation} min(x,y)*t = x*t \end{equation}\] 如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 \(x*t\) 。为什么呢，这里我们只考虑当指针还指向左右边界的时候。 我们任意向左移动右指针，指向的数为 \(y_{1}\) ，两个指针之间的距离为 \(t_{1}\) ，\(t_{1} &lt; t\) ，并且 \(min(x,y_{1}) \le min(x,y)\)]]></description>
</item></channel>
</rss>
