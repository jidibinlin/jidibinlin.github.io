<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>double-point on jidibinlin`s blog Site</title>
    <link>https://jidibinlin.github.io/tags/double-point/</link>
    <description>Recent content in double-point on jidibinlin`s blog Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Mar 2022 20:39:00 +0800</lastBuildDate><atom:link href="https://jidibinlin.github.io/tags/double-point/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>三数之和</title>
      <link>https://jidibinlin.github.io/posts/2022/03/3sumcloset/</link>
      <pubDate>Mon, 28 Mar 2022 20:39:00 +0800</pubDate>
      
      <guid>https://jidibinlin.github.io/posts/2022/03/3sumcloset/</guid>
      <description>3SumCloset description  analyze 这道题先排序，防止重复枚举，并且利用有序性，来使双指针的逼近产生可能。双指针的逼近其实和那题最大容量是类似的。 假设每轮枚举到的数分别为a,b,c，第二轮第三轮枚举的指针分别为i,pb,pc,令pb指向i+1,pc指向len(nums)-1
 若a+b+c &amp;gt; target 则应该让pc左移，因为排完序后，pb不动的情况下 只有pc左移才会使a+b+c的值减小 才有可能更加靠近target 若a+b+c &amp;lt; target 则应该让pb右移，因为pc不动的情况下，只有pb右移，a+b+c的值才会增大，才有可能更加靠近target  implementation package main  import (  &amp;#34;fmt&amp;#34;  &amp;#34;math&amp;#34;  &amp;#34;sort&amp;#34; )  func threeSumClosest(nums []int, target int) int {  result := math.MaxInt64   distance := math.MaxFloat64  sort.Ints(nums)  for i := 0; i &amp;lt; len(nums); i++ {  if i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1] {  continue  }  third := len(nums) - 1  for j := i + 1; j &amp;lt; len(nums); j++ {   if j &amp;gt; i+1 &amp;amp;&amp;amp; nums[j] == nums[j-1] {  continue  }   for nums[i]+nums[j]+nums[third] &amp;gt; target &amp;amp;&amp;amp; third &amp;gt; j {  if third &amp;lt; len(nums)-1 &amp;amp;&amp;amp; nums[third] == nums[third+1] {  third--  continue  }  sum := nums[i] + nums[j] + nums[third]  tmpDistance := math.</description>
    </item>
    
    <item>
      <title>leetcode-盛水最多的容器</title>
      <link>https://jidibinlin.github.io/posts/2022/03/container_with_most_water/</link>
      <pubDate>Mon, 28 Mar 2022 19:56:00 +0800</pubDate>
      
      <guid>https://jidibinlin.github.io/posts/2022/03/container_with_most_water/</guid>
      <description>Container_With_Most_Water Description https://leetcode-cn.com/problems/container-with-most-water/
 analyze problem 这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最优解优于全局最优解，则刷新全局最优解。
slove step  step1 分配两个指针，分别指向数组的头尾 [1,8,6,2,5,4,8,3,7] l r   step2计算面积并与全局最优解做比较，如果大于全局最优解，刷新全局最优解。并且移动对应数字较小的那个指针 (向对应数字较大的方向移动)
```nil [1,8,6,2,5,4,8,3,7] l r ```  重复上述操作直到指针相遇
certify 需要该解法需要证明的是，为什么每次移动对应值较小的指针是正确的。 双指针代表的是 可以作为容器边界的所有位置的范围 移动指针就代表这个指针不可能再作为容器的边界了。 为什么指向较小值的指针不可能再作为容器的边界了 。
  step1
假设当前左指针和右指针指向的数分别为\(x\) 和\(y\), 不失一般性，我们假设 \(x \leq y\) 两个指针之间的距离为t。那么，他们组成的容器的容量为：
\begin{equation} min(x,y)*t = x*t \end{equation}
如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 \(x*t\) 。为什么呢，这里我们只考虑当指针还指向左右边界的时候。 我们任意向左移动右指针，指向的数为 \(y_{1}\) ，两个指针之间的距离为 \(t_{1}\) ，\(t_{1} &amp;lt; t\) ，并且 \(min(x,y_{1}) \le min(x,y)\)
 如果 \(y_{1} \le y\), then \(min(x,y_{1}) \le min(x,y)\) ; 如果 \(y_{1} \ge y\), then \(min(x,y_{1}) =x= min(x,y)\) ;  所以有:</description>
    </item>
    
    <item>
      <title>leetcode-四数之和</title>
      <link>https://jidibinlin.github.io/posts/2022/03/4sum/</link>
      <pubDate>Mon, 28 Mar 2022 19:54:00 +0800</pubDate>
      
      <guid>https://jidibinlin.github.io/posts/2022/03/4sum/</guid>
      <description>Problem Description  Analyse 这题和3数之和的解法几乎一样，使用双指针枚举最后两个数字，所以我直接偷懒，拿了3数之和的代码稍微改了一下解决了这一题。
Implement func fourSum(nums []int, target int) [][]int {  result := [][]int{}  if len(nums) &amp;lt; 4 {  return result  }  sort.Ints(nums)  for i := 0; i &amp;lt; len(nums)-3; i++ {  if i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1] {  continue  }  ntarget := target - nums[i]  tmp := threeSum(nums[i+1:], nums[i], ntarget)  for _, value := range tmp {  result = append(result, value)  }  }  return result }  func threeSum(nums []int, first int, target int) [][]int {  result := [][]int{}  if len(nums) &amp;lt; 3 {  return result  }   for i := 0; i &amp;lt; len(nums); i++ {  if i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1] {  continue  }   k := len(nums) - 1  ntarget := target - nums[i]   for j := i + 1; j &amp;lt; len(nums); j++ {  if j &amp;gt; i+1 &amp;amp;&amp;amp; nums[j] == nums[j-1] {  continue  }   for j &amp;lt; k &amp;amp;&amp;amp; nums[j]+nums[k] &amp;gt; ntarget {  k--  }   if j == k {  break  }   if nums[j]+nums[k] == ntarget {  result = append(result, []int{first, nums[i], nums[j], nums[k]})  }  }  }  return result } Summery </description>
    </item>
    
  </channel>
</rss>
