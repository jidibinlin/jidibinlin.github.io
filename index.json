[{"categories":["gamedev"],"content":"enemy sync flow ","date":"2022-10-05","objectID":"/frame_sync/:1:0","tags":["gamedev","frame_sync"],"title":"frame-sync","uri":"/frame_sync/"},{"categories":["leetcode"],"content":"Longest-Palindromic-Substring ","date":"2022-10-04","objectID":"/longest_palindromic_substring/:1:0","tags":["dynamic-programming"],"title":"longest palindromic substring","uri":"/longest_palindromic_substring/"},{"categories":["leetcode"],"content":"题目描述 Given a string s,return the longest palindromic substring in s。 给定一个字符串s, 返回最长的回文子字符串。 example 1 Input: s = \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. example 2 Input: s = \"cbbd\" Output: \"bb\" example 3 Input: s = \"a\" Output: \"a\" example 4 Input: s = \"ac\" Output: \"a\" 限制 1\u003c=s.length \u003c=1000 s consist of only digits and english letters https://leetcode-cn.com/problems/longest-palindromic-substring/ ","date":"2022-10-04","objectID":"/longest_palindromic_substring/:1:1","tags":["dynamic-programming"],"title":"longest palindromic substring","uri":"/longest_palindromic_substring/"},{"categories":["leetcode"],"content":"题目分析 这题应该用动态规划来做。为什么,首先要想使用动态规划是需要满足几个条件的。 问题要有最优子结构 :: 最优子结构就是递归分解后，结构最小的问题 问题要能够递归分解 :: 递归分解，又叫转移方程，问题被不断递归拆解成一个个小的问题 子问题的最优解决定了父问题的最优解 有很多的重叠问题 :: 当问题有重叠问题时，重叠的问题会被不断的计算，这时候可以将重叠 问题的结果存储起来，下次在次计算这个问题的时候，我们可以直接去取结果，用牺牲少量内存 的方法来加速计算 具体分析 首先我们看看能不能递归拆解这个问题 最长的回文字串，这里有一个性质: 最长的回文字符串，他的子串一定也是一个回文字符串。 如果他有任意一个字串，他不是回文字符串，那他就不构成回文了。因为回文一定是\"a\",“aa” “aba\"这三种形式。所以到这里最优子结构也就出来了。 最优子结构 “a” “aa” 任意的回文字符串，一定是在这两个结构的基础上，通过在他们两端加上相同的字符复合而成 转移方程 我们设 pol(i,j)表示从i到j的字符串是否为回文字符串，那么他可以转化成下面的形式 \\[pol(i,j) = pol(i+1,j-1)\\wedge(s[i]==s[j])\\] pol(i,j) 要想为真 那么他从i+1 到 j-1 的子字符串必须是回文字符串，s[i]==s[j] 也就是两端必须字符相同的时候。 \\[pol(i,j) = pol(i+1,j-1)\\wedge(s[i]==s[j])\\]所以这就是我们的转移方程式 这里，我们还要考虑边界情况 当字符串长度为1的时候，因为只有一个字符，所以他本身就是回文 当字符串长度为2的时候，只有两个字符都相等，才表示它是回文 \\begin{equation} \\begin{cases} pol(i,i)=true\\\\ p(i,i+1)=(s_{i}==s_{i+1}) \\end{cases} \\end{equation} 整个递推表达式就是 \\begin{equation} pol(i,j)=\\begin{cases} true \u0026\\text{i=j}\\\\ s_{i}==s_{i+1} \u0026\\text{j-i=1}\\\\ pol(i+1,j-i)\\wedge(s[i]==s[j]) \u0026j-i\u003e=2 \\end{cases} \\end{equation} ","date":"2022-10-04","objectID":"/longest_palindromic_substring/:1:2","tags":["dynamic-programming"],"title":"longest palindromic substring","uri":"/longest_palindromic_substring/"},{"categories":["leetcode"],"content":"代码实现 #include \u003cvector\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; class Solution { public: string longestPalindrome(string s) { vector \u003cvector\u003cbool\u003e\u003e dp(s.length(),vector\u003cbool\u003e(s.length(),0)); for (int i = 1; i \u003c s.length(); ++i) { dp[i][i]=true; } int longest = 1; int start=0; for (int i=2; i \u003c= s.length(); ++i) { for (int j=0 ; j+i\u003c=s.length(); ++j) { if(i==2){ dp[j][j+1]=(s[j]==s[j+1]); if(longest \u003c=2 \u0026\u0026 dp[j][j+1]){ longest = i; start=j; } continue; } dp[j][j+i-1]=dp[j+1][j+i-2] \u0026\u0026 (s[j]==s[j+i-1]); if(dp[j][j+i-1] \u0026\u0026 i\u003e=longest){ longest = i; start=j; } } } cout \u003c\u003c longest\u003c\u003c endl; return s.substr(start, longest); } }; int main() { Solution *s = new Solution(); cout \u003c\u003c s-\u003elongestPalindrome(\"bb\") \u003c\u003cendl; } ","date":"2022-10-04","objectID":"/longest_palindromic_substring/:1:3","tags":["dynamic-programming"],"title":"longest palindromic substring","uri":"/longest_palindromic_substring/"},{"categories":["leetcode"],"content":"Problem description ","date":"2022-10-04","objectID":"/3sum/:1:0","tags":["leetcode"],"title":"3sum","uri":"/3sum/"},{"categories":["leetcode"],"content":"Analyse 这道题难点在于不重复的三元组，但是三重枚举后不断通过哈希去去重的消耗太高不合适。解决这个难点的可以先将数组进行排序，然后按照顺序去枚举当遇到相同的元素时，直接跳过，这样就避免了之后需要哈希去重的麻烦事。 这道题的三重枚举可以优化成两重。当 a+b+c = 0(a\u003c=b\u003c=c)，在进行下一次二重枚举的若有满足条件的组合,会有 a+b`+c`=0(b`\u003eb \u0026\u0026 c`\u003cc) 这意味着，我们不必在第三重枚举时枚举所有剩下的元素，只需要枚举比上一次满足要求组合中比c小的元素即可。 我们可以采用双指针的思想，让第二轮的second 固定，不断向左平移thrid下标 ","date":"2022-10-04","objectID":"/3sum/:2:0","tags":["leetcode"],"title":"3sum","uri":"/3sum/"},{"categories":["leetcode"],"content":"Implement package main import ( \"fmt\" \"sort\" ) func threeSum(nums []int) [][]int { if len(nums) \u003c 3 { return [][]int{} } result := [][]int{} sort.Ints(nums) for i := 0; i \u003c= len(nums)-3; i++ { if i \u003e 0 \u0026\u0026 nums[i] == nums[i-1] { continue } k := len(nums) - 1 target := -1 * nums[i] for j := i + 1; j \u003c= len(nums)-2; j++ { if j \u003e i+1 \u0026\u0026 nums[j] == nums[j-1] { continue } for j \u003c k \u0026\u0026 nums[j]+nums[k] \u003e target { k-- } if j == k { break } if nums[j]+nums[k] == target { result = append(result, []int{nums[i], nums[j], nums[k]}) } } } return result } #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; class Solution { public: vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) { vector\u003cvector\u003cint\u003e\u003e result; if (nums.size() \u003c 3) { return result; } sort(nums.begin(),nums.end()); for (int i=0; i\u003cnums.size(); ++i) { if (i\u003e0 \u0026\u0026 nums[i]==nums[i-1]) { continue; } int third = nums.size()-1; int target = -nums[i]; for (int j=i+1; j\u003cnums.size(); j++) { if (j\u003ei+1 \u0026\u0026 nums[j] == nums[j-1]) { continue; } while(j\u003cthird \u0026\u0026 nums[j]+nums[third] \u003e target){ third--; } if (third == j) { break; } if(nums[j]+nums[third] == target){ result.push_back({nums[i],nums[j],nums[third]}); } } } return result; } }; ","date":"2022-10-04","objectID":"/3sum/:3:0","tags":["leetcode"],"title":"3sum","uri":"/3sum/"},{"categories":["leetcode"],"content":"Summery 解题的时候还是应该多多思考题目已知条件所带来的一些性质，这题就用到了数字可以排序的性质来解决重复枚举的问题。新的第三轮的枚举值必定小于上一次成功的第三轮枚举值，可以用来优化代码。 ","date":"2022-10-04","objectID":"/3sum/:4:0","tags":["leetcode"],"title":"3sum","uri":"/3sum/"},{"categories":["leetcode","divide-and-conquer"],"content":"Description Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. Example 3: Input: nums1 = [0,0], nums2 = [0,0] Output: 0.00000 Example 4: Input: nums1 = [], nums2 = [1] Output: 1.00000 Example 5: Input: nums1 = [2], nums2 = [] Output: 2.00000 Constraints: nums1.length == m nums2.length == n 0 \u003c= m \u003c= 1000 0 \u003c= n \u003c= 1000 1 \u003c= m + n \u003c= 2000 -106 \u003c= nums1[i], nums2[i] \u003c= 106 ","date":"2022-10-04","objectID":"/median_of_two_sorted_arrays/:1:0","tags":["leetcode","divide-and-conquer"],"title":"Median of Two Sorted Arrays","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode","divide-and-conquer"],"content":"Analyse 这道题最简单的想法就是先归并到一个数组，然后再把中位数找到，但是此时的时间复杂度 为\\(o(m+n)\\) 不符合题意。题目要求的是 \\(o(\\log(m+n))\\) 。此时我们能想到的应该就只有 二分法了，对于有序数组，二分法总能非常有效的降低算法的复杂度。但是如何二分成为一 个问题。中位数指的是一个数列中间的数。设 len = len(array) 这里的/为整除 \\begin{equation} \\label{中位数公式} medium = \\begin{cases} \\frac{array[len/2-1] + array[len/2]}{2} \u0026len\\mod 2=0 \\\\ \\frac{array[len/2-1]}{2}\u0026 len\\mod 2\\neq 0 \\end{cases} \\end{equation} 这道题是寻找两个有序数组的中位数，我们可以姑且假设他们已经合并后的数组为 nums3 我们要在nums3中寻找中位数。此时 nums3 的长度我们是知道的(m+n) 那么其中位数的应该 为第 k= \\(\\frac{m+n}{2}\\) 个数（这里我们先只看奇数情况。这时我们可以对k进行二分处 理，分别找到两个s数组中第\\(\\frac{k}{2}\\) 个数进行比较，然后排除较小的以及它所在数 组中在它前面的数。因为他们是不可能成为中位数的。对于 nums1[k/2-1] 和 nums2[k/2-1] 在它们之前的只有 k/2-1 + k/2-1 = k -2 个数。即使算上较小的那个数， 也只能到第k-1个数。所以他们是不可能成为第k个数的。这时我们让 k = k-A(A为已经排除 的数的个数) 然后继续对剩下的数组进行同样的操作。 这里会出现两种情况 如果 nums1[k/2-1] \u003e= nums2[k/2-1] 则直接排除nums1[k/2-1] 及其前面的数 如果 nums1[k/2-1] \u003c nums2[k/2-1] 则直接排除nums2[k/2-1] 及其前面的数 在排除过程中我们还会遇到几种情况 k/2-1 越界，这种情况取最后一个元素 k=1 直接返回较小的元素 数组为空，直接去非空数组中寻找即可 ","date":"2022-10-04","objectID":"/median_of_two_sorted_arrays/:2:0","tags":["leetcode","divide-and-conquer"],"title":"Median of Two Sorted Arrays","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode","divide-and-conquer"],"content":"Implement //c++ version #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e int main(int argc, char *argv[]) { Solution s; vector\u003cint\u003e nums1 = new vector\u003cint\u003e(); vector\u003cint\u003e nums2 = new vector\u003cint\u003e(); for(int i = 1;i\u003c10;i++){ nums1.push_back(i); } for(int i= 1;i\u003c10;i=i+2){ nums2.push_back(i); } s.findMedianSortedArrays(nums1,nums2); return 0; } class Solution { public: double findMedianSortedArrays(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { int k = nums1.size() + nums2.size(); if(k%2 == 0){ return min(getKthElement(nums1, nums2, k/2+1),getKthElement(nums1, nums2,k/2))/2.0; }else{ return getKthElement(nums1,nums2,k/2); } } double getKthElement(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2,int k){ int index1 = 0; int index2 = 0; int m = nums1.size(); int n = nums2.size(); while (true){ if (index1 == m){ return nums2[index2+k-1]; } if(index2 == n){ return nums1[index1 +k -1]; } if(k == 1){ return min(nums1[index1],nums2[index2]); } int newIndex1 = min(index1+k/2-1,m-1); int newIndex2 = min(index2+k/2-1,n-1); if(nums1[newIndex1] \u003e= nums2[newIndex2]){ k -= newIndex2 - index2 +1; index2 = newIndex2+1; }else{ k -= newIndex1 - index1 +1; index1 = newIndex1+1; } } } }; //GO version package main import ( \"fmt\" \"math\" ) func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { k := int(math.Ceil((float64(len(nums1)) + float64(len(nums2))) / 2)) if (len(nums1)+len(nums2))%2 == 0 { foo1 := getKthElement(nums1, nums2, k) foo2 := getKthElement(nums1, nums2, k+1) return float64(foo1+foo2) / 2 } else { return float64(getKthElement(nums1, nums2, k)) } } func getKthElement(nums1 []int, nums2 []int, k int) int { if len(nums1) == 0 { return nums2[k-1] } if len(nums2) == 0 { return nums1[k-1] } compareIdx := k / 2 if compareIdx == 0 { return min(nums1[0], nums2[0]) } nums1Idx := min(len(nums1)-1, compareIdx-1) nums2Idx := min(len(nums2)-1, compareIdx-1) if nums1[nums1Idx] \u003e= nums2[nums2Idx] { if len(nums2) \u003c= compareIdx { return getKthElement(nums1, []int{}, k-(nums2Idx+1)) } return getKthElement(nums1, nums2[compareIdx:], k-(nums2Idx+1)) } else { if len(nums1) \u003c= compareIdx { return getKthElement([]int{}, nums2, k-(nums1Idx+1)) } return getKthElement(nums1[compareIdx:], nums2, k-(nums1Idx+1)) } } func min(x, y int) int { if x \u003c y { return x } return y } ","date":"2022-10-04","objectID":"/median_of_two_sorted_arrays/:3:0","tags":["leetcode","divide-and-conquer"],"title":"Median of Two Sorted Arrays","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode","divide-and-conquer"],"content":"summery 这道题对二分的运用比较灵活，主要是二分的对象变了，但是思想还在。正常的二分是对数 组的长度进行二分，而此题的二分却是先确定中位数的位置，再利用二分的思想去到两个数 组中分别寻找排除，非常巧妙，受益匪浅。 ","date":"2022-10-04","objectID":"/median_of_two_sorted_arrays/:4:0","tags":["leetcode","divide-and-conquer"],"title":"Median of Two Sorted Arrays","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode","interval-scheduling"],"content":"这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最优解优于全局最优解，则刷新全局最优解。","date":"2022-10-04","objectID":"/container_with_most_water/","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"1 Description https://leetcode-cn.com/problems/container-with-most-water/ ","date":"2022-10-04","objectID":"/container_with_most_water/:1:0","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"2.analyze problem 这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最 优解优于全局最优解，则刷新全局最优解。 ","date":"2022-10-04","objectID":"/container_with_most_water/:2:0","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"2.1 slove step 分配两个指针，分别指向数组的头尾 [1,8,6,2,5,4,8,3,7] l r 计算面积并与全局最优解做比较，如果大于全局最优解，刷新全局最优解。并且移动对应 数字较小的那个指针(向对应数字较大的方向移动) [1,8,6,2,5,4,8,3,7] l r 重复上述操作直到指针相遇 ","date":"2022-10-04","objectID":"/container_with_most_water/:2:1","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"2.2 certify 需要该解法需要证明的是，为什么每次移动对应值较小的指针是正确的。 双指针代表的是 可以作为容器边界的所有位置的范围 移动指针就代表这个指针不可能再作 为容器的边界了。 为什么指向较小值的指针不可能再作为容器的边界了 。假设当前左指针 和右指针指向的数分别为\\(x\\) 和\\(y\\), 不失一般性，我们假设 \\(x \\leq y\\) 两个指针之间的 距离为t。那么，他们组成的容器的容量为： \\begin{equation} \\min(x,y)*t = x*t \\end{equation} 如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过\\(x*t\\) 。 为什么呢，这里我们只考虑当指针还指向左右边界的时候。我们任意向左移动右指 针，指向的数为 \\(y_{1}\\) ，两个指针之间的距离为 \\(t_{1}\\) ，\\(t_{1} \u003c t\\) ，并且\\(min(x,y_{1}) \\le min(x,y)\\) 如果 \\(y_{1} \\le y\\), then \\(min(x,y_{1}) \\le min(x,y)\\) ; 如果 \\(y_{1} \\ge y\\), then \\(min(x,y_{1}) =x= min(x,y)\\) ; 所以有 \\begin{equation} \\min(x,y_{t})*t_{1} \u003c min(x,y)*t \\end{equation} 这表明指向较小值的指针不可以再作为容器的边界，因为无论如何移动较大的指针，容器的 容量都不会再变大。这个边界应该被舍弃。 ","date":"2022-10-04","objectID":"/container_with_most_water/:2:2","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"3 implementation //c++ version #include \u003calgrothim\u003e #include \u003ciostream\u003e #include \u003cmath\u003e using namespace std; class Solution { public: int maxArea(vector\u003cint\u003e \u0026height) { int left = 0; int right = height.size()-1; int compacity = 0; while (left \u003c right) { int min = fmin(height[left], height[right]); int length = right - left; int tmpCompacity = min * length; if (tmpCompacity \u003e= compacity) compacity = tmpCompacity; if (height[left] \u003e= height[right]) right--; else left++; } return compacity; } }; int main(int argc, char *argv[]) { return 0; } //go version import \"math\" func maxArea(height []int) int { front := 0 end := len(height)-1 var maxCompacity float64 = 0 for front \u003c end { longSide := math.Min(float64(height[front]),float64(height[end])) shotSide := float64(end-front) tmpCompacity := longSide*shotSide maxCompacity = math.Max(tmpCompacity,maxCompacity) if height[front] \u003e= height[end] { end-- }else{ front++ } } return int(maxCompacity) } ","date":"2022-10-04","objectID":"/container_with_most_water/:3:0","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"4 summery 这道题用到了双指针+贪心算法。以后都可以用双指针对撞的思想去求解这类问题，重点在 于如何找到应该移动的指针。当因子分布再数组的两边的时候，可以考虑使用双指针的方法 求解。这题的贪心并不明显，只在更新最大的容量的时候进行了贪心。贪心的思想是每一步 只选择当前认为的最优解。 ","date":"2022-10-04","objectID":"/container_with_most_water/:4:0","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["tools"],"content":"如何将时间调试工具libfaketiem , roswell, 和emacs 结合起来方便的做时间测试","date":"2022-10-04","objectID":"/libfaketime/","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs 时间测试尝试","uri":"/libfaketime/"},{"categories":["tools"],"content":"如果你写的程序经常依赖时间去做一些逻辑控制，那么你可能对调时间这件事比较敏感，你可能说不上讨厌，但是一定不喜欢。电脑频繁调时间会导致一些意想不到的问题，比如在我使用的mac m1 mini 上就会有交换内存暴涨40个g的问题。还会导致梯子失效无法访问外网。再比如你以为才上午12点，实际上已经晚上都已经下班了,你对时间没有概念了。如果往回调时间我的emacs还会卡死😮‍💨。 总之调时间好像是一件小事，但是影响却很大。 所以我一直在尝试如何在不调时间的情况下，给指定程序一个假的时间。我曾试过用容器来解决这个问题，不过容器内的时间会定时和宿主机同步，并不能解决时间问题。后来我发现了libfaketime这个工具，不过弄了半天一直没能在我的mac m1 上正常使用。最近我又遇到了要频繁调时间的情况，所以下定决心要解决这个问题。 那么在这篇blog中，你将看到如何使用libfaketime,如何使用roswell脚本制作指定程序的libfaketime 环境（先初始化时间环境，再启动指定程序），最后是如何使用emacs一键启动。 ","date":"2022-10-04","objectID":"/libfaketime/:0:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs 时间测试尝试","uri":"/libfaketime/"},{"categories":["tools"],"content":"libfaketime 安装 对于不同的环境，libfaketime的安装方法也不相同。 对于mac如果你使用homebrew(homebrew如何安装我就不赘述了) brew install libfaketime 对于linux 你可以研究下自己发行版的包管理器，比如ubuntu sudo apt-get install libfaketime windows嘛，我讨厌windows抵制程序员使用windows。所以就不介绍了（不过我建议你用wsl,把windows当作linux的子系统😝） 还有一种源码编译的安装方式，你们可以看下libfaketime 的自述文件libfaketime-readme ","date":"2022-10-04","objectID":"/libfaketime/:1:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs 时间测试尝试","uri":"/libfaketime/"},{"categories":["tools"],"content":"如何使用libfaketime 安装完成后，你有两件事情要做。 第一个读一遍libfaketime的readme。对于mac来说你应该读一遍libfaketime-mac-readme 第二个，你需要知道libfaketime的动态链接库被发到了哪个目录下面(brew安装的是 /opt/homebrew/lib/faketime/libfaketime.1.dylib) libfaketime大概的原理就是，让程序链接libfaketime的库达到改时间的目的（允许我这么潦草😄，毕竟这个库不是我写的）。所以我们应该让程序自己链接libfaketime。 在unix环境下，我们可以通过设置环境变量的方式来达到这个目的 mac下你需要 export DYLD_FORCE_FLAT_NAMESPACE=1 export DYLD_INSERT_LIBRARIES=/path/to/libfaketime.1.dylib linux下你需要 export LDPRELOAD=/path/to/libfaketime.1.so 在你正确设置了上面的环境变量后（mac 下最好通过export 设置环境变量，我试过直接在程序前面设置但是没成功）,你可以通过在程序启动前设置 “faketime” 这个环境变量来达到控制程序时间的目的。 faketime有很多中设置格式，我只介绍如何设置指定时间，并让时间自然流逝的方法。libfaketime还有很多用法，都可以在官方的自述文件里面看到。 现在直接上命令 export faketime_dont_reset=1 export faketime=\"@2022-08-20 00:00:00\" “@“字符很关键，没有””@“时间将不会自动流逝,另外faketime_dont_reset这个变量有时候也不用设置，但是如果你发现程序时间和你预期的不一样，你应该把faketime_dont_reset设置为1(具体原因你可以去看自述文件) 最后一步就是启动程序，不需要我教你吧😊 ","date":"2022-10-04","objectID":"/libfaketime/:2:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs 时间测试尝试","uri":"/libfaketime/"},{"categories":["tools"],"content":"如何使用roswell 初始化一个libfaketime环境 先介绍一下roswell。roswell 是一个common lisp 的实现管理工具，但是他自身有挺多的附带功能。其中一个就是可以作为bash 脚本的替代品，用common lisp 去写脚本。这样的好处是，common lisp要比shell脚本好写一点（主要是不像shell那么容易出错shell脚本一个空格不对都不行😒）。再者就是，利用repl,你可以非常方便的调试roswell脚本（动态语言的repl简直不要太香，开发效率真的要比go那种静态语言高，这也是我不选go的原因）。 如果你不喜欢common lisp, 你也可以使用python这样的脚本语言，也能达到一样甚至更好的效果。我简单介绍一下我的思路，其实就一句话，使用脚本语言去设置libfaketime的一系列环境变量，然后启动程序。你可以给脚本语言加上几个参数 比如程序的路径，你想要设置的时间等等去控制脚本的行为这都取决于你自己了 使用roswell作为脚本，你就需要知道如何使用common lisp的一些与系统交互的库，比如如何解析命令行的参数可以使用 unix-opts这个库。看代码喽(看不懂也没关系，你可以用你喜欢的语言甚至shell脚本自己研究下，很好写的) 这段脚本的行为是， 接受一个-e参数 用来指定程序的路径,以及一个-t参数用来指定时间 #!/bin/sh #|-*- mode:lisp -*-|# #| exec ros -Q -- $0 \"$@\" |# (progn ;;init forms (ros:ensure-asdf) #+quicklisp(ql:quickload '() :silent t) ) (defpackage :ros.script.luna_time_tast.3869869288 (:use :cl)) (in-package :ros.script.luna_time_tast.3869869288) (ql:quickload \"unix-opts\") (ql:quickload \"uiop\") ;; 定义命令行参数 (opts:define-opts (:name :bin-path :description \"binary path to be executed\" :short #\\e :long \"bin_path\" :arg-parser #'uiop:native-namestring) (:name :time :description \"time to be used\" :short #\\t :long \"time\" :arg-parser #'string) ) (defun main (\u0026rest argv) (declare (ignorable argv)) ;; 解析命令行参数 (multiple-value-bind (options) (opts:get-opts argv) (let* ((binary-path (getf options :bin-path)) ;;找到程序的父目录 (dir (uiop:pathname-directory-pathname binary-path)) (time (getf options :time))) ;; 设置libfaketime环境变量 (sb-posix:setenv \"DYLD_FORCE_FLAT_NAMESPACE\" \"1\" 1) (sb-posix:setenv \"DYLD_INSERT_LIBRARIES\" \"/opt/homebrew/lib/faketime/libfaketime.1.dylib\" 1) (sb-posix:setenv \"FAKETIME_DONT_RESET\" \"1\" 1) (sb-posix:setenv \"FAKETIME\" time 1) ;; 切换到程序目录 (uiop:chdir dir) ;;执行程序 (uiop:run-program (list \"./game\")) ) ) ) ","date":"2022-10-04","objectID":"/libfaketime/:3:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs 时间测试尝试","uri":"/libfaketime/"},{"categories":["tools"],"content":"emacs集成 其实我会用common lisp当作脚本语言是因为我比较喜欢用emacs, hack emacs需要用到lisp 这样的语言。emacs 需要做的是封装interactive函数去异步调用上述的脚本。 ;; 一个时间变量，后面会带入脚本 (setq luna_time \"@2022-08-23 23:59:20\") ;; 脚本的路径 (setq luna_run \"/Users/qibinyang/Data/luna_time_test/luna_time_tast.ros\") (defun cycle-rank-test() \"test luna game\" (interactive) ;; 异步调用脚本执行我想要调时间的程序 我的工作是游戏开发，最近在做跨服业务所以会开三个 (start-process \"run_game\" (get-buffer \"*Messages*\") luna_run \"-e\" \"/opt/cycle_test/game/game\" \"-t\" luna_time) (start-process \"run_game\" (get-buffer \"*Messages*\") luna_run \"-e\" \"/opt/cycle_test/game2/game\" \"-t\" luna_time) (start-process \"run_game\" (get-buffer \"*Messages*\") luna_run \"-e\" \"/opt/cycle_test/game_center/game\" \"-t\" luna_time) ) 这样我就可以在emacs 中 M-x cycle-rank-test 将\"20200-08-23 23:59:20” 这个时间带入到程序中。如果我想换一个时间，只需要修改luna_time这个变量，然后重启程序即可。 ","date":"2022-10-04","objectID":"/libfaketime/:4:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs 时间测试尝试","uri":"/libfaketime/"},{"categories":["tools"],"content":"总结 毕业到工作有一年的时间了，经历了挺多的事情的。印象最深的是失恋以后，又慢慢的重整旗鼓，健身改造自己，和自己对话慢慢的走出以前的漩涡。保持积极的心态，慢慢的接受新的思想，新的理念。锻炼身体，也锻炼自己的内心。慢慢接受变化，向着不惧怕变化前进。这些改变确实给我带来了我没有想到的好处。 最近有断时间没写博客了，所以今天补上一篇工作日记。从高中的时候就接触到linux，在linux和编辑器上浪费了大量的时间。现在逐渐稳定下来，未来的半年应该把重点放在算法和后端架构的理解上，兼顾开发一些小工具，提升自己的效率。最近对自己的编码风格也不是很满意，写的程序有点乱还得注意一下。 最怕懒在床上，困在手机里，被低级趣味消磨意志。 ","date":"2022-10-04","objectID":"/libfaketime/:5:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs 时间测试尝试","uri":"/libfaketime/"},{"categories":["game-dev","GoGameActor"],"content":"有关游戏中热更代码的一些思考","date":"2022-10-04","objectID":"/hotfix/","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"上周在思考框架该不该上热更，以及如何适配热更的时候（其实一行代码都还没写呢😕），迫使我不断去思考如何去热更才能做到正确。但是，热更这个事情即使是lua,也需要加上很多的限制。而且，热更这件事情不但和语言层面相关联，和框架的设计也有很密切的关系。最近在网上看了很多博客，所以这里做个思考记录。 ","date":"2022-10-04","objectID":"/hotfix/:0:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"什么是热更 热更就是在不中断服务的情况下（注意是不中断服务而不是不重启进程或服务器），对程序的行为进行修改。简单来说，如果已经部署的代码执行的逻辑是1+1=2, 那么热更就可以改变1+1=2这个行为，比如该更1+1=3，并且对外的服务是不能中断的（因为用户会无法访问业务）。在用户无感知的情况下，改变原有的代码逻辑，我们也可以这么说。 ","date":"2022-10-04","objectID":"/hotfix/:1:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"为什么要有热更 对于互联网行业来说，有流量才有可能变现。流量意味着有人在使用产品，有人使用产品我们才能着手诱导用户进行消费。试想，一个酒楼没有一个顾客（流量），他的酒，服务，饭菜要如何销售变现？而对于互联网产品来说，一秒钟的流量就可能高达千万，而这一秒的流量转化，即便只有1%，也是很多的。 试想一下，现在这一秒有1千万的流量，转化率是1%,那就意味着这一秒中有100个人在下单，假设此时一单的流水是1块，那这一秒钟的流水就是100块。 注意这里只是这1秒钟，如果时间拉长到1小时，12小时，24小时。乞丐都会知道要是每秒有人给自己扔100块，一天自己就可以🏠靠海了。 如果这时停机维护1小时，要损失多少钱？这大概就是为什么互联网行业都非常忌讳停机维护，因为\"时间\"约等于\"流量\"约等于\"钱\"。而对于游戏这种纯靠流量来赚钱的行业更是如此了，不停机维护已经是游戏行业的标配了。 ","date":"2022-10-04","objectID":"/hotfix/:2:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"热更的方案 服务器无状态，快速重启。这种方案的痛点是，服务器的重启必须尽可能的快。慢了，客户端就要考虑重登和重发协议。而且由于无状态，业务的编写更倾向于web那一套。 服务器不好维护用户状态，业务的性能和编码的难易程度一得看项目是如何架构的，二得看有没有有意识的迭代代码。如果两者都做不到，性能就由数据库决定（不做cache的话），编码就有可能要不断处理操作数据库所有可能带来的异常。因为无状态是不可能将业务的状态存储在内存的，多数是直接入库或者入cache。 对于go来说，你得时刻注意操作数据库时抛出来的error,如果不能从框架上先行对这种error进行过滤，会因为频繁的写重复代码而控制不住的觉得烦。比如，很多rpc的接口都需要用到usr这张表的信息，如果不能在rpc来的时候，自动去获取usr，那就需要程序员自己去编写。程序员的时间就浪费在了这种事情上面，未免有些亏。但是，又不是每个rpc都要用到usr表的信息，如果每个都去查一遍usr表，又会浪费数据库那有限的吞吐。所以做无状态，架构代码的人必须足够牛🍺，项目成员要时刻有迭代代码的意识。有的时候项目老大还要在编码和性能之间做权衡。 服务器无状态，将新的流量导入新的进程或者新的服务器。这种方案得在router层做好流量的转发，而且如果有些逻辑是有状态的话，还得做好状态的移交（虽是无状态服务器，但是有的逻辑有状态是难免的）。 服务器无状态，直接将代码打进正在运行的进程中，这种就比较难了。需要工程师足够了解语言特性,和框架，知道如何去替换运行时的函数。 服务器有状态，直接将代码打进正在运行的进程，这个难度比三要大。而且由于有状态，不但得做到3提到的全部，而且得做到运行时状态的转化，热更代码的编写会异常的复杂。一般来说这种方案都会在架构上加上各种限制来保证热更的正确性，所以缺点就是有各种限制。比如逻辑和数据必须严格分离，最好只热更纯函数, 对于弱类型语言会好做一些比如(lua,js)这种，允许数据结构修改的同时去更改逻辑函数做到热更正确，但是对于强类型语言(go,c++)当需要修改数据类型的时候可能不得不重启服务器，而且可能会带来动态链接模块版本控制等一系列问题(我的框架可能会选择这种方式)。 只热更策划表，这种就比较容易了，做好所有业务逻辑从统一的地方拿配置就行。对于静态语言来说，配表结构更改还是免不了需要重启服务器。编码的时候预留控制台接口，需要更新时由控制台发送reload配置的命令，程序先锁住配表服务然后直接reload所有的配表再解锁就可以了。 ","date":"2022-10-04","objectID":"/hotfix/:3:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"总结 静态语言虽然性能上要好过动态语言，但是灵活性上大大弱于动态语言。无状态虽然能做到无感知，但是吃重启速度，还得客户端配合，想要性能和愉快的编码，你得找好点的搭档，架构得好好设计别偷懒。 热更会带来很多的限制，引入新的特性，新的技术都会带来新的副作用和问题。引入之前必须做好权衡，想好了再做。框架编写非常吃架构师的能力，你得给他足够的时间去思考架构上的问题。 我就遇到无状态服务器频繁操作数据库（因为当时后端环境非常恶劣，只有他一个人，他来的时候没有框架，还得尽快对接业务,后端1v8非常惨烈，而且说好一个服只有4000的导量，所以没有上cache），老大担心性能上会遇到瓶颈, 所以让我去做一些热表（数据库中需要频繁访问的表）的cache。但是我做完了热表的cache后，发现热表的cache会影响一些跨服的业务。这个时候修改跨服的代码代价会比较大，而且也没到非上不可的时候（导量还是不会突破4000的）所以这个事情只能暂时搁置, 我还得去写别的业务。但是就怕有一天性能会遇到瓶颈，遇到了我那写了挺多跨服业务的同事就得忙一会了，我最近也写了一些，我也得忙一下了😂。 ","date":"2022-10-04","objectID":"/hotfix/:4:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["gamedev"],"content":"actor 介绍和感悟","date":"2022-10-04","objectID":"/introduction/","tags":["actor","gamedev"],"title":"actor 模型介绍和感悟","uri":"/introduction/"},{"categories":["gamedev"],"content":"为什么有这篇博客 一切源自于我去年的毕业设计，我毕业设计的课题是《基于unity打造的第三人称设计游戏》。刚一看到这个题目的时候你一定想到，这和actor 和 网络有什么关系吗？确实，按照毕设的要求，是不需要这个游戏有网络模块的设计的。但是嘛，因为我快毕业那会非常想找一家游戏公司的后端进行实习，未来的职业规划也是往游戏后端的方向发展的。所以我自告奋勇的跟导师说这个游戏我要加上网络模块（其实之前有过类似的游戏协议序列化和网络同步的经验）。 选定课题没多久，我就在广州找到了我的第一家实习公司，是一家做大型mmo的游戏公司（刚去他家的时候还微微鄙视他家的框架，现在看来简直是我无法企及的神）。 东家用的libevent 写的网络库（其实从这就可以看出是一家成立很早的公司了）,然后暴露给lua调用，逻辑全是用lua写的，由于lua不支持真正的多线程所以东家用的多进程，利用rpc解决进程同步的问题（当时初出茅庐，这个地方狠狠的坑了我一把，也导致我给东家留下了第一个不好的印象）。所以我很自然的学到了protobuf 和 lua这样的技术。 有了这两个技术之后，我便开始着手自己毕设的后端框架了。去网上找了一通资料，发现skynet（一款基于actor模型开发的框架）这个框架,我立刻被skynet的actor模型给吸引了，并且立志我也要基于actor模型写出一个自己的框架。 四个月后，由于我总是在忙自己的毕设，给东家留下了第二个不好的印象，我被开了。被开的时候，我的老大把我拉到办公室跟我说了很多让我受用的话。在反复的思考他说的话之后，我开始学习go语言。并且在离职的那段时间里，我写了自己的golang 协程池,写的时候知道golang已经有一个非常厉害的协程池叫ants,所以写完之后和ants battle了一下,但是发现我只在百万以上级别的性能上能够领先ants, 但是内存占用却完完全全的输给了ants，而且ants还有动态伸缩等等一些我没有的特性。我还是菜了点😂。但是这个经历却让我尝到了绞尽脑汁解决问题的甜头, 也让我在实践中学到了很多的东西。 个人认为实践和看书必须相互结合，先看书，再实践，实践完了再看书又会收获新的东西，只有实践后的只是才能真正的内化。 介绍自己写协程池的经历是因为，在写协程池的时候，我了解到了golang的协程调度器GMP。这个调度器和skynet内部的线程池非常的类似，我可以基于这个GMP去写我的后端框架。 ","date":"2022-10-04","objectID":"/introduction/:1:0","tags":["actor","gamedev"],"title":"actor 模型介绍和感悟","uri":"/introduction/"},{"categories":["gamedev"],"content":"Actor模型 Actor模型(Actor model)首先是由Carl Hewitt在1973定义， 由Erlang OTP 推广，其 消息传递更加符合面向对象的原始意图。Actor属于并发组件模型，通过组件方式定义并发编程范式的高级阶段，避免使用者直接接触多线程并发或线程池等基础概念。 Actor模型=数据+行为+消息。 actor模型是一种天然的分布式模型，actor可以分布在不同的地方，可以是本地，也可以分布在不同的网络主机上。 强隔离性,actor之间只能通过每个actor的mailbox来协作，一个actor不可以直接操纵另一个actor,只能通过写信的方式通知另一个actor自己要做什么。也就是说，actor与actor默认且强制要求使用类似物理隔离的主机那样使用rpc的方式协作。 位置透明，抹平本地与非本地的差异，actor模型中无需关注一个actor部署在了哪个地方。 异步，由于通过mailbox来实现协作，所以发送者在将消息推送到接收者的mailbox后，若无需等待结果，就可以直接去做别的事情。剩下的就可以交给接收者让它自己去消费这条消息了。 无锁，同样由于基于mailbox实现协作，消息是具有顺序的，我们无需关注资源竞争带来的数据一致性问题(你不能直接操作actor，只能告诉它你要做什么) 天生支持负载均衡，而且对水平扩容的支持非常好(actor 强迫你对服务进行划分，做成微服务那样) note 这里提一嘴在我面试现东家的时候，老大和我探讨actor模型时，给我出的一个题目。当时回答的不是非常好，所以这次写博客总结一下。 当时老大在听完我介绍actor模型后，就问我，由于actor和actor之间是通过mailbox进行协作的，每个actor的状态都是自维护的。现在每个玩家登陆，我们就会实例化一个actor出来，如果我现在想广播一条协议给全服在线的玩家，我就需要给每个玩家的actor的mailbox推送一条指令，这个是非常消耗资源的。这种情况，你要怎么解决? 这个问题其实问的主要是，当我要让大量的actor进行相同的操作的时候，就会遇到需要向每一个actor的mailbox插入消息的情况。假设现有3w的玩家在线(这个已经很多了)，如果消息的大小非常小的时候（比如只有byte级），如果一条消息100byte,那广播一次的成本是2929KB 也就是差不多3M的样子。但是如果广播的消息比较大 达到了K级别如果一条消息的1k，那广播一次的成本是 30M, 但是100k的话，成本就是3G。 但是实际的情况是，一条协议能过突破1k,已经很不容易了。 假设一条协议有10个字段，每个字段占8Byte(64位),也才80byte,100个字段也才突破1k。虽然消耗上来说，会比不用actor的要大，但是并非无法接受的程度。 假设真的遇到了那种需要广播一条非常大的协议（假设一条协议他突破了100k?），我们还可以从框架的层面去解决这个问题。这里给出几个解决的思路。 假设我们现在遇到了群发协议的情况，其实正常的框架设计是不可能让玩家的agent actor(一个玩家会有一个叫做agent的actor)去收发协议的，而是在客户端和 agent actor之间用一个叫做router的actor进行一个中转，这个router负责编码/解码协议，并推送给指定的agent actor或者客户端, 它管理了玩家的socket。 所以如果是广播协议，其实不用通过agent actor. 直接通过router, 让router拿到每一个在线玩家的套接字去群发就好了。所以遇到这种需要发送给一类actor的情况，优先考虑是否能通过这些actor 的 manager来解决，不得已的情况下才需要给每个actor 分发message。 还可以把协议做成指针，指针的指针的传送成本是非常小的，一招鲜吃遍天😂。skynet中就有一个这样的服务，专门用于广播消息。不过实现的细节是比较复杂的可以去看一看skynet的新组播方案 这里我先立个flag 等我的框架写到这部分的时候再细细研究 再不济，你就把这种需要世界广播的业务(比如世界聊天)用单独的服务器承载，把业务划分出来，让单独的服务器去做。 actor模型的实现除了skynet,akka,proto.actor(有两种实现一种是 c# 还有一种是 golang实现的 golang实现的还不稳定) 还有在游戏中广泛使用的erlang语言，天生从语言层面就支持actor模型 要想自己造一个actor的轮子你得清楚网络数据传输的解码/编码，熟悉消息队列。 ","date":"2022-10-04","objectID":"/introduction/:2:0","tags":["actor","gamedev"],"title":"actor 模型介绍和感悟","uri":"/introduction/"},{"categories":["golang"],"content":"golang的语法基础: 编程语言的语法总是离不开三件套，变量，函数，控制结构. 这里着重介绍golang这三部分的基础知识.","date":"2022-10-04","objectID":"/syntax/","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"定义(Declarations) 定义用来描述一个编程元素的基本属性，比较难理解。通俗来说，就是指定这个元素是干什么的。元素被定义的那一刻就被赋予了职能。比如总统有总统该干的事，猫天生就会抓老鼠，水可以呈现液态，固态，气态三种形式。 golang有三种形式的定义 var 用来定义变量 const 用来定义常量 type 用来定义类型 func 用来定义函数 ","date":"2022-10-04","objectID":"/syntax/:1:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"定义的作用域 定义是分作用范围的，golang的作用范围分为 package-level 包级别: 在包中都能被访问到 func-level 函数级别: 只能在函数中被访问到 block-level 块级别: 只能在代码块中被访问到 三个作用域级别由大到小，block-level最小. package-level package main //申明所在的包 import \"fmt\" const boilingF = 212.0 func main() { } 在这段代码中 boilingF 就是包级别的常量. 只要项目文件的开头申明了 package main 那么boilingF就可以在这个文件中被访问到 func-level package main import \"fmt\" func main() { const boilingF = 212.0 } 这段代码的boilingF就只能在main函数中被访问到 block-level package main import \"fmt\" func main() { if true { const boilingF = 212.0 } } 这里的boilingF就只能在if代码块中被访问 同名定义的访问顺序自底向上 试想一种场景，若在三个作用域级别中，我们分别都定义了 boilingF 那我们将访问到哪一个 boilingF package main import \"fmt\" const boilingF = 212.0 func main() { const boilingF = 213.0 fmt.Printf(\"boilingF %d\\n\",boilingF) if true { const boilingF = 214.0 fmt.Printf(\"boilingF %d\\n\",boilingF) } } 执行结果 boilingF = 213.000000 boilingF = 214.000000 可以看到第一个打印打印的是213而不是212.0 说明212被213隐藏了. 而在if代码块中 打印的是214而不是213说明213被隐藏了。 这说明若有同名变量，那么低作用域的定义将会覆盖高作用域的定义 同作用域内，不可重定义同名变量 package main import \"fmt\" const boilingF = 212.0 const boilingF = 212.0 func main() { } 这段代码编译是不会通过的，因为定义了两次boilingF属于重定义错误 note 这些只是一些基本的知识，更多的有关定义的坑将会在下面的变量中介绍 ","date":"2022-10-04","objectID":"/syntax/:1:1","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"变量(variable) 变量有两种定义方式 var var name type = expression 语法糖 := name := expression ","date":"2022-10-04","objectID":"/syntax/:2:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"使用var来定义 在使用var 来定义变量时 type 和 expression可以省略其中一个 但是不可以同时省略（同时省略的话，go将不清楚我们具体要定义什么） 省略type(自动推倒类型) 省略type 的时候 golang将会根据expression自动推倒类型， 后面将会介绍的 := 就是这种写法的语法糖 比如 var name = \"jidibinlin\" // name 的类型是string var age = 12 // age 的类型是age 省略expression 若省略expression 变量将被默认值（0值)取代。 对于数值类型，默认值将是0, 对于字符串将会是\"\" 对于bool型将会是false,对于引用类型(slice,pointer,map,channel,function) 将会是nil 对于array和struct来说，他们的元素将会是0值 var s string // s = \"\" var i int // i = 0 var b bool // b = false var slc []int // slic = nil var arr [3]int // arr[0]=0 arr[1]=0 arr[2]=0 type astruct struct { s string i int b bool slc []int } var stru astruct // stru.s = \"\" stru.i = 0 stru.b = false stru.slc = nil 一次定义多个变量 var i, j, k int //int, int, int var b, f, s = true, 2.3, \"fout\" //bool,float64,string 接受多返回值函数的返回值 go可以定义多返回值的函数。 使用var 就可以很便捷的申明多个变量用来接受函数的返回值. var f,err = os.Open(name) //os.Open 会返回一个file 和 一个error note 注意，由于函数的返回值类型是不确定的。 而var 在定义多变量的时候只能是同一类型的 var i, j ,k int 所以在接收多返回值函数的时候，建议使用自动类型推倒(强烈建议) ","date":"2022-10-04","objectID":"/syntax/:2:1","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":":= 语法糖 := 是用来定义和初始化变量的语法糖 name := expression 乍一看似乎和自动推倒类型的var 形式很像，但是两者是有区别的. 两者都可以自动推倒变量的类型, 都可以同时申明多个variable var name = \"\" //name的类型为string name1 := \"\" // name的类型为string name2, name3, name4 := \"\",\"\",\"\" 但是 := 语法糖只能在函数的内部用来申明和初始化变量,而var 却可以用在函数外部 package main var i = 1 // right j := 1 //wrong func main() { k := 2 //right var g = 1 //right } := 和 var 都会申明新的变量，但是:=却会考虑重用已有的变量 var n1, n2 = \"\",\"\" var n2, n3 = \"\",\"\" // wrong 这里会报n2重定义 name1,name2 := \"\",\"\" name2,name3 := \"\",\"\" //right := 会重用name2 (如果有已经申明的变量的话 会重用) warning 注意 := 的左侧必须有未被申明的变量才能被执行 name1,name2 :=\"\",\"\" name1,name2 :=\"\",\"\" //wrong ","date":"2022-10-04","objectID":"/syntax/:2:2","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"Pointer指针 如果对c系列的语言有了解的话，应该对指针是不陌生的. 在go 中指针的用法和c语言几乎相同 使用* 声明/解引用，使用\u0026来取地址 x := 1 p := \u0026x //取地址 并声明一个p指针指向x *p = 2 // 将2存进p指向的变量也就是x 有关go的指针不过多介绍 ","date":"2022-10-04","objectID":"/syntax/:2:3","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"new函数 new也可以用来创建指针,但是new创建的是指针类型,使用的时候直接在传入一个类型即可 p := new(int) //p指向一块int型的内存空间 *p = 2 //给p指向的空间赋值 new 和声明指针的区别在于，new会先分配内存空间再将这块空间的地址返回，而声明指针只是声明了一个指针，但是它并不指向任何地址。new 更像是先声明变量，再将变量的地址返回. ","date":"2022-10-04","objectID":"/syntax/:2:4","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"变量的生命周期 除了包级别的变量外(声明在函数外的变量), 其余变量的生命周期都是动态的。 包级别的变量生命周期将会持续到整个程序被终止。 动态生命周期指变量从变量被声明的那一刻起，一直到它无法被访问到为止。当变量无法被访问时他的内存可能会被回收。 由于变量的生命周期是由其能否被访问到决定的，所以变量有可能会跳出循环或者函数继续存在。 note 一般来说局部变量的可以跳出代码块而存在的话，我们就说这是一个逃逸变量。相对于非逃逸变量来说，逃逸变量的内存将会被分配在堆上，而非逃逸变量是分配在栈上的。 c++ 程序员需要关心变量是分配在栈上好，还是分配在堆上好。但是对于go来说，这些都是编译器自动完成的，程序员无需关心变量的内存是分配在栈上还是堆上。 栈是及时回收的数据结构，所有在栈上声明的变量在函数结束的那一刻都会被回收，所以如果变量在函数外还可以被使用，就应该分配在堆上。c++中堆是程序员自己释放的，而在go中，go有自己的回收方案。 var global *int func f() { var x int //x将被分配在堆上，因为global指向它，他逃逸出了f函数 x = 1 global = \u0026x } func g() { y := new(int) //y将被分配在栈上，因为他不是逃逸变量，出了g函数后，是没法被访问的 *y = 1 } ","date":"2022-10-04","objectID":"/syntax/:2:5","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"变量赋值 赋值可以更新变量存储的value,但是左边和右边的类型必须是匹配的（比如左右都是同类型的,都实现了同一个接口） x = 1 *p = true person.name = \"bob\" count[x] = count[x]*scale c语言支持的赋值操作go都支持包括++,–,+=,-=, 移位等等 ","date":"2022-10-04","objectID":"/syntax/:3:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"元组赋值(tuple assignment) 元组赋值允许多个变量同时被赋值，所有右边的变量都会先被运算然后再赋值给左边。也就是说你可以这样交换两个变量的值 x, y = y, x 前面有提到过，go的返回值可以有多个。go习惯用第二个返回值表示函数执行的状态，第二个返回值可以是error,或者一个bool值ok,这样就可以知道在取出变量和调用函数的时候是否有错误和异常出现。 f, err = os.Open(\"foo.text\") //如果err 不为nil的话表示打开文件失败 这一点在go中经常被用到 v,ok = m[key] //从map中取值 v,ok = x.(T) //类型断言 v,ok = \u003c-ch //从channel中接受 如果你并不需要用到某些返回值，你可以用 “_” 占位来忽略它 _, err = io.Copy(dst,src) //discard byte count _, ok = x.(T) //check type but discard result 但是捏，不要这样用 v, _ = io.Copy(dst,src) 这样用和 v = io.Copy(dst,src) 是没有区别的，但是上面的形式不推荐。因为元祖赋值是按顺序的，如果左边变量数量不足，那么右边的多余返回值会被自动忽略 note 在go中函数经常以返回一个err或者bool 值的形式来告诉函数在调用的时候是否出现问题。这是go处理异常的方式。 ","date":"2022-10-04","objectID":"/syntax/:3:1","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"Type定义 variable和expression的类型定义了这个variable的特征，例如这个值的大小，内部是如何表示的，可以对它做哪些操作，和它相关的函数有哪些。 type 可以定义一个新的类型（基于已有类型，并且具有他的一切特性） type name underlying-type type定义一般写在包级别的作用域中，这样对整个包中的代码都是可见的。如果这个类型被导出了，也可以在包外使用. 我门先看一段简短的代码 package tempconv import \"fmt\" type Celsius float64 type Fahrenheit float64 const ( AbsoluteZeroC Celsius = -273.15 FreezingC Celsius = 0 BoilingC Celsius = 100 ) func CToF (c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } func FToC (f Fahrenheit) Celsius { return Celsius((f-32) * 5 /9) } 这段代码定义了温度的两种表示方法Celsius(摄氏度)和Fahrenheit(华氏度),两者的基本类型都是Float64。Celsius和Fahrenheit是两种不同的类型，所以两者不能做数学运算和逻辑运算。这样做是为了防止因为表示温度的单位不同而导致错误。Celsius(t)和Fahrenheit(t)是转型器，并不是函数调用。type定义显示的改变了类型的意义。 对于任意的类型T都有对应的转型操作T(x)用来将其他类型的值x转型成T类型的值. 当两种类型的基本类型是相同的时候，转型才被允许。如果是指针类型，被指向的值必须具有相同的基本类型才能够被转型。这些转型只会转换type但是值的表示是不会改变的。 转型也能发生在数值类型，string,和一些slice类型之间，这些转型可能会改变值的表示，比如将float类型转型成integer类型会丢失小数点。将string类型转成[]byte slice. 基本类型决定了 named type的结构和表示，以及所支持的操作，就像是基本类型被直接使用一样。不过，我们可以为named type 额外定义一些操作。 func (c Celsius) string() string { return fmt.Sprintf(\"%g*c\"，c) } 这段代码会返回Celsius的string类型并以*c结尾 note 许多类型都定义了string操作，这样在使用fmt打印的时候，就可以更加的好看 ","date":"2022-10-04","objectID":"/syntax/:4:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"packages 和 Files go中的package就像其他语言中的libraries 和 modules. 提供modularity(模块化),encapsulation(封装),separate compilation(隔离编译)和reuse(重用)特性。代码可以写在package中多个.go结尾的文件中。 每个包都有一个独立的命名空间，当我们要在外部使用这个包中的东西的时候，必须要加上包名作为前缀。例如要是用image包中的Decode我们需要 image.Docode,要使用utf16包中的Decode我们需要utf16.Decode. 要想导出package中的变量，定义，函数，我们必须在定义他们的时候以大写字母开头。我们举一个例子 //Package tempconv performs Celsius and Fahrenheit conversions. package tempconv import \"fmt\" type Celsius float64 type Fahrenheit float64 const ( AbsoluteZeroC Celsius = -273.15 FreezingC Celsius = 0 BoilingC celsius = 100 ) func (c Celsius) String() string { return fmt.Sprintf(\"%g*c\",c) } func (f Fahrenheit) String() string { return fmt.Sprintf(\"%g*F\",f) } package tempconv // CToF converts a Celsius temperature to Fahrenheit. func CToF (c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } //FToC converts a Fahrenheit temperature to Celsius. func FToC (f Fahrenheit) Celsius { return Celsius((f-32) *5 / 9) } 在包中，所有文件都应以包定义开头，这里是 package tempconv. 当包被导入后，我们就可以使用tempconv.CToF 这样的形式使用包中暴露出来的成员(以大写字母开头)。 ","date":"2022-10-04","objectID":"/syntax/:5:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"imports 在go中，所有的包都被一个唯一的import path标识(string 类型) 比如\"foo/tempconv\"。import path 表明了包含包中的文件的路径. 除了import path 每个包还有一个package name, 相对import path要短很多. 通常一个包的名字通常是import path 的最后一个分割段 比如foot/tempconv 的包名就是tempconv. // Cf converts its numeric argument to Celsius and Fahrenheit. package main import ( \"fmt\" \"os\" \"strconv\" \"foo/tempconv\" ) func main() { for _, arg := range os.Args[1:] { t, err := strconv.ParseFloat(arg, 64) if err != nil { fmt.Fprintf(os.Stderr, \"cf: %v\\n\", err) os.Exit(1) } f := tempconv.Fahrenheit(t) c := tempconv.Celsius(t) fmt.Printf(\"%s = %s, %s = %s\\n\", f, tempconv.FToC(f), c, tempconv.CToF(c)) } } 我们应直接使用tempconv(包名)而不是import path,我们也可以在import 的时候定义包的别名以防止冲突. package main import ( \"fmt\" \"os\" \"strconv\" conv \"foo/tempconv\" ) func main () { for _, arg := range os.Args[1:] { t,err := strconv.ParseFloat(arg,64) if err != nil { fmt.Fprintf(os.Stderr,\"cf:%v\\n\",err) os.Exit(1) } f := conv.Fahrenheit(t) c := conv.Celsius(t) fmt.Printf(\"%s = %s, %s = %s\\n\", f,conv.FToC(f),c,conv.CToF(c)) } } 导入未使用的包是不被允许的，在编译前必须删除多余的导入，推荐使用golang.org/x/tools/cmd/goimports 工具。 它会自动导入和删除不必要的导入。 ","date":"2022-10-04","objectID":"/syntax/:5:1","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"包初始化 package会按定义的顺序先初始化包级别的变量（但是会先解决依赖） var a = b + c // a initialized third, to 3 var b = f() // b initialized second, to 2, by calling f var c = 1 // c initialized first, to 1 func f() int { return c + 1 } 为了使用导入的程序包，必须首先对其进行初始化，而包的初始化过程可以由这张图表示出来 流程是 先导入包（递归导入） 初始化const 初始化var 调用init()函数 warning 在golang中 init()函数会在初始化时被自动调用，但是init()函数不能够被手动调用。同一个包中可以出现多个init()函数，但是init()的调用顺序是不被保证的。所以尽量只写一个init()函数 warning 需要注意的是，golang中不允许导入了，但未被使用的包存在，也不允许定义了但未使用的变量存在 ","date":"2022-10-04","objectID":"/syntax/:5:2","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"golang 的functional options","date":"2022-10-04","objectID":"/functional_options/","tags":["golang"],"title":"golang functional-options","uri":"/functional_options/"},{"categories":["golang"],"content":"Functional Options go语言的函数没有重载以及默认参数的功能，这个时候生成一个i对象会变得极其麻烦 type Person struct{ Name string Age int Country string Gender string Height string Address string } func main(){ person :=Person{ Name:\"张三\", Age: -1， Country: \"China\", Gender: \"Male\", Height: \"-1\", Address: \"unknown\", } } 我们可以使用函数式选项来解决这一问题。 type Person struct { Name string Age int Country string Gender string Height string Address string } // 将func(*Person)这种类型的函数简化命名 type per func(*Person) func Country(country string) per { return func(person *Person) { person.Country = country } } func Gender(gender string) per{ return func(person *Person){ person.Gender = gender } } func Gender(gender string) per{ return func(person *Person){ person.Gender = gender } } func Address(address string) per{ return func(person *Person){ person.Address = address } } // NewPerson ... func NewPerson(name string,ops ...per) *Person { person := \u0026Person{ Name: name, Age: -1, Country: \"China\", Gender: \"Male\", Height: 0, Address: \"unknown\", } for _,op:= range ops { op(person) } return person } ","date":"2022-10-04","objectID":"/functional_options/:1:0","tags":["golang"],"title":"golang functional-options","uri":"/functional_options/"},{"categories":["golang"],"content":"用法： package main import ( \"fmt\" op \"studygo/pattern/functionOptions\" ) // main ... func main() { person1 := op.NewPerson(\"zhangsan\") fmt.Println(person1) person2 := op.NewPerson(\"Marry\", op.Gender(\"Female\"), op.Country(\"Japan\")) fmt.Println(person2) } ","date":"2022-10-04","objectID":"/functional_options/:1:1","tags":["golang"],"title":"golang functional-options","uri":"/functional_options/"},{"categories":["golang"],"content":"golang 中一些tips 从effective go那边超过来的","date":"2022-10-04","objectID":"/tips/","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"this artical is copied from golang official ","date":"2022-10-04","objectID":"/tips/:0:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Formatting Go let the machine take care of most formatting issues. The gofmt program(also available as go fmt,which operates at the package level rather than source file level) emits the source in a standard style of indentation and vertical alignment,retaining and if necessary reformatting comments. before formatted type T struct{ name string //name of the object value int//its value } after formatted type T struct { name string // name of the object value int // its value } ","date":"2022-10-04","objectID":"/tips/:1:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Commentary Go Support C++ style comments. Line comments are norm;block comments appear mostly as package comments. The godoc process Go source files to extract documentation about the contents of the package. Comments that appear before top-level declarations,with no intervening newlines,are extracted along with the declaration to serve as explanatory text for the item. Every package should have a package comment,a block comment preceding the package clause. For multi-file packages,the package comment only needs to be present in one file. The package comment should introduce the package and provide information revelant to the whole package.It will appear first on the godoc page and should set up the detailed documentation as follows. /* Package regexp implements a simple library for regular expressions. The syntax of the regular expressions accepted is: regexp: concatenation { '|' concatenation } concatenation: { closure } closure: term [ '*' | '+' | '?' ] term: '^' '$' '.' character '[' [ '^' ] character-ranges ']' '(' regexp ')' */ package regexp If the package is simple,the package comment can be brief // Package path implements utility routines for // manipulating slash-separated filename paths. Depending on the context, godoc might not even reformat comments, so make sure they look good straight up: use correct spelling, punctuation, and sentence structure, fold long lines, and so on. Inside a package,any comment immediately preceding a top-level delaration serves as doc comment for that declaration.Every exported(Capitalized) name in a program should have a doc comment. Doc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared. // Compile parses a regular expression and returns, if successful, // a Regexp that can be used to match against text. func Compile(str string) (*Regexp, error) { If every doc comment begins with the name of the item it describes, you can use the doc subcommand of the go tool and run the output through grep. Imagine you couldn’t remember the name “Compile” but were looking for the parsing function for regular expressions, so you ran the command, $ go doc -all regexp | grep -i parse If all the doc comments in the package began, “This function…”, grep wouldn’t help you remember the name. But because the package starts each doc comment with the name, you’d see something like this, which recalls the word you’re looking for. $ go doc -all regexp | grep -i parse Compile parses a regular expression and returns, if successful, a Regexp MustCompile is like Compile but panics if the expression cannot be parsed. parsed. It simplifies safe initialization of global variables holding $ Go`s declaration syntax allows grouping of declarations.A single doc comment can introduce a group of related constants or variables.Since the whole declaration is presented,such a comment can often be perfunctory // Error codes returned by failures to parse an expression. var ( ErrInternal = errors.New(\"regexp: internal error\") ErrUnmatchedLpar = errors.New(\"regexp: unmatched '('\") ErrUnmatchedRpar = errors.New(\"regexp: unmatched ')'\") ) Grouping can also indicate relationships between items,such as the fact that a set of variables is protected by a mutex var ( countLock sync.Mutex inputCount uint32 outputCount uint32 errorCount uint32 ) ","date":"2022-10-04","objectID":"/tips/:2:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Names The visibility of a name outside a package is determined by whether its first character is upper case. ","date":"2022-10-04","objectID":"/tips/:3:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"package names When a package is imported,the package name becomes an accessor for the contents After import \"bytes\" bytes.Buffer This means that the package name should be good:short concise,evocative.By convention,packages a given lower case,single-word names;there should be no need for underscores or mixedCaps.Err on the side of brevity,since everyone using you package will be typing that name. Another convention is that the package name is the base name of its source directory; the package in src/encoding/base64 is imported as “encoding/base64” but has name base64, not encoding_base64 and not encodingBase64. The importer of a package will use the name to refer to its contents,so exported names in the package can use that fact to avoid repetition. For instance,the buffered reader type in bufio package is called Reader not BufReader,because users see it as bufio.Reader,which is a clear,concise name. Another short example is once.Do; once.Do(setup) reads well and would not be improved by writing once.DoOrWaitUntilDone(setup). Long names don’t automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name. ","date":"2022-10-04","objectID":"/tips/:3:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Getters Go doesn’t provide automatic support for getters and setters. There’s nothing wrong with providing getters and setters yourself, and it’s often appropriate to do so, but it’s neither idiomatic nor necessary to put Get into the getter’s name. If you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported), not GetOwner. The use of upper-case names for export provides the hook to discriminate the field from the method. A setter function, if needed, owner := obj.Owner() if owner != user { obj.SetOwner(user) } ","date":"2022-10-04","objectID":"/tips/:3:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interface names By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc. ","date":"2022-10-04","objectID":"/tips/:3:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"MixedCaps Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names. ","date":"2022-10-04","objectID":"/tips/:3:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Control structures ","date":"2022-10-04","objectID":"/tips/:4:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Redeclaration and reassignment f,err := os.Open(name) d,err := f.Stat() The call to f.Stat uses the existing err variable declared above,and just gives it a new value ","date":"2022-10-04","objectID":"/tips/:4:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"For There are three forms,only one of which has semicolons //like a c for for init;condition;post{ } //like a C While for condition { } // like a c For(;;) for { } Shot declarations make it easy to declare the index varible right in the loop sum := 0 for i := 0;i\u003c10;i++{ sum += i } If you’re looping over an array, slice, string, or map, or reading from a channel, a range clause can manage the loop. for key,value := range oldMap { newMap[key] = value } If you only need the first item in the range (the key or index), drop the second: for key := range m { if key.expired() { delete(m,key) } } If you only need the second item in the range (the value), use the blank identifier, an underscore, to discard the first: sum := 0 for _,value := range array { sum += value } For strings, the range does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD. (The name (with associated builtin type) rune is Go terminology for a single Unicode code point. See the language specification for details.) The loop for pos, char := range \"日本\\x80語\" { // \\x80 is an illegal UTF-8 encoding fmt.Printf(\"character %#U starts at byte position %d\\n\", char, pos) } prints character U+65E5 '日' starts at byte position 0 character U+672C '本' starts at byte position 3 character U+FFFD '�' starts at byte position 6 character U+8A9E '語' starts at byte position 7 Finally, Go has no comma operator and \\++ and – are statements not expressions. Thus if you want to run multiple variables in a for you should use parallel assignment (although that precludes ++ and –). for i,j := 0,len(a)-1 ;i\u003cj;i,j = i+1,j-1{ a[i],a[j] = a[j],a[i] } ","date":"2022-10-04","objectID":"/tips/:4:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Switch Go’s switch is more general than C’s. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the switch has no expression it switches on true. It’s therefore possible—and idiomatic—to write an if-else-if-else chain as a switch. func unhex(c byte) byte { switch { case '0' \u003c= c \u0026\u0026 c\u003c= '9': return c- '0' case 'a' \u003c= c \u0026\u0026 c \u003c='f': return c - 'a' + 10 case 'A' \u003c= c \u0026\u0026 c \u003c= 'F': return c - 'A' + 10 } return 0 } There is no automatic fall through,but cases can be presented in comma-separated lists. func shouldEscape(c byte) bool { switch c { case ' ', '?', '\u0026', '=', '#', '+', '%': return true } return false } Although they are not nearly as common in Go as some other C-like languages, break statements can be used to terminate a switch early. Sometimes, though, it’s necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and “breaking” to that label. This example shows both uses. Loop: for n := 0; n \u003c len(src); n += size { switch { case src[n] \u003c sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] \u003c sizeTwo: if n+1 \u003e= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]\u003c\u003cshift) } } Of course, the continue statement also accepts an optional label but it applies only to loops. ","date":"2022-10-04","objectID":"/tips/:4:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Type switch A switch can also be used to discover the dynamic type of an interface variable. Such a type switch uses the syntax of a type assertion with the keyword type inside the parentheses. var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\\n\", t) // %T prints whatever type t has case bool: fmt.Printf(\"boolean %t\\n\", t) // t has type bool case int: fmt.Printf(\"integer %d\\n\", t) // t has type int case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t has type *bool case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t has type *int } ","date":"2022-10-04","objectID":"/tips/:4:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Functions ","date":"2022-10-04","objectID":"/tips/:5:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"multiple return values One of Go’s unusual features is that functions and methods can return multiple values. This form can be used to improve on a couple of clumsy idioms in C programs: in-band error returns such as -1 for EOF and modifying an argument passed by address. In C, a write error is signaled by a negative count with the error code secreted away in a volatile location. In Go, Write can return a count and an error: “Yes, you wrote some bytes but not all of them because you filled the device”. The signature of the Write method on files from package os is: func (file *File) Write(b []byte) (n int, err error) and as the documentation says, it returns the number of bytes written and a non-nil error when n != len(b). This is a common style; see the section on error handling for more examples. A similar approach obviates the need to pass a pointer to a return value to simulate a reference parameter. Here’s a simple-minded function to grab a number from a position in a byte slice, returning the number and the next position. func nextInt(b []byte, i int) (int, int) { for ; i \u003c len(b) \u0026\u0026 !isDigit(b[i]); i++ { } x := 0 for ; i \u003c len(b) \u0026\u0026 isDigit(b[i]); i++ { x = x*10 + int(b[i]) - '0' } return x, i } You could use it to scan the numbers in an input slice b like this: for i := 0; i \u003c len(b); { x, i = nextInt(b, i) fmt.Println(x) } ","date":"2022-10-04","objectID":"/tips/:5:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Named result parameters The return or result “parameters” of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values. The names are not mandatory but they can make code shorter and clearer: they’re documentation. If we name the results of nextInt it becomes obvious which returned int is which. func nextInt(b []byte, pos int) (value, nextPos int) { ","date":"2022-10-04","objectID":"/tips/:5:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Defer Go’s defer statement schedules a function call (the deferred function) to be run immediately before the function executing the defer returns. It’s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. The canonical examples are unlocking a mutex or closing a file. // Contents returns the file's contents as a string. func Contents(filename string) (string, error) { f, err := os.Open(filename) if err != nil { return \"\", err } defer f.Close() // f.Close will run when we're finished. var result []byte buf := make([]byte, 100) for { n, err := f.Read(buf[0:]) result = append(result, buf[0:n]...) // append is discussed later. if err != nil { if err == io.EOF { break } return \"\", err // f will be closed if we return here. } } return string(result), nil // f will be closed if we return here. } The arguments to be deferred function are evaluated when the defer executes, not when the call executes.Besides avoiding worries about variable changing values as the function executes, this means that a single defer call sit can defer multiple function executions for i := 0; i \u003c 5; i++ { defer fmt.Printf(\"%d \", i) } Defered functions are executed in LIFO order,so this code will caause 4,3,2,1 to be printed when the function returns.A more plausible example is a simple way to trace function execution through the program. We could write a couple of simple tracing routine like this: func trace(s string) { fmt.Println(\"entering:\", s) } func untrace(s string) { fmt.Println(\"leaving:\", s) } // Use them like this: func a() { trace(\"a\") defer untrace(\"a\") // do something.... } We can do better by exploiting the fact that arguments to defer functions are evaluated when the defer executes. The tracing routine can set up the argument to the untracing routine. func trace(s string) string { fmt.Println(\"entering:\", s) return s } func un(s string) { fmt.Println(\"leaving:\", s) } func a() { defer un(trace(\"a\")) fmt.Println(\"in a\") } func b() { defer un(trace(\"b\")) fmt.Println(\"in b\") a() } func main() { b() } prints entering: b in b entering: a in a leaving: a leaving: b ","date":"2022-10-04","objectID":"/tips/:5:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Data ","date":"2022-10-04","objectID":"/tips/:6:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Allocation with new Go have two allocation primitives,the built-in function new and make.They do different things and apply to different types. new built-in function that allocates memory, new(T) allocates zeroed storage for a new item of type T and returns its address. it returns a pointer to a newly allocated zero value of type T. make built-in function make(T,args) creates slices,maps and channels only and it returns an initialized(not zeroed) value of type T(not *T) ","date":"2022-10-04","objectID":"/tips/:6:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Constructors and composite literals Sometimes the zero value isn’t good enough and an initializing constructor is necessary, as in this example derived from package os. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f } There’s a lot of boiler plate in there. We can simplify it using a composite literal, which is an expression that creates a new instance each time it is evaluated. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := File{fd, name, nil, 0} return \u0026f } Note that, unlike in C, it’s perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns. In fact, taking the address of a composite literal allocates a fresh instance each time it is evaluated, so we can combine these last two lines. return \u0026File{fd, name, nil, 0} The fields of a composite literal are laid out in order and must all be present. However, by labeling the elements explicitly as field:value pairs, the initializers can appear in any order, with the missing ones left as their respective zero values. Thus we could say return \u0026File{fd: fd, name: name} As a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions new(File) and \u0026File{} are equivalent. Composite literals can also be created for arrays, slices, and maps, with the field labels being indices or map keys as appropriate. In these examples, the initializations work regardless of the values of Enone, Eio, and Einval, as long as they are distinct. a := [...]string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} s := []string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} m := map[int]string{Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} ","date":"2022-10-04","objectID":"/tips/:6:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Allocation with make The built-in function make(T, args) serves a purpose different from new(T). It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is nil. For slices, maps, and channels, make initializes the internal data structure and prepares the value for use. For instance, make([]int, 10, 100) allocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array(When making a slice, the capacity can be omitted; see the section on slices for more information.) In contrast,new([]int) returns a pointer to a newly allocated,zeroed slice structure,that is,a pointer to a nil slice value. These examples illustrate the difference between new and make. var p *[]int = new([]int) // allocates slice structure; *p == nil; rarely useful var v []int = make([]int, 100) // the slice v now refers to a new array of 100 ints // Unnecessarily complex: var p *[]int = new([]int) *p = make([]int, 100, 100) // Idiomatic: v := make([]int, 100) Remember that make applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with new or take the address of a variable explicitly. ","date":"2022-10-04","objectID":"/tips/:6:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Arrays Arrays are useful when planning the detailed layout of memory and sometimes can help avoid allocation, but primarily they are a building block for slices, the subject of the next section. To lay the foundation for that topic, here are a few words about arrays. There are major differences between the ways arrays work in Go and C. In Go, Arrays are values. Assigning one array to another copies all the elements. In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it. The size of an array is part of its type. The types [10]int and [20]int are distinct. The value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array. func Sum(a *[3]float64) (sum float64) { for _, v := range *a { sum += v } return } array := [...]float64{7.0, 8.5, 9.1} x := Sum(\u0026array) // Note the explicit address-of operator But even this style isn’t idiomatic Go. Use slices instead. ","date":"2022-10-04","objectID":"/tips/:6:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Slices Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays. Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array. If a function takes a slice argument, changes it makes to the elements of the slice will be visible to the caller, analogous to passing a pointer to the underlying array. A Read function can therefore accept a slice argument rather than a pointer and a count; the length within the slice sets an upper limit of how much data to read. Here is the signature of the Read method of the File type in package os: func (f *File) Read(buf []byte) (n int, err error) The method returns the number of bytes read and an error value, if any. To read into the first 32 bytes of a larger buffer buf, slice (here used as a verb) the buffer. n, err := f.Read(buf[0:32]) Such slicing is common and efficient. In fact, leaving efficiency aside for the moment, the following snippet would also read the first 32 bytes of the buffer. var n int var err error for i := 0; i \u003c 32; i++ { nbytes, e := f.Read(buf[i:i+1]) // Read one byte. n += nbytes if nbytes == 0 || e != nil { err = e break } } The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The capacity of a slice, accessible by the built-in function cap, reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that len and cap are legal when applied to the nil slice, and return 0. func Append(slice,data[] byte) [] byte{ l := len(slice) if l+len(data)\u003ecap(slice){ //reallocate //Allocate double what`s needed,for future growth newSlice :=make([]byte,(l+len(data))*2) //Tye copy function is predeclared and works for any slice type. copy(newSlice,slice) slice = newSlice } slice = slice[0:l+len(data)] copy(slice[l:],data) return slice } We must return the slice afterwards because, although Append can modify the elements of slice, the slice itself (the run-time data structure holding the pointer, length, and capacity) is passed by value. The idea of appending to a slice is so useful it’s captured by the append built-in function. To understand that function’s design, though, we need a little more information, so we’ll return to it later. ","date":"2022-10-04","objectID":"/tips/:6:5","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Two-dimensional slices Go’s arrays and slices are one-dimensional. To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices, like this: type Transform [3][3]float64 // A 3x3 array, really an array of arrays. type LinesOfText [][]byte // A slice of byte slices. Because slices are variable-length, it is possible to have each inner slice be a different length. That can be a common situation, as in our LinesOfText example: each line has an independent length. text := LinesOfText{ []byte(\"Now is the time\"), []byte(\"for all good gophers\"), []byte(\"to bring some fun to the party.\"), } Sometimes it’s necessary to allocate a 2D slice, a situation that can arise when processing scan lines of pixels, for instance. There are two ways to achieve this. One is to allocate each slice independently; the other is to allocate a single array and point the individual slices into it. Which to use depends on your application. If the slices might grow or shrink, they should be allocated independently to avoid overwriting the next line; if not, it can be more efficient to construct the object with a single allocation. For reference, here are sketches of the two methods. First, a line at a time: // Allocate the top-level slice. picture := make([][]uint8, YSize) // One row per unit of y. // Loop over the rows, allocating the slice for each row. for i := range picture { picture[i] = make([]uint8, XSize) } And now as one allocation, sliced into lines: // Allocate the top-level slice, the same as before. picture := make([][]uint8, YSize) // One row per unit of y. // Allocate one large slice to hold all the pixels. pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8. // Loop over the rows, slicing each row from the front of the remaining pixels slice. for i := range picture { picture[i], pixels = pixels[:XSize], pixels[XSize:] } ","date":"2022-10-04","objectID":"/tips/:6:6","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Maps Maps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value). The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller. Maps can be constructed using the usual composite literal syntax with colon-separated key-value pairs, so it’s easy to build them during initialization. var timeZone = map[string]int{ \"UTC\": 0*60*60, \"EST\": -5*60*60, \"CST\": -6*60*60, \"MST\": -7*60*60, \"PST\": -8*60*60, } Assigning and fetching map values looks syntactically just like doing the same for arrays and slices except that the index doesn’t need to be an integer. offset := timeZone[\"EST\"] An attempt to fetch a map value with a key that is not present in the map will return the zero value for the type of the entries in the map. For instance, if the map contains integers, looking up a non-existent key will return 0. A set can be implemented as a map with value type bool. Set the map entry to true to put the value in the set, and then test it by simple indexing. attended := map[string]bool{ \"Ann\": true, \"Joe\": true, ... } if attended[person] { // will be false if person is not in the map fmt.Println(person, \"was at the meeting\") } Sometimes you need to distinguish a missing entry from a zero value. Is there an entry for “UTC” or is that 0 because it’s not in the map at all? You can discriminate with a form of multiple assignment. var seconds int var ok bool seconds,ok = timeZone[tz] For obvious reasons this is called the “comma ok” idiom. In this example, if tz is present, seconds will be set appropriately and ok will be true; if not, seconds will be set to zero and ok will be false. Here’s a function that puts it together with a nice error report: func offset(tz string) int { if seconds, ok := timeZone[tz]; ok { return seconds } log.Println(\"unknown time zone:\", tz) return 0 } To test for presence in the map without worrying about the actual value, you can use the blank identifier (_) in place of the usual variable for the value. _, present := timeZone[tz] To delete a map entry, use the delete built-in function, whose arguments are the map and the key to be deleted. It’s safe to do this even if the key is already absent from the map. delete(timeZone, \"PDT\") // Now on Standard Time ","date":"2022-10-04","objectID":"/tips/:6:7","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Printing Formatted printing in Go uses a style similar to C’s printf family but is richer and more general. The functions live in the fmt package and have capitalized names: fmt.Printf, fmt.Fprintf, fmt.Sprintf and so on. The string functions (Sprintf etc.) return a string rather than filling in a provided buffer. You don’t need to provide a format string. For each of Printf, Fprintf and Sprintf there is another pair of functions, for instance Print and Println. These functions do not take a format string but instead generate a default format for each argument. The Println versions also insert a blank between arguments and append a newline to the output while the Print versions add blanks only if the operand on neither side is a string. In this example each line produces the same output. fmt.Printf(\"Hello %d\\n\", 23) fmt.Fprint(os.Stdout, \"Hello \", 23, \"\\n\") fmt.Println(\"Hello\", 23) fmt.Println(fmt.Sprint(\"Hello \", 23)) The formatted print functions fmt.Fprint and friends take as a first argument any object that implements the io.Writer interface; the variables os.Stdout and os.Stderr are familiar instances. Here things start to diverge from C. First, the numeric formats such as %d do not take flags for signedness or size; instead, the printing routines use the type of the argument to decide these properties. var x uint64 = 1\u003c\u003c64 - 1 fmt.Printf(\"%d %x; %d %x\\n\", x, x, int64(x), int64(x)) prints: 18446744073709551615 ffffffffffffffff; -1 -1 If you just want the default conversion, such as decimal for integers, you can use the catchall format %v (for “value”); the result is exactly what Print and Println would produce. Moreover, that format can print any value, even arrays, slices, structs, and maps. Here is a print statement for the time zone map defined in the previous section. fmt.Printf(\"%v\\n\", timeZone) // or just fmt.Println(timeZone) which gives output: map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0] For maps, Printf and friends sort the output lexicographically by key. When printing a struct, the modified format %+v annotates the fields of the structure with their names, and for any value the alternate format %#v prints the value in full Go syntax. type T struct { a int b float64 c string } t := \u0026T{ 7, -2.35, \"abc\\tdef\" } fmt.Printf(\"%v\\n\", t) fmt.Printf(\"%+v\\n\", t) fmt.Printf(\"%#v\\n\", t) fmt.Printf(\"%#v\\n\", timeZone) prints: \u0026{7 -2.35 abc def} \u0026{a:7 b:-2.35 c:abc def} \u0026main.T{a:7, b:-2.35, c:\"abc\\tdef\"} map[string]int{\"CST\":-21600, \"EST\":-18000, \"MST\":-25200, \"PST\":-28800, \"UTC\":0} (Note the ampersands.) That quoted string format is also available through %q when applied to a value of type string or []byte. The alternate format %#q will use backquotes instead if possible. (The %q format also applies to integers and runes, producing a single-quoted rune constant.) Also, %x works on strings, byte arrays and byte slices as well as on integers, generating a long hexadecimal string, and with a space in the format (% x) it puts spaces between the bytes. Another handy format is %T, which prints the type of a value. fmt.Printf(\"%T\\n\", timeZone) prints: map[string]int If you want to control the default format for a custom type, all that’s required is to define a method with the signature String() string on the type. For our simple type T, that might look like this. func (t *T) String() string { return fmt.Sprintf(\"%d/%g/%q\", t.a, t.b, t.c) } fmt.Printf(\"%v\\n\", t) to print in the format 7/-2.35/\"abc\\tdef\" (If you need to print values of type T as well as pointers to T, the receiver for String must be of value type; this example used a pointer because that’s more efficient and idiomatic for struct types. See the section below on pointers vs. value receivers for more information.) Our String method is able to call Sprintf because the print routines are fully reentrant and can be wrapped this way. There is one important detail to understand about this approach, however: don’t construct a String method by calling Sprintf in a w","date":"2022-10-04","objectID":"/tips/:6:8","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Append Now we have the missing piece we needed to explain the design of the append built-in function. The signature of append is different from our custom Append function above. Schematically, it’s like this: func append(slice []T, elements ...T) []T where T is a placeholder for any given type. You can’t actually write a function in Go where the type T is determined by the caller. That’s why append is built in: it needs support from the compiler. What append does is append the elements to the end of the slice and return the result. The result needs to be returned because, as with our hand-written Append, the underlying array may change. This simple example x := []int{1,2,3} x = append(x, 4, 5, 6) fmt.Println(x) prints [1 2 3 4 5 6]. So append works a little like Printf, collecting an arbitrary number of arguments. But what if we wanted to do what our Append does and append a slice to a slice? Easy: use … at the call site, just as we did in the call to Output above. This snippet produces identical output to the one above. x := []int{1,2,3} y := []int{4,5,6} x = append(x, y...) fmt.Println(x) Without that …, it wouldn’t compile because the types would be wrong; y is not of type int. ","date":"2022-10-04","objectID":"/tips/:6:9","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Initialization Although it doesn’t look superficially very different from initialization in C or C++, initialization in Go is more powerful. Complex structures can be built during initialization and the ordering issues among initialized objects, even among different packages, are handled correctly. ","date":"2022-10-04","objectID":"/tips/:7:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Constants Constants in Go are just that—constant. They are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. For instance, 1\u003c\u003c3 is a constant expression, while math.Sin(math.Pi/4) is not because the function call to math.Sin needs to happen at run time. In Go, enumerated constants are created using the iota enumerator. Since iota can be part of an expression and expressions can be implicitly repeated, it is easy to build intricate sets of values. type ByteSize float64 const ( _ = iota // ignore first value by assigning to blank identifier KB ByteSize = 1 \u003c\u003c (10 * iota) MB GB TB PB EB ZB YB ) The ability to attach a method such as String to any user-defined type makes it possible for arbitrary values to format themselves automatically for printing. Although you’ll see it most often applied to structs, this technique is also useful for scalar types such as floating-point types like ByteSize. func (b ByteSize) String() string { switch { case b \u003e= YB: return fmt.Sprintf(\"%.2fYB\", b/YB) case b \u003e= ZB: return fmt.Sprintf(\"%.2fZB\", b/ZB) case b \u003e= EB: return fmt.Sprintf(\"%.2fEB\", b/EB) case b \u003e= PB: return fmt.Sprintf(\"%.2fPB\", b/PB) case b \u003e= TB: return fmt.Sprintf(\"%.2fTB\", b/TB) case b \u003e= GB: return fmt.Sprintf(\"%.2fGB\", b/GB) case b \u003e= MB: return fmt.Sprintf(\"%.2fMB\", b/MB) case b \u003e= KB: return fmt.Sprintf(\"%.2fKB\", b/KB) } return fmt.Sprintf(\"%.2fB\", b) } The use here of Sprintf to implement ByteSize’s String method is safe (avoids recurring indefinitely) not because of a conversion but because it calls Sprintf with %f, which is not a string format: Sprintf will only call the String method when it wants a string, and %f wants a floating-point value. ","date":"2022-10-04","objectID":"/tips/:7:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Variables Variables can be initialized just like constants but the initializer can be a general expression computed at run time. var ( home = os.Getenv(\"HOME\") user = os.Getenv(\"USER\") gopath = os.Getenv(\"GOPATH\") ) ","date":"2022-10-04","objectID":"/tips/:7:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"The init function Finally, each source file can define its own niladic init function to set up whatever state is required. (Actually each file can have multiple init functions.) And finally means finally: init is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized. Besides initializations that cannot be expressed as declarations, a common use of init functions is to verify or repair correctness of the program state before real execution begins. func init() { if user == \"\" { log.Fatal(\"$USER not set\") } if home == \"\" { home = \"/home/\" + user } if gopath == \"\" { gopath = home + \"/go\" } // gopath may be overridden by --gopath flag on command line. flag.StringVar(\u0026gopath, \"gopath\", gopath, \"override default GOPATH\") } ","date":"2022-10-04","objectID":"/tips/:7:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Methods ","date":"2022-10-04","objectID":"/tips/:8:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Pointer vs Values As we saw with ByteSize, methods can be defined for any named type (except a pointer or an interface); the receiver does not have to be a struct. In the discussion of slices above, we wrote an Append function. We can define it as a method on slices instead. To do this, we first declare a named type to which we can bind the method, and then make the receiver for the method a value of that type. type ByteSlice []byte func (slice ByteSlice) Append(data []byte) []byte { l := len(slice) if l+len(data)\u003ecap(slice){ //reallocate //Allocate double what`s needed,for future growth newSlice :=make([]byte,(l+len(data))*2) //Tye copy function is predeclared and works for any slice type. copy(newSlice,slice) slice = newSlice } slice = slice[0:l+len(data)] copy(slice[l:],data) return slice } This still requires the method to return the updated slice.We can eliminate that clumsiness by redefining the method to take a pointer to a ByteSlice as its receiver,so the method can overwrite the caller`s slice. func (p *ByteSlice) Append(data []byte) { slice := *p l := len(slice) if l+len(data)\u003ecap(slice){ //reallocate //Allocate double what`s needed,for future growth newSlice :=make([]byte,(l+len(data))*2) //Tye copy function is predeclared and works for any slice type. copy(newSlice,slice) slice = newSlice } slice = slice[0:l+len(data)] copy(slice[l:],data) *p = slice } In fact,we can de even better. If we modify our function so it look like a standard Write method, like this, func (p *ByteSlice) Write(data []byte) (n int, err error) { slice := *p l := len(slice) if l+len(data)\u003ecap(slice){ //reallocate //Allocate double what`s needed,for future growth newSlice :=make([]byte,(l+len(data))*2) //Tye copy function is predeclared and works for any slice type. copy(newSlice,slice) slice = newSlice } slice = slice[0:l+len(data)] copy(slice[l:],data) *p = slice return len(data), nil } then the type *ByteSlice satisfies the standard interface io.Writer, which is handy. For instance, we can print into one. var b ByteSlice fmt.Fprintf(\u0026b, \"This hour has %d days\\n\", 7) We pass the address of a ByteSlice because only *ByteSlice satisfies io.Writer. The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers. This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (\u0026b).Write for us. By the way, the idea of using Write on a slice of bytes is central to the implementation of bytes.Buffer. ","date":"2022-10-04","objectID":"/tips/:8:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interfaces and other types Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here. We’ve seen a couple of simple examples already; custom printers can be implemented by a String method while Fprintf can generate output to anything with a Write method. Interfaces with only one or two methods are common in Go code, and are usually given a name derived from the method, such as io.Writer for something that implements Write. A type can implement multiple interfaces. For instance, a collection can be sorted by the routines in package sort if it implements sort.Interface, which contains Len(), Less(i, j int) bool, and Swap(i, j int), and it could also have a custom formatter. In this contrived example Sequence satisfies both. type Sequence []int //Methods required by sort.Interface func (s Sequence) Len() int { return len(s) } func (s Sequence) Less(i, j int) bool { return s[i] \u003c s[j] } func (s Sequence) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s Sequence) Copy() Sequence { copy: make(Sequence, 0, len(s)) return append(copy, s...) } func (s Sequence) String() string { s = s.Copy() sort.Sort(s) srt := \"[\" for i, elem := range s { // Loop is O(N²); will fix that in next example. if i \u003e 0 { str += \" \" } str += fmt.Sprint(elem) } return str + \"]\" } ","date":"2022-10-04","objectID":"/tips/:9:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Conversions The String method of Sequence is recreating the work that Sprint already dose for slices.(it also has complexity O(N2), which is poor.) We can share the effort (and also speed it up) if we convert the Sequence to a plain []int before calling Spring. func (s Sequence) String() string{ s = s.Copy() sort.Sort(s) return fmt.Sprint([]int(s)) } This method is another example of the conversion technique for calling Sprintf safely from a String method. Because the two types (Sequence and []int) are the same if we ignore the type name, it’s legal to convert between them. The conversion doesn’t create a new value, it just temporarily acts as though the existing value has a new type. (There are other legal conversions, such as from integer to floating point, that do create a new value.) It’s an idiom in Go programs to convert the type of an expression to access a different set of methods. As an example, we could use the existing type sort.IntSlice to reduce the entire example to this: type Sequence []int // Method for printing - sorts the elements before printing func (s Sequence) String() string { s =s.Copy() sort.IntSlice(s).Sort() return fmt.Sprint([]int(s)) } Now, instead of having Sequence implement multiple interfaces (sorting and printing), we’re using the ability of a data item to be converted to multiple types (Sequence, sort.IntSlice and []int), each of which does some part of the job. That’s more unusual in practice but can be effective. ","date":"2022-10-04","objectID":"/tips/:9:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interface conversions and type assertions Type switches are a form of conversion: they take an interface and, for each case in the switch, in a sense convert it to the type of that case. Here’s a simplified version of how the code under fmt.Printf turns a value into a string using a type switch. If it’s already a string, we want the actual string value held by the interface, while if it has a String method we want the result of calling the method. type Stringer interface { String() string } var value interface{} // Value provided by caller. switch str := value.(type) { case string: return str case Stringer: return str.String() } The first case finds a concrete value; the second converts the interface into another interface. It’s perfectly fine to mix types this way. What if there’s only one type we care about? If we know the value holds a string and we just want to extract it? A one-case type switch would do, but so would a type assertion. A type assertion takes an interface value and extracts from it a value of the specified explicit type. The syntax borrows from the clause opening a type switch, but with an explicit type rather than the type keyword: value.(typeName) and the result is a new value with the static type typeName. That type must either be the concrete type held by the interface, or a second interface type that the value can be converted to. To extract the string we know is in the value, we could write: But if it turns out that the value does not contain a string, the program will crash with a run-time error. To guard against that, use the “comma, ok” idiom to test, safely, whether the value is a string str, ok := value.(string) if ok { fmt.Printf(\"string value is: %q\\n\", str) } else { fmt.Printf(\"value is not a string\\n\") } If the type assertion fails, str will still exist and be of type string, but it will have the zero value, an empty string. As an illustration of the capability, here’s an if-else statement that’s equivalent to the type switch that opened this section. if str, ok := value.(string); ok { return str } else if str, ok := value.(Stringer); ok { return str.String() } ","date":"2022-10-04","objectID":"/tips/:9:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Generality If a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface. It also avoids the need to repeat the documentation on every instance of a common method. In such cases, the constructor should return an interface value rather than the implementing type. As an example, in the hash libraries both crc32.NewIEEE and adler32.New return the interface type hash.Hash32. Substituting the CRC-32 algorithm for Adler-32 in a Go program requires only changing the constructor call; the rest of the code is unaffected by the change of algorithm. A similar approach allows the streaming cipher algorithms in the various crypto packages to be separated from the block ciphers they chain together. The Block interface in the crypto/cipher package specifies the behavior of a block cipher, which provides encryption of a single block of data. Then, by analogy with the bufio package, cipher packages that implement this interface can be used to construct streaming ciphers, represented by the Stream interface, without knowing the details of the block encryption. The crypto/cipher interfaces look like this: type Block interface { BlockSize() int Encrypt(dst, src []byte) Decrypt(dst, src []byte) } type Stream interface { XORKeyStream(dst, src []byte) } Here’s the definition of the counter mode (CTR) stream, which turns a block cipher into a streaming cipher; notice that the block cipher’s details are abstracted away: // NewCTR returns a Stream that encrypts/decrypts using the given Block in // counter mode. The length of iv must be the same as the Block's block size. func NewCTR(block Block, iv []byte) Stream NewCTR applies not just to one specific encryption algorithm and data source but to any implementation of the Block interface and any Stream. Because they return interface values, replacing CTR encryption with other encryption modes is a localized change. The constructor calls must be edited, but because the surrounding code must treat the result only as a Stream, it won’t notice the difference. ","date":"2022-10-04","objectID":"/tips/:9:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interfaces and methods Since almost anything can have methods attached, almost anything can satisfy an interface. One illustrative example is in the http package, which defines the Handler interface. Any object that implements Handler can serve HTTP requests. type Handler interface { ServeHTTP(ResponseWriter, *Request) } ResponseWriter is itself an interface that provides access to the methods needed to return the response to the client. Those methods include the standard Write method, so an http.ResponseWriter can be used wherever an io.Writer can be used. Request is a struct containing a parsed representation of the request from the client. For brevity, let’s ignore POSTs and assume HTTP requests are always GETs; that simplification does not affect the way the handlers are set up. Here’s a trivial implementation of a handler to count the number of times the page is visited. // Simple counter server. type Counter struct { n int } func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) { ctr.n++ fmt.Fprintf(w, \"counter = %d\\n\", ctr.n) } (Keeping with our theme, note how Fprintf can print to an http.ResponseWriter.) In a real server, access to ctr.n would need protection from concurrent access. See the sync and atomic packages for suggestions. For reference, here’s how to attach such a server to a node on the URL tree. import \"net/http\" ... ctr := new(Counter) http.Handle(\"/counter\", ctr) But why make Counter a struct? An integer is all that’s needed. (The receiver needs to be a pointer so the increment is visible to the caller.) // Simpler counter server. type Counter int func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) { *ctr++ fmt.Fprintf(w, \"counter = %d\\n\", *ctr) } What if your program has some internal state that needs to be notified that a page has been visited? Tie a channel to the web page. // A channel that sends a notification on each visit. // (Probably want the channel to be buffered.) type Chan chan *http.Request func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) { ch \u003c- req fmt.Fprint(w, \"notification sent\") } Finally, let’s say we wanted to present on /args the arguments used when invoking the server binary. It’s easy to write a function to print the arguments. func ArgServer() { fmt.Println(os.Args) } How do we turn that into an HTTP server? We could make ArgServer a method of some type whose value we ignore, but there’s a cleaner way. Since we can define a method for any type except pointers and interfaces, we can write a method for a function. The http package contains this code: // The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers. If f is a function // with the appropriate signature, HandlerFunc(f) is a // Handler object that calls f. type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP calls f(w, req). func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) { f(w, req) } HandlerFunc is a type with a method, ServeHTTP, so values of that type can serve HTTP requests. Look at the implementation of the method: the receiver is a function, f, and the method calls f. That may seem odd but it’s not that different from, say, the receiver being a channel and the method sending on the channel. To make ArgServer into an HTTP server, we first modify it to have the right signature. // Argument server. func ArgServer(w http.ResponseWriter, req *http.Request) { fmt.Fprintln(w, os.Args) } ArgServer now has same signature as HandlerFunc, so it can be converted to that type to access its methods, just as we converted Sequence to IntSlice to access IntSlice.Sort. The code to set it up is concise: http.Handle(\"/args\", http.HandlerFunc(ArgServer)) When someone visits the page /args, the handler installed at that page has value ArgServer and type HandlerFunc. The HTTP server will invoke the method ServeHTTP of that type, with ArgServer as the receiver, which will in turn call ArgServer (via the invocation f(w, req) i","date":"2022-10-04","objectID":"/tips/:9:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"The blank identifier We’ve mentioned the blank identifier a couple of times now, in the context of for range loops and maps. The blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. It’s a bit like writing to the Unix /dev/null file: it represents a write-only value to be used as a place-holder where a variable is needed but the actual value is irrelevant. It has uses beyond those we’ve seen already. ","date":"2022-10-04","objectID":"/tips/:10:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"The blank identifier in multiple assignment If an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and makes it clear that the value is to be discarded. For instance, when calling a function that returns a value and an error, but only the error is important, use the blank identifier to discard the irrelevant value. if _, err := os.Stat(path); os.IsNotExist(err) { fmt.Printf(\"%s does not exist\\n\", path) } Occasionally you’ll see code that discards the error value in order to ignore the error; this is terrible practice. Always check error returns; they’re provided for a reason. // Bad! This code will crash if path does not exist. fi, _ := os.Stat(path) if fi.IsDir() { fmt.Printf(\"%s is a directory\\n\", path) } ","date":"2022-10-04","objectID":"/tips/:10:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Unused imports and variables It is an error to import a package or to declare a variable without using it. Unused imports bloat the program and slow compilation, while a variable that is initialized but not used is at least a wasted computation and perhaps indicative of a larger bug. When a program is under active development, however, unused imports and variables often arise and it can be annoying to delete them just to have the compilation proceed, only to have them be needed again later. The blank identifier provides a workaround. This half-written program has two unused imports (fmt and io) and an unused variable (fd), so it will not compile, but it would be nice to see if the code so far is correct. package main import ( \"fmt\" \"io\" \"log\" \"os\" ) func main() { fd, err := os.Open(\"test.go\") if err != nil { log.Fatal(err) } // TODO: use fd. } To silence complaints about the unused imports, use a blank identifier to refer to a symbol from the imported package. Similarly, assigning the unused variable fd to the blank identifier will silence the unused variable error. This version of the program does compile. package main import ( \"fmt\" \"io\" \"log\" \"os\" ) var _ = fmt.Printf // For debugging; delete when done. var _ io.Reader // For debugging; delete when done. func main() { fd, err := os.Open(\"test.go\") if err != nil { log.Fatal(err) } // TODO: use fd. _ = fd } By convention, the global declarations to silence import errors should come right after the imports and be commented, both to make them easy to find and as a reminder to clean things up later. ","date":"2022-10-04","objectID":"/tips/:10:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Import for side effect An unused import like fmt or io in the previous example should eventually be used or removed: blank assignments identify code as a work in progress. But sometimes it is useful to import a package only for its side effects, without any explicit use. For example, during its init function, the net/http/pprof package registers HTTP handlers that provide debugging information. It has an exported API, but most clients need only the handler registration and access the data through a web page. To import the package only for its side effects, rename the package to the blank identifier: import _ \"net/http/pprof\" This form of import makes clear that the package is being imported for its side effects, because there is no other possible use of the package: in this file, it doesn’t have a name. (If it did, and we didn’t use that name, the compiler would reject the program.) ","date":"2022-10-04","objectID":"/tips/:10:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interface checks As we saw in the discussion of interfaces above, a type need not declare explicitly that it implements an interface. Instead, a type implements the interface just by implementing the interface’s methods. In practice, most interface conversions are static and therefore checked at compile time. For example, passing an *os.File to a function expecting an io.Reader will not compile unless *os.File implements the io.Reader interface. Some interface checks do happen at run-time, though. One instance is in the encoding/json package, which defines a Marshaler interface. When the JSON encoder receives a value that implements that interface, the encoder invokes the value’s marshaling method to convert it to JSON instead of doing the standard conversion. The encoder checks this property at run time with a type assertion like: m, ok := val.(json.Marshaler) If it’s necessary only to ask whether a type implements an interface, without actually using the interface itself, perhaps as part of an error check, use the blank identifier to ignore the type-asserted value: if _, ok := val.(json.Marshaler); ok { fmt.Printf(\"value %v of type %T implements json.Marshaler\\n\", val, val) } One place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface. If a type—for example, json.RawMessage—needs a custom JSON representation, it should implement json.Marshaler, but there are no static conversions that would cause the compiler to verify this automatically. If the type inadvertently fails to satisfy the interface, the JSON encoder will still work, but will not use the custom implementation. To guarantee that the implementation is correct, a global declaration using the blank identifier can be used in the package: var _ json.Marshaler = (*RawMessage)(nil) In this declaration, the assignment involving a conversion of a *RawMessage to a Marshaler requires that *RawMessage implements Marshaler, and that property will be checked at compile time. Should the json.Marshaler interface change, this package will no longer compile and we will be on notice that it needs to be updated. The appearance of the blank identifier in this construct indicates that the declaration exists only for the type checking, not to create a variable. Don’t do this for every type that satisfies an interface, though. By convention, such declarations are only used when there are no static conversions already present in the code, which is a rare event. ","date":"2022-10-04","objectID":"/tips/:10:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Concurrency Concurrent programming is a large topic and there is space only for some Go-specific highlights here. Concurrent programming in many environments is made difficult by the subtleties required to implement correct access to shared variables. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan: Do not communicate by sharing memory; instead, share memory by communicating. This approach can be taken too far. Reference counts may be best done by putting a mutex around an integer variable, for instance. But as a high-level approach, using channels to control access makes it easier to write clear, correct programs. One way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, there’s still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Go’s approach to concurrency originates in Hoare’s Communicating Sequential Processes (CSP), it can also be seen as a type-safe generalization of Unix pipes. ","date":"2022-10-04","objectID":"/tips/:11:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Goroutines They’re called goroutines because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required. Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and management. Prefix a function or method call with the go keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. (The effect is similar to the Unix shell’s \u0026 notation for running a command in the background.) go list.Sort() // run list.Sort concurrently; don't wait for it. A function literal can be handy in a goroutine invocation. func Announce(message string, delay time.Duration) { go func() { time.Sleep(delay) fmt.Println(message) }() // Note the parentheses - must call the function. } In Go, function literals are closures: the implementation makes sure the variables referred to by the function survive as long as they are active. These examples aren’t too practical because the functions have no way of signaling completion. For that, we need channels. ","date":"2022-10-04","objectID":"/tips/:11:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Channels Like maps, channels are allocated with make, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel. ci := make(chan int) // unbuffered channel of integers cj := make(chan int, 0) // unbuffered channel of integers cs := make(chan *os.File, 100) // buffered channel of pointers to Files Unbuffered channels combine communication—the exchange of a value—with synchronization—guaranteeing that two calculations (goroutines) are in a known state. There are lots of nice idioms using channels. Here’s one to get us started. In the previous section we launched a sort in the background. A channel can allow the launching goroutine to wait for the sort to complete. c := make(chan int) // Allocate a channel. // Start the sort in a goroutine; when it completes, signal on the channel. go func() { list.Sort() c \u003c- 1 // Send a signal; value does not matter. }() doSomethingForAWhile() \u003c-c // Wait for sort to finish; discard sent value. Receivers always block until there is data to receive. If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until the value has been copied to the buffer; if the buffer is full, this means waiting until some receiver has retrieved a value. A buffered channel can be used like a semaphore, for instance to limit throughput. In this example, incoming requests are passed to handle, which sends a value into the channel, processes the request, and then receives a value from the channel to ready the “semaphore” for the next consumer. The capacity of the channel buffer limits the number of simultaneous calls to process. var sem = make(chan int, MaxOutstanding) func handle(r *Request) { sem \u003c- 1 // Wait for active queue to drain. process(r) // May take a long time. \u003c-sem // Done; enable next request to run. } func Serve(queue chan *Request) { for { req := \u003c-queue go handle(req) // Don't wait for handle to finish. } } This design has a problem, though: Serve creates a new goroutine for every incoming request, even though only MaxOutstanding of them can run at any moment. As a result, the program can consume unlimited resources if the requests come in too fast. We can address that deficiency by changing Serve to gate the creation of the goroutines. Here’s an obvious solution, but beware it has a bug we’ll fix subsequently: func Serve(queue chan *Request) { for req := range queue { sem \u003c- 1 go func() { process(req) // Buggy; see explanation below. \u003c-sem }() } } The bug is that in a Go for loop, the loop variable is reused for each iteration, so the req variable is shared across all goroutines. That’s not what we want. We need to make sure that req is unique for each goroutine. Here’s one way to do that, passing the value of req as an argument to the closure in the goroutine: func Serve(queue chan *Request) { for req := range queue { sem \u003c- 1 go func(req *Request) { process(req) \u003c-sem }(req) } } Compare this version with the previous to see the difference in how the closure is declared and run. Another solution is just to create a new variable with the same name, as in this example: func Serve(queue chan *Request) { for req := range queue { req := req // Create new instance of req for the goroutine. sem \u003c- 1 go func() { process(req) \u003c-sem }() } } but it’s legal and idiomatic in Go to do this. You get a fresh version of the variable with the same name, deliberately shadowing the loop variable locally but unique to each goroutine. Going back to the general problem of writing the server, another approach that manages resources well is to start a fixed number of handle goroutines all reading from the request channel. The number of goroutines limits the number of simultaneous calls to process. This Serve function also accepts a channel on which it will be told to exit; ","date":"2022-10-04","objectID":"/tips/:11:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Channels of channels One of the most important properties of Go is that a channel is a first-class value that can be allocated and passed around like any other. A common use of this property is to implement safe, parallel demultiplexing. In the example in the previous section, handle was an idealized handler for a request but we didn’t define the type it was handling. If that type includes a channel on which to reply, each client can provide its own path for the answer. Here’s a schematic definition of type Request. type Request struct { args []int f func([]int) int resultChan chan int } The client provides a function and its arguments, as well as a channel inside the request object on which to receive the answer. func sum(a []int) (s int) { for _, v := range a { s += v } return } request := \u0026Request{[]int{3, 4, 5}, sum, make(chan int)} // Send request clientRequests \u003c- request // Wait for response. fmt.Printf(\"answer: %d\\n\", \u003c-request.resultChan) On the server side, the handler function is the only thing that changes. There’s clearly a lot more to do to make it realistic, but this code is a framework for a rate-limited, parallel, non-blocking RPC system, and there’s not a mutex in sight. ","date":"2022-10-04","objectID":"/tips/:11:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Parallelization Another application of these ideas is to parallelize a calculation across multiple CPU cores. If the calculation can be broken into separate pieces that can execute independently, it can be parallelized, with a channel to signal when each piece completes. Let’s say we have an expensive operation to perform on a vector of items, and that the value of the operation on each item is independent, as in this idealized example. type Vector []float64 // Apply the operation to v[i], v[i+1] ... up to v[n-1]. func (v Vector) DoSome(i, n int, u Vector, c chan int) { for ; i \u003c n; i++ { v[i] += u.Op(v[i]) } c \u003c- 1 // signal that this piece is done } We launch the pieces independently in a loop, one per CPU. They can complete in any order but it doesn’t matter; we just count the completion signals by draining the channel after launching all the goroutines. const numCPU = 4 // number of CPU cores func (v Vector) DoAll(u Vector) { c := make(chan int, numCPU) // Buffering optional but sensible. for i := 0; i \u003c numCPU; i++ { go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c) } // Drain the channel. for i := 0; i \u003c numCPU; i++ { \u003c-c // wait for one task to complete } // All done. } Rather than create a constant value for numCPU, we can ask the runtime what value is appropriate. The function runtime.NumCPU returns the number of hardware CPU cores in the machine, so we could write var numCPU = runtime.NumCPU() There is also a function runtime.GOMAXPROCS, which reports (or sets) the user-specified number of cores that a Go program can have running simultaneously. It defaults to the value of runtime.NumCPU but can be overridden by setting the similarly named shell environment variable or by calling the function with a positive number. Calling it with zero just queries the value. Therefore if we want to honor the user’s resource request, we should write var numCPU = runtime.GOMAXPROCS(0) Be sure not to confuse the ideas of concurrency—structuring a program as independently executing components—and parallelism—executing calculations in parallel for efficiency on multiple CPUs. Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go’s model. For a discussion of the distinction, see the talk cited in this blog post. ","date":"2022-10-04","objectID":"/tips/:11:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"A leaky buffer The tools of concurrent programming can even make non-concurrent ideas easier to express. Here’s an example abstracted from an RPC package. The client goroutine loops receiving data from some source, perhaps a network. To avoid allocating and freeing buffers, it keeps a free list, and uses a buffered channel to represent it. If the channel is empty, a new buffer gets allocated. Once the message buffer is ready, it’s sent to the server on serverChan. var freeList = make(chan *Buffer, 100) var serverChan = make(chan *Buffer) func client() { for { var b *Buffer // Grab a buffer if available; allocate if not. select { case b = \u003c-freeList: // Got one; nothing more to do. default: // None free, so allocate a new one. b = new(Buffer) } load(b) // Read next message from the net. serverChan \u003c- b // Send to server. } } The server loop receives each message from the client, processes it, and returns the buffer to the free list. func server() { for { b := \u003c-serverChan // Wait for work. process(b) // Reuse buffer if there's room. select { case freeList \u003c- b: // Buffer on free list; nothing more to do. default: // Free list full, just carry on. } } } The client attempts to retrieve a buffer from freeList; if none is available, it allocates a fresh one. The server’s send to freeList puts b back on the free list unless the list is full, in which case the buffer is dropped on the floor to be reclaimed by the garbage collector. (The default clauses in the select statements execute when no other case is ready, meaning that the selects never block.) This implementation builds a leaky bucket free list in just a few lines, relying on the buffered channel and the garbage collector for bookkeeping. ","date":"2022-10-04","objectID":"/tips/:11:5","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Errors Library routines must often return some sort of error indication to the caller. As mentioned earlier, Go’s multivalue return makes it easy to return a detailed error description alongside the normal return value. It is good style to use this feature to provide detailed error information. For example, as we’ll see, os.Open doesn’t just return a nil pointer on failure, it also returns an error value that describes what went wrong. By convention, errors have type error, a simple built-in interface. type error interface { Error() string } A library writer is free to implement this interface with a richer model under the covers, making it possible not only to see the error but also to provide some context. As mentioned, alongside the usual *os.File return value, os.Open also returns an error value. If the file is opened successfully, the error will be nil, but when there is a problem, it will hold an os.PathError: // PathError records an error and the operation and // file path that caused it. type PathError struct { Op string // \"open\", \"unlink\", etc. Path string // The associated file. Err error // Returned by the system call. } func (e *PathError) Error() string { return e.Op + \" \" + e.Path + \": \" + e.Err.Error() } PathError’s Error generates a string like this: open /etc/passwx: no such file or directory Such an error, which includes the problematic file name, the operation, and the operating system error it triggered, is useful even if printed far from the call that caused it; it is much more informative than the plain “no such file or directory”. When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. For example, in package image, the string representation for a decoding error due to an unknown format is “image: unknown format”. Callers that care about the precise error details can use a type switch or a type assertion to look for specific errors and extract details. For PathErrors this might include examining the internal Err field for recoverable failures. for try := 0; try \u003c 2; try++ { file, err = os.Create(filename) if err == nil { return } if e, ok := err.(*os.PathError); ok \u0026\u0026 e.Err == syscall.ENOSPC { deleteTempFiles() // Recover some space. continue } return } The second if statement here is another type assertion. If it fails, ok will be false, and e will be nil. If it succeeds, ok will be true, which means the error was of type *os.PathError, and then so is e, which we can examine for more information about the error. ","date":"2022-10-04","objectID":"/tips/:12:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Panic The usual way to report an error to a caller is to return an error as an extra return value. The canonical Read method is a well-known instance; it returns a byte count and an error. But what if the error is unrecoverable? Sometimes the program simply cannot continue. For this purpose, there is a built-in function panic that in effect creates a run-time error that will stop the program (but see the next section). The function takes a single argument of arbitrary type—often a string—to be printed as the program dies. It’s also a way to indicate that something impossible has happened, such as exiting an infinite loop. // A toy implementation of cube root using Newton's method. func CubeRoot(x float64) float64 { z := x/3 // Arbitrary initial value for i := 0; i \u003c 1e6; i++ { prevz := z z -= (z*z*z-x) / (3*z*z) if veryClose(z, prevz) { return z } } // A million iterations has not converged; something is wrong. panic(fmt.Sprintf(\"CubeRoot(%g) did not converge\", x)) } This is only an example but real library functions should avoid panic. If the problem can be masked or worked around, it’s always better to let things continue to run rather than taking down the whole program. One possible counterexample is during initialization: if the library truly cannot set itself up, it might be reasonable to panic, so to speak. var user = os.Getenv(\"USER\") func init() { if user == \"\" { panic(\"no value for $USER\") } } ","date":"2022-10-04","objectID":"/tips/:12:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Recover When panic is called, including implicitly for run-time errors such as indexing a slice out of bounds or failing a type assertion, it immediately stops execution of the current function and begins unwinding the stack of the goroutine, running any deferred functions along the way. If that unwinding reaches the top of the goroutine’s stack, the program dies. However, it is possible to use the built-in function recover to regain control of the goroutine and resume normal execution. A call to recover stops the unwinding and returns the argument passed to panic. Because the only code that runs while unwinding is inside deferred functions, recover is only useful inside deferred functions. One application of recover is to shut down a failing goroutine inside a server without killing the other executing goroutines. func server(workChan \u003c-chan *Work) { for work := range workChan { go safelyDo(work) } } func safelyDo(work *Work) { defer func() { if err := recover(); err != nil { log.Println(\"work failed:\", err) } }() do(work) } In this example, if do(work) panics, the result will be logged and the goroutine will exit cleanly without disturbing the others. There’s no need to do anything else in the deferred closure; calling recover handles the condition completely. Because recover always returns nil unless called directly from a deferred function, deferred code can call library routines that themselves use panic and recover without failing. As an example, the deferred function in safelyDo might call a logging function before calling recover, and that logging code would run unaffected by the panicking state. With our recovery pattern in place, the do function (and anything it calls) can get out of any bad situation cleanly by calling panic. We can use that idea to simplify error handling in complex software. Let’s look at an idealized version of a regexp package, which reports parsing errors by calling panic with a local error type. Here’s the definition of Error, an error method, and the Compile function. // Error is the type of a parse error; it satisfies the error interface. type Error string func (e Error) Error() string { return string(e) } // error is a method of *Regexp that reports parsing errors by // panicking with an Error. func (regexp *Regexp) error(err string) { panic(Error(err)) } // Compile returns a parsed representation of the regular expression. func Compile(str string) (regexp *Regexp, err error) { regexp = new(Regexp) // doParse will panic if there is a parse error. defer func() { if e := recover(); e != nil { regexp = nil // Clear return value. err = e.(Error) // Will re-panic if not a parse error. } }() return regexp.doParse(str), nil } If doParse panics, the recovery block will set the return value to nil—deferred functions can modify named return values. It will then check, in the assignment to err, that the problem was a parse error by asserting that it has the local type Error. If it does not, the type assertion will fail, causing a run-time error that continues the stack unwinding as though nothing had interrupted it. This check means that if something unexpected happens, such as an index out of bounds, the code will fail even though we are using panic and recover to handle parse errors. With error handling in place, the error method (because it’s a method bound to a type, it’s fine, even natural, for it to have the same name as the builtin error type) makes it easy to report parse errors without worrying about unwinding the parse stack by hand: if pos == 0 { re.error(\"'*' illegal at start of expression\") } By the way, this re-panic idiom changes the panic value if an actual error occurs. However, both the original and new failures will be presented in the crash report, so the root cause of the problem will still be visible. Thus this simple re-panic approach is usually sufficient—it’s a crash after all—but if you want to display only the original value, you can write a little more code to filter unexpe","date":"2022-10-04","objectID":"/tips/:12:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"golang反射, 接口值，基本使用","date":"2022-10-04","objectID":"/reflect/","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"会想起来写这篇博客是因为，最近总是在想怎么让golang的代码写的更动态一点。再加上最近在关注架构上面的事情，无意中让我看到了gonet这个框架中对golang反射的使用。让我一时间有种惊讶的感觉（这东西还能这么用？😂）, 于是感觉还是先把这上面的只是恶补一下，也许对后面写架构有好处也不一定呢。 ","date":"2022-10-04","objectID":"/reflect/:0:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"引言 在讨论反射之前，先说一下反射的利弊。反射可以用来做非常灵活的工作，但是反射的使用往往和代码的可读性走向对立面。这唤起了我在第一家公司的记忆。 第一家公司对于游戏的理解非常透彻，主程的水平非常的高，对游戏中各个元素的抽象非常透彻。他对代码的优化，以及简洁性也有一定的偏执。 项目解耦非常彻底，这应该是一个对项目里所有人都非常友好的框架。但是对我不是，我经常被模块里面的各种抽象和继承弄得烦不胜烦。 因为lua不像java那样有非常标准的面向对象概念，lua是函数式语言，lua的table数据结构可以用来实现很多数据结构，链表，队列，甚至用它实现一套面向对象。但是，不是语言原生支持的东西就总是有别扭的地方。项目没有任何文档，我在完全不了解框架的情况下开始了工作。印象最深的是，我经常担心我用的对象里面是没有那个字段的，于是逼迫着我去仔细梳理一遍代码的来龙去脉。这种体验让我感觉非常糟糕。加上没有类型检查，没有debug调试器（把我喜欢用调试器的毛病给纠正过来了，现在我只习惯打log😂） 而反射的使用，就会带来可读性的问题。应用反射的最主要目的是为了提高代码的灵活性，简洁性，复用率。但是反射会模糊程序内部逻辑，还会有性能问题。反射代码会比普通的代码要更加难读。所以反射的使用应该慎重。反射是一把双刃剑。 ","date":"2022-10-04","objectID":"/reflect/:1:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"基本概念 golang 的reflect包提供了反射支持，golang中有两个重要类型Type和Value,任意的接口值都由reflect.Type 和 reflect.Value组成 ","date":"2022-10-04","objectID":"/reflect/:2:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"接口值 简单说接口值就是由reflect.Type 和 reflect.Value组成的值. Type部分保存了他的动态类型描述符，value部分保存了他的动态值。 接口值的作用是用来描述。反射的基本理念就是让程序能够自我描述，那么接口值的定义就是为了能够让程序自我描述。 动态类型描述符 对于go语言这种静态类型语言，类型只是编译期的概念。类型不是值，类型信息被称为类型描述符。所以接口值中的类型部分代表类型的描述符 看下面的代码 var w io.Writer //w是一个io.Writer类型的空接口值 w = os.Stdout //将*os.File类型的值赋值给变量w w = new(bytes.Buffer) // 将*bytes.Buffer类型的值赋值给变量w w = nil // 将nil赋值给接口值 由浅入深 先看第一行代码 var w io.Writer 定义了一个空的接口值, 这里表明w只能接收实现了io.Writer的接口的接口值。但是对于w本身来说他的内部是这样的。这里表明，他没有描述任何具体类型的值 golang中只有值传递，而接口值是用来描述存储在接口值用值的类型描述符和它的真实值的 再看第二行，我们给接口值一个值 w = os.Stdout 此时 w的内部接口是这样的 前面说过接口值的作用是用来描述，这里接口值传达的信息是，我描述了一个*os.File类型的值, 到这里的时候，是不是一下就清晰了。 第三行 w = new(bytes.Buffer) 这里w被用来描述*bytes.Buffer返回的值 第四行 再将w内部制空，让它不在描述任何值 w = nil 接口值可以用==和!=来比较，但是只有当接口值都为nil或者它们的动态类型相同且动态值也可以用==去判断相等。 如果两个接口值动态类型相同，但是动态类型不可比较（切片就属于这种）是会导致panic的（注意，因为反射的代码没有类型检查，所以可以被编译通过，只有运行的时候才会报错, 所以要尤为注意） var x interface{} = []int{1, 2, 3} fmt.Println(x == x) // panic: comparing uncomparable type []int 一个包含nil指针的接口不是nil接口 一个不包含任何值的nil接口值，和一个刚好包含nil指针的接口值是不同的 空的接口值是还没有被赋值的接口值（golang中，都是值，空接口也是值），没有被赋值的接口长这样 而包含了nil指针的接口值长这样 空接口值是指它内部的type 和 value都为nil，这是 w == nil 时才回返回true ","date":"2022-10-04","objectID":"/reflect/:2:1","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"反射的类型对象 reflect.Type reflect包提供reflect.TypeOf()获取任意值的类型对象(reflect.Type), 通过类型对象，我们就可以知道任意值的类型信息 但是你可能会疑惑，为什么我直接传原值就可以，而不需要传接口值。因为reflect.TypeOf()的函数签名是这样的reflect.TypeOf(interface{})在参数被传入的时候，会自动生成接口值 package main import ( \"fmt\" \"reflect\" ) func main() { var a int typeOfA := reflect.TypeOf(a) //获取类型变量 fmt.Println(typeOfA.Name(), typeOfA.Kind()) //获取类型名(int)，可类型种类(int) } int int Name(),Kind()是类型对象的成员函数分别用来获取类型名，和类型的种类 约定 文章里reflect.TypeOf()和reflect.ValueOf()都是reflect.TypeOf(interface{})和reflect.ValueOf(interface{})的简写 ","date":"2022-10-04","objectID":"/reflect/:2:2","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"反射的类型 type 和 种类 Kind Type指的是原生go 数据类型和使用type关键字定义的类型的集合,而Kind指的是种类要比Type更加范化。在需要区分大品种的时候，我们会用到Kind。 Kind的定义 Kind在reflect包的定义中有如下 type Kind uint const ( Invalid Kind = iota // 非法类型 Bool // 布尔型 Int // 有符号整型 Int8 // 有符号8位整型 Int16 // 有符号16位整型 Int32 // 有符号32位整型 Int64 // 有符号64位整型 Uint // 无符号整型 Uint8 // 无符号8位整型 Uint16 // 无符号16位整型 Uint32 // 无符号32位整型 Uint64 // 无符号64位整型 Uintptr // 指针 Float32 // 单精度浮点数 Float64 // 双精度浮点数 Complex64 // 64位复数类型 Complex128 // 128位复数类型 Array // 数组 Chan // 通道 Func // 函数 Interface // 接口 Map // 映射 Ptr // 指针 Slice // 切片 String // 字符串 Struct // 结构体 UnsafePointer // 底层指针 ) Map, Slice, Chan属于引用类型，但是属于独立的种类. type A struct{} 数据Struct 种类, type Enum int 是Emum类型 是int种类 ","date":"2022-10-04","objectID":"/reflect/:2:3","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"从类型对象中获取类型名称和种类 reflect.Type对象的Name()可以用来获取类型名称，而Kind()就可以帮我们获取种类。 package main import ( \"fmt\" \"reflect\" ) type Enum int const ( Zero Enum = 0 ) func main() { // 声明一个空结构体 type cat struct { } // 获取结构体实例的反射类型对象 typeOfCat := reflect.TypeOf(cat{}) // 显示反射类型对象的名称和种类 fmt.Println(typeOfCat.Name(), typeOfCat.Kind()) // 获取Zero常量的反射类型对象 typeOfA := reflect.TypeOf(Zero) // 显示反射类型对象的名称和种类 fmt.Println(typeOfA.Name(), typeOfA.Kind()) } cat struct Enum int ","date":"2022-10-04","objectID":"/reflect/:3:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"使用反射获取结构体成员的类型 如果类型是结构体，在使用reflect.TypeOf()获取反射对象类型信息后，可以通过 NumField()和Field()方法获得结构体成员的详细信息。 方法 说明 Field(i int) StructField 根据索引返回索引对应的结构体字段的信息，当值不是结构体或索引超界时发生宕机 NumField() int 返回结构体成员字段数量，当类型不是结构体或索引超界时发生宕机 FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息，没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机 FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息，没有找到时返回零值。当类型不是结构体或索引超界时发生宕机 FieldByNameFunc(match func(string) bool) (StructField,bool) 根据匹配函数匹配需要的字段，当值不是结构体或索引超界时发生宕机 结构体字段类型 reflect.Type的Field()会返回StructField结构。这个结构描述了结构体成员的信息 type StructField struct { Name string // 字段名 PkgPath string // 字段路径 Type Type // 字段反射类型对象 Tag StructTag // 字段的结构体标签 Offset uintptr // 字段在结构体中的相对偏移 Index []int // Type.FieldByIndex中的返回的索引值 Anonymous bool // 是否为匿名字段 } 获取成员信息 通过reflect.Type对象的FieldByName()方法可以直接查找接口体中指定名称的字段。通过NumField()可以获取结构体中的字段数量，而通过Field()则可以获取对应索引的字段信息。 package main import ( \"fmt\" \"reflect\" ) func main() { // 声明一个空结构体 type cat struct { Name string // 带有结构体tag的字段 Type int `json:\"type\" id:\"100\"` } // 创建cat的实例 ins := cat{Name: \"mimi\", Type: 1} // 获取结构体实例的反射类型对象 typeOfCat := reflect.TypeOf(ins) // 遍历结构体所有成员 for i := 0; i \u003c typeOfCat.NumField(); i++ { // 获取每个成员的结构体字段类型 fieldType := typeOfCat.Field(i) // 输出成员名和tag fmt.Printf(\"name: %v tag: '%v'\\n\", fieldType.Name, fieldType.Tag) } // 通过字段名, 找到字段类型信息 if catType, ok := typeOfCat.FieldByName(\"Type\"); ok { // 从tag中取出需要的tag fmt.Println(catType.Tag.Get(\"json\"), catType.Tag.Get(\"id\")) } } name: Name tag: '' name: Type tag: 'json:\"type\" id:\"100\"' type 100 结构体标签 你可能注意到了上面有这样的写法 type cat struct { Type int `json:\"type\" id:\"100\"` } 对于Type int 后面跟的那一串键值对，golang把它称作结构体标签。 结构体标签是对结构体字段信息的额外补充，很多ORM系统都会用到这样的标签 结构体标签的格式 `key1:\"value1\" key2:\"value2\"` 结构体可以由一个或多个键值对组成；键与值之间用冒号分割，值用双引号括起来，键值对与键值对之间使用空格分割。 获取结构体标签中的值 reflect.Type.Tag 的 Get(key string)string可以根据结构体标签中的键获取对应的值, Lookup(key string)(value string, ok bool)可以根据结构体标签中的键，查询值是否存在 ","date":"2022-10-04","objectID":"/reflect/:4:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"指针与指针指向的元素 reflect.Elem()专用于获取指针指向的元素的类型, 因为当我们对一个指针使用reflect.TypeOf时，我们只能得到这个指针的接口值的类型信息(也就是interface值的type部分), 所以如果想要进一步获取它指向的指的类型信息，我们必须得先将指针解引用。而reflect.Elem()可以帮我们完成这一步的操作。 package main import ( \"fmt\" \"reflect\" ) func main() { // 声明一个空结构体 type cat struct { } // 创建cat的实例 ins := \u0026cat{} // 获取结构体实例的反射类型对象 typeOfCat := reflect.TypeOf(ins) // 显示反射类型对象的名称和种类 fmt.Printf(\"name:'%v' kind:'%v'\\n\", typeOfCat.Name(), typeOfCat.Kind()) // 取类型的元素 typeOfCat = typeOfCat.Elem() // 显示反射类型对象的名称和种类 fmt.Printf(\"element name: '%v', element kind: '%v'\\n\", typeOfCat.Name(), typeOfCat.Kind()) } name:'' kind:'ptr' element name: 'cat', element kind: 'struct' ","date":"2022-10-04","objectID":"/reflect/:5:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"使用反射值对象包装任意值 反射不仅可以获取值的类型信息，还能动态获取或设置变量的值。Go语言中使用reflect.Value可以通过包装和拆包相互转化。 包装与拆包 所谓包装 就是将原值转换成reflect.Value类型的值。而拆包就是将reflect.Value类型的值转化成原值。 在包装的时候，原值被转换成reflect.Value, 而reflect.Value中封装了原值的各种信息，就像食品加工完后在外面套一层包装来告诉顾客成分信息一样，所以这一步我们通常叫做包装 拆包，就像顾客拆掉食品包装，见到真正的食物，所以由reflect.Value转化成原值这一步叫拆包。 value := refelct.ValueOf(rawValue) reflect.ValueOf返回reflect.Value类型，包含有rawValue的值信息。 ","date":"2022-10-04","objectID":"/reflect/:6:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"从reflect.Value类型的对象中获取被包装的值的方法 方法名 说 明 Interface() interface {} 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型 Int() int64 将值以 int 类型返回，所有有符号整型均可以此方式返回 Uint() uint64 将值以 uint 类型返回，所有无符号整型均可以此方式返回 Float() float64 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 Bool() bool 将值以 bool 类型返回 Bytes() []bytes 将值以字节数组 []bytes 类型返回 String() string 将值以字符串类型返回 package main import ( \"fmt\" \"reflect\" ) func main() { // 声明整型变量a并赋初值 var a int = 1024 // 获取变量a的反射值对象 valueOfA := reflect.ValueOf(a) // 获取interface{}类型的值, 通过类型断言转换 var getA int = valueOfA.Interface().(int) // 获取64位的值, 强制类型转换为int类型 var getA2 int = int(valueOfA.Int()) fmt.Println(getA, getA2) } 1024 1024 ","date":"2022-10-04","objectID":"/reflect/:7:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"使用IsNil() 和 IsValid() – 判断反射值的空和有效性 反射对象(reflect.Value)提供了零值和空的判断 方 法 说 明 IsNil() bool 返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的v== nil操作 IsValid() bool 判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等。 package main import ( \"fmt\" \"reflect\" ) func main() { // *int的空指针 var a *int fmt.Println(\"var a *int:\", reflect.ValueOf(a).IsNil()) // nil值 fmt.Println(\"nil:\", reflect.ValueOf(nil).IsValid()) // *int类型的空指针 fmt.Println(\"(*int)(nil):\", reflect.ValueOf((*int)(nil)).Elem().IsValid()) // 实例化一个结构体 s := struct{}{} // 尝试从结构体中查找一个不存在的字段 fmt.Println(\"不存在的结构体成员:\", reflect.ValueOf(s).FieldByName(\"\").IsValid()) // 尝试从结构体中查找一个不存在的方法 fmt.Println(\"不存在的结构体方法:\", reflect.ValueOf(s).MethodByName(\"\").IsValid()) // 实例化一个map m := map[int]int{} // 尝试从map中查找一个不存在的键 fmt.Println(\"不存在的键：\", reflect.ValueOf(m).MapIndex(reflect.ValueOf(3)).IsValid()) } var a *int: true nil: false (*int)(nil): false 不存在的结构体成员: false 不存在的结构体方法: false 不存在的键： false ","date":"2022-10-04","objectID":"/reflect/:8:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"使用反射修改变量的值 使用reflect.Value对包装的值进行修改的时候，必须先遵循一些规则，否则有可能会导致程序宕机。 ","date":"2022-10-04","objectID":"/reflect/:9:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"原则一：可被寻址 先说一说什么是可被寻值。先上代码 x := 2 // value type variable? a := reflect.ValueOf(2) // 2 int 不可寻址 b := reflect.ValueOf(x) // 2 int 不可寻址 c := reflect.ValueOf(\u0026x) // \u0026x *int 不可寻址 d := c.Elem() // 2 int yes (x) 可被寻址 上面a b c 都不可被寻址。因为值在被传入reflect.ValueOf()的时候，会被自动拷贝一份出来，这时 a b c 都指向的是原值的副本。 而反射的目的是对原值描述，对原值修改。如果允许修改副本，违背了反射的初衷，所以如果之间将值传入，无法修改原值。因为a b c 这三个变量已经没有办法找到原值了，所以我们说不可被寻址。 再看d, c中存储的是x的指针，而之前说过Elem()函数可以获取到指针指向值，所以这里d描述的就是x,由于可被寻址，所以他可以被修改。 简单的说所有reflec.Value都是不可取地址的，只有当reflect.Value是指针并且调用了 Elem()的时候才能取地址，比如 reflect.ValueOf(\u0026s).Elem() package main import ( \"fmt\" \"reflect\" ) func main() { x := 2 c := reflect.ValueOf(\u0026x) c.Elem().SetInt(6) d := c.Elem() d.SetInt(0) fmt.Println(x) } 0 使用reflect.Value取元素，取地址，判断是否可取地址可以修改的api 方法名 备 注 Elem() Value 取值指向的元素值，类似于语言层*操作。当值类型不是指针或接口时发生宕 机，空指针时返回 nil 的 Value Addr() Value 对可寻址的值返回其地址，类似于语言层\u0026操作。当值不可寻址时发生宕机 CanAddr() bool 表示值是否可寻址 CanSet() bool 返回值能否被修改。要求值可寻址且是导出的字段 ","date":"2022-10-04","objectID":"/reflect/:9:1","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"原则二：被导出 结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改。 package main import ( \"reflect\" ) func main() { type dog struct { legCount int } // 获取dog实例的反射值对象 valueOfDog := reflect.ValueOf(dog{}) // 获取legCount字段的值 vLegCount := valueOfDog.FieldByName(\"legCount\") // 尝试设置legCount的值(这里会发生崩溃) vLegCount.SetInt(4) } :panic: reflect: reflect.Value.SetInt using value obtained using unexported field 为了能修改这个值，需要将该字段导出。将 dog 中的 legCount 的成员首字母大写，导出 LegCount 让反射可以访问，修改后的代码如下： type dog struct { LegCount int } 然后根据字段名获取字段的值时，将字符串的字段首字母大写，修改后的代码如下： vLegCount := valueOfDog.FieldByName(\"LegCount\") 再次运行程序，发现仍然报错： panic: reflect: reflect.Value.SetInt using unaddressable value 这个错误表示第 13 行构造的 valueOfDog 这个结构体实例不能被寻址，因此其字段也不能被修改。修改代码，取结构体的指针，再通过 reflect.Value 的 Elem() 方法取到值的反射值对象。修改后的完整代码如下： package main import ( \"reflect\" \"fmt\" ) func main() { type dog struct { LegCount int } // 获取dog实例地址的反射值对象 valueOfDog := reflect.ValueOf(\u0026dog{}) // 取出dog实例地址的元素 valueOfDog = valueOfDog.Elem() // 获取legCount字段的值 vLegCount := valueOfDog.FieldByName(\"LegCount\") // 尝试设置legCount的值(这里会发生崩溃) vLegCount.SetInt(4) fmt.Println(vLegCount.Int()) } 4 ","date":"2022-10-04","objectID":"/reflect/:9:2","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"值修改相关api Set(x Value) 将值设置为传入的反射值对象的值 Setlnt(x int64) 使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机 SetUint(x uint64) 使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机 SetFloat(x float64) 使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机 SetBool(x bool) 使用 bool 设置值。当值的类型不是 bod 时会发生宕机 SetBytes(x []byte) 设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机 SetString(x string) 设置字符串值。当值的类型不是 string 时会发生宕机 如果CanSet返回的是false, 荏苒调用上面的方法就会导致宕机 ","date":"2022-10-04","objectID":"/reflect/:9:3","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"通过类型信息创建实例 当已知reflect.Type时，可以动态地创建这个类型的实例，实例的类型为指针。用例代码如下 package main import ( \"fmt\" \"reflect\" ) func main() { var a int // 取变量a的反射类型对象 typeOfA := reflect.TypeOf(a) // 根据反射类型对象创建类型实例 aIns := reflect.New(typeOfA) // 输出Value的类型和种类 fmt.Println(aIns.Type(), aIns.Kind()) } *int ptr ","date":"2022-10-04","objectID":"/reflect/:10:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"通过反射调用函数 反射还能调用函数，是不是觉得挺🐮🍺的。 如果反射值对象(reflect.Value)中值的类型为函数时，可以通过reflect.Value调用该函数。使用反射调用函数，需要将参数用[]reflect.Value构造后传入Call(). 调用完成函数的返回值会通过[]reflect.Value返回。 package main import ( \"fmt\" \"reflect\" ) func add (a,b int) int { return a + b } func main(){ funcValue := reflect.ValueOf(add) paramList := []reflect.Value{reflect.ValueOf(10),reflect.ValueOf(20)} retList := funcValue.Call(paramList) fmt.Println(retList[0].Int()) } 30 反射调用函数的过程需要构造大量的 reflect.Value 和中间变量，对函数参数值进行逐一检查，还需要将调用参数复制到调用函数的参数内存中。调用完毕后，还需要将返回值转换为 reflect.Value，用户还需要从中取出调用值。因此，反射调用函数的性能问题尤为突出，不建议大量使用反射函数调用。 ","date":"2022-10-04","objectID":"/reflect/:11:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"golang plugin 详解","date":"2022-10-04","objectID":"/plugin/","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"golang 的plugin特性 是已经出了好几年了。不过直到我写这篇博客的时候，golang的plugin 也仅支持linux/unix平台。而且plugin的使用有诸多限制，让它成为了一个冷门特性。 ","date":"2022-10-04","objectID":"/plugin/:0:0","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"golang plugin golang的plugin为golang 提供了类似动态链接库的能力。通过plugin，我们可以将Go包编译成共享库，这样就可以动态加载模块。 但是他有一些限制 插件的实现和主应用程序必须用完全相同的Go工具链版本构建。这种特性一般只会用于类似算法模块的更新，因为算法模块是纯函数。程序分为数据和算法，数据结构是一定不能动的，因为静态语言会有类型检查，这会导致很多的问题。作为数据结构不单会被主程序引用，plugin也得引用。两者版本对不上，会是非常头疼的问题。 不同so文件定义的结构体不能使用类型断言进行转换 每个so不能单独保存数据，so是没法被关闭的。可能多个so引用同一个变量，gc没有办法释放。 使用plugin的主程序只能够使用动态链接，go以静态编译著称，编译的程序不需要别的依赖就可以跑起来。但是使用了plugin的主程序就需要依赖系统的动态链接库了。 plugin的使用很简单，分为三个步骤。 先编写plugin程序， 然后使用-buildmode=plugin 编译出.so文件 编写主程序 使用plugin包的api去调用plugin中的函数 举个例子 先看项目结构 plugin目录下的plug.go是plug.so的源码文件， 主程序是test目录下的test.go 编写plugin程序 plug.go package main import ( \"fmt\" ) func PrintHahaha() { fmt.Println(\"Hahaha\") } func CallInDirect() { i:= 1 i++ } note 必须要注意，plugin程序的包定义必须是package main 可以没有main函数。同一个plugin程序的init函数只会被调用一次，重复加载后也不会再被调用(就是说 plugin在第一次被打开时，会调用包里面的init函数，但是后面再次打开init是不会再被调用的) 使用-buildmode=plugin参数编译 cd plugin go build -buildmode=plugin -o plug.so ./plug.go 编写调用的主程序test.go package main import ( \"fmt\" \"plugin\" ) func main() { plug, err := plugin.Open(\"../plugin/plug.so\") if err != nil { fmt.Println(err) } foo, err := plug.Lookup(\"PrintHahaha\") if err != nil { fmt.Println(err) } PrintHahaha, ok := foo.(func()) if !ok { fmt.Println(\"unexpected type from module symbol\") } PrintHahaha() } 这里先介绍一下基本使用流程，方便下面的性能测试 ","date":"2022-10-04","objectID":"/plugin/:1:0","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"性能测试 先说结论，plugin的函数调用要比正常的直接函数调用慢很多，大概慢3倍左右。但是你大可不必感到失望，因为实际使用中并不一定就会有很大的性能差异。 这里会分为两个部分，一个是调用plugin中函数的调用速度与直接调用函数速度的对比，另一个则是测试plugin LookUp的性能 ","date":"2022-10-04","objectID":"/plugin/:2:0","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"directCall vs indirectCall 先在宿主程序中添加一个CallDirect函数作为直接调用的素材 func CallDirect() { // for i := 0; i \u003c 1000; i++ { // } i := 10 i++ } 再在plugin中添加CallInDirect函数作为调用plugin中函数的素材 func CallInDirect() { // for i := 0; i \u003c 1000; i++ { // } i := 10 i++ } 接下来编写benchmark func BenchmarkCallDirect(b *testing.B) { for i := 0; i \u003c b.N; i++ { CallDirect() } } func BenchmarkCallInDirect(b *testing.B) { plug, err := plugin.Open(\"../plugin/plug.so\") if err != nil { fmt.Println(err) } foo, err := plug.Lookup(\"CallInDirect\") if err != nil { fmt.Println(err) } CallInDirect, ok := foo.(func()) if !ok { return } for i := 0; i \u003c b.N; i++ { CallInDirect() } } 下面是跑分结果 BenchmarkCallDirect ~/test/testPlugin/test ❯ go test -bench=\"CallDirect$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkCallDirect-8 1000000000 0.3317 ns/op BenchmarkCallDirect-8 1000000000 0.3271 ns/op BenchmarkCallDirect-8 1000000000 0.3228 ns/op PASS ok testplugin 1.346s BenchmarkCallInDirect ~/test/testPlugin/test ❯ go test -bench=\"CallInDirect$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkCallInDirect-8 1000000000 0.9653 ns/op BenchmarkCallInDirect-8 1000000000 0.9513 ns/op BenchmarkCallInDirect-8 1000000000 0.9542 ns/op PASS ok testplugin 3.801s 差不多是三倍的差距，但是这里，测试素材比较简单。如果让测试素材里面跑一些比较耗时的逻辑呢。 CallDirect func CallDirect() { for i := 0; i \u003c 1000; i++ { } // i := 10 // i++ } CallInDirect func CallInDirect() { for i := 0; i \u003c 1000; i++ { } // i := 10 // i++ } 跑分结果 BenchmarkCallDirect ~/test/testPlugin/test 13s ❯ go test -bench=\"CallDirect$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkCallDirect-8 16496887 327.1 ns/op BenchmarkCallDirect-8 17459262 328.3 ns/op BenchmarkCallDirect-8 18355296 332.5 ns/op PASS ok testplugin 21.329s BenchmarkCallInDirect ❯ go test -bench=\"CallInDirect$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkCallInDirect-8 16783506 331.3 ns/op BenchmarkCallInDirect-8 18161929 333.9 ns/op BenchmarkCallInDirect-8 18247104 328.9 ns/op PASS ok testplugin 18.826s summary 差距是无限缩小的，大概能够得出的结论是。如果你不是不要命的频繁的去调用函数，那么plugin调用带来的消耗几乎可以忽略不计，尤其是当你的函数执行越耗时，这种差异就会越小。 ","date":"2022-10-04","objectID":"/plugin/:2:1","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"LookUp的性能 跑分代码 func BenchmarkLookUp(b *testing.B) { plug, err := plugin.Open(\"../plugin/plug.so\") if err != nil { fmt.Println(err) } for i := 0; i \u003c b.N; i++ { plug.Lookup(\"CallInDirect\") } } 跑分结果 ~/test/testPlugin/test 20s ❯ go test -bench=\"LookUp$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkLookUp-8 1000000000 4.785 ns/op BenchmarkLookUp-8 1000000000 4.791 ns/op BenchmarkLookUp-8 1000000000 4.787 ns/op PASS ok testplugin 16.576s 性能也还不错哦 ","date":"2022-10-04","objectID":"/plugin/:2:2","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"结论 正常使用过程中你并不需要特别关心plugin所带来的消耗，因为相比函数内部逻辑带来的消耗，plugin 所带来的消耗实在是太小了。在了解plugin特性的时候，我还了解到golang 有一个 go-plugin 的包，使用grpc来实现组件的拔插，截止到现在已经有3.7k的收藏。所以性能并不由调用函数的速度决定，性能取决于函数内部的逻辑是如何实现的。 ","date":"2022-10-04","objectID":"/plugin/:3:0","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["lisp"],"content":"common lisp 字符串","date":"2022-10-04","objectID":"/strings/","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"你应该知道，string 在 common lisp 中它既是arrays 也是 sequences. 也就是说，arrays 和 sequences的操作都可以应用在string上。如果你找不到某个string特有的函数，你应该去找一找arrays 和 sequences的函数。 还有一些额外的libraries 托管在 quicklisp上，这里只给出英文介绍 ASDF3, which is included with almost all Common Lisp implementations, includes Utilities for Implementation- and OS- Portability (UIOP), which defines functions to work on strings (strcat, string-prefix-p, string-enclosed-p, first-char, last-char, split-string, stripln). Some external libraries available on Quicklisp bring some more functionality or some shorter ways to do. str defines trim, words, unwords, lines, unlines, concat, split, shorten, repeat, replace-all, starts-with?, ends-with?, blankp, emptyp, … Serapeum is a large set of utilities with many string manipulation functions. cl-change-case has functions to convert strings between camelCase, param-case, snake_case and more. They are also included into str. mk-string-metrics has functions to calculate various string metrics efficiently (Damerau-Levenshtein, Hamming, Jaro, Jaro-Winkler, Levenshtein, etc), and cl-ppcre can come in handy, for example ppcre:replace-regexp-all. See the regexp section. Last but not least, when you’ll need to tackle the format construct, don’t miss the following resources: the official CLHS documentation a quick reference a CLHS summary on HexstreamSoft plus a Slime tip: type C-c C-d ~ plus a letter of a format directive to open up its documentation. Again more useful with ivy-mode or helm-mode. ","date":"2022-10-04","objectID":"/strings/:0:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"创建 字符串 最简单的，我们可以使用双引号创建string.但是其实我们还有别的方法: 使用format nil (defparameter person \"you\") (format nil \"hello ~a\" person) ;; =\u003e \"hello you\" make-string count 创建指定长度的字符串。 :initial-element 字符会被重复count次 (make-string 3 :initial-element #\\♥) ;; =\u003e \"♥♥♥\" ","date":"2022-10-04","objectID":"/strings/:1:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"访问子串 string 是一个sequence,你可以使用subseq 来访问它的子串 先给出一个比较易懂的签名 (subseq my-string start end) 这里是调用 * (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* * (subseq *my-string* 8) \"Marx\" * (subseq *my-string* 0 7) \"Groucho\" * (subseq *my-string* 1 5) \"rouc\" 也可以像序列那样用setf 和 subseq 配合来操作字符串 * (defparameter *my-string* (string \"Harpo Marx\")) *MY-STRING* * (subseq *my-string* 0 5) \"Harpo\" * (setf (subseq *my-string* 0 5) \"Chico\") \"Chico\" * *my-string* \"Chico Marx\" string isn`t stretchable 字符串的长度是不可变的，如果新的子串的长度和原始子串的长度不同，短的那一个将决定多少个字符将被替换， * (defparameter *my-string* (string \"Karl Marx\")) *MY-STRING* * (subseq *my-string* 0 4) \"Karl\" * (setf (subseq *my-string* 0 4) \"Harpo\") \"Harpo\" * *my-string* \"Harp Marx\" * (subseq *my-string* 4) \" Marx\" * (setf (subseq *my-string* 4) \"o Marx\") \"o Marx\" * *my-string* \"Harpo Mar\" ","date":"2022-10-04","objectID":"/strings/:2:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"访问单个字符 char函数专门用来访问字符串中的单个字符，char也可以和setf配合使用 (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (char *my-string* 11) #\\x (char *my-string* 7) #\\Space (char *my-string* 6) #\\o (setf (char *my-string* 6) #\\y) #\\y *my-string* \"Grouchy Marx\" 还有一个schar也可以做到同样的事情，但是在特定情况下，schar会更快一些 因为strings 既是 arrays 也是 sequence. 你也可以用更加通用的aref 和 elt (但是char的效率会更高) (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (aref *my-string* 3) #\\u (elt *my-string* 8) #\\M ","date":"2022-10-04","objectID":"/strings/:3:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"从string中删除和替换 可以使用 sequence的函数来对string中的子串进行删除和替换操作 从string中删除一个字符 (remove #\\o \"Harpo Marx\") \"Harp Marx\" (remove #\\a \"Harpo Marx\") \"Hrpo Mrx\" (remove #\\a \"Harpo Marx\" :start 2) \"Harpo Mrx\" (remove-if #'upper-case-p \"Harpo Marx\") \"arpo arx\" 使用substitute(non destructive) 或者 replace (destructive) 来替换一个字符 (substitute #\\u #\\o \"Groucho Marx\") \"Gruuchu Marx\" (substitute-if #\\_ #'upper-case-p \"Groucho Marx\") \"_roucho _arx\" (defparameter *my-string* (string \"Zeppo Marx\")) *MY-STRING* (replace *my-string* \"Harpo\" :end1 5) \"Harpo Marx\" *my-string* \"Harpo Marx\" ","date":"2022-10-04","objectID":"/strings/:4:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"拼接字符串 (Concatenating string) concatenate 是sequence的通用函数，在对string进行操作时，应该指定返回值的类型 (concatenate 'string \"karl\" \" \" \"Marx\") ;; =\u003e \"Karl Marx\" (concatenate 'list \"Karl\" \" \" \"Marx\") ;; =\u003e (#\\K #\\a #\\r #\\l #\\Space #\\M #\\a #\\r #\\x) 使用UIOP库的话，可以用strcat: (uiop:strcat \"karl\" \" \" marx\") 或者是str library 使用concat: (str:concat \"foo\" \"bar\") ","date":"2022-10-04","objectID":"/strings/:5:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"一次操作一个字符 使用Map函数一次操作一个字符 (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (map 'string #'(lambda (c) (print c)) *my-string*) #\\G #\\r #\\o #\\u #\\c #\\h #\\o #\\Space #\\M #\\a #\\r #\\x \"Groucho Marx\" 或者使用loop 函数 (loop for char across \"Zeppo\" collect char) (#\\Z #\\e #\\p #\\p #\\o) ","date":"2022-10-04","objectID":"/strings/:6:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"根据word 或 character翻转string 使用reverse (或者destructive 版的 nreverse) 来根据character反转字符串 (defparameter *my-string* (string \"DSL\")) *MY-STRING* (reverse *my-string*) \"LSD\" 在CL中 没有直接根据word反转字符串的函数，你可以使用第三方库 比如SPLIT-SEQUENCE 或者你自己实现一套解决方案 我们可以使用str库 (defparameter *singing* \"singing in the rain\") *SINGING* (str:words *SINGING*) ;; =\u003e (\"singing\" \"in\" \"the\" \"rain\") (str:unwords (reverse (str:words *singing*))) ;; =\u003e \"rain the in singing\" ","date":"2022-10-04","objectID":"/strings/:7:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"Breaking strings into graphenes,sentences,lines and words These functions use SBCL’s sb-unicode: they are SBCL specific. sb-unicode:sentences 将string 以段落切割，根据他默认的段落分割规则 sb-unicode:lines 将string 分割成行（长度不会超过:margin 指定的参数 默认80） (sb-unicode:lines \"A first sentence. A second somewhat long one.\" :margin 10) ;; =\u003e (\"A first\" ;; \"sentence.\" ;; \"A second\" ;; \"somewhat\" ;; \"long one.\") sb-unicode:words 和 sb-unicode:graphenes 可以自己去查看 确保运行在sbcl中 #+sbcl (runs on sbcl) #-sbcl (runs on other implementations) ","date":"2022-10-04","objectID":"/strings/:8:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"Controlling Case 控制大小写 Common lisp 提供了大量的函数来控制字符串的大小写 (string-upcase \"cool\") ;; =\u003e \"COOL\" (string-upcase \"Cool\") ;; =\u003e \"COOL\" (string-downcase \"COOL\") ;; =\u003e \"cool\" (string-downcase \"Cool\") ;; =\u003e \"cool\" (string-capitalize \"cool\") ;; =\u003e \"Cool\" (string-capitalize \"cool example\") ;; =\u003e \"Cool Example\" 这些函数可以接受:start 和 :key 所以你可以只对字符串的指定部分进行操作。 这些函数也有destructive的版本都以n开头 (string-capitalize \"cool example\" :start 5) ;; =\u003e \"cool Example\" (string-capitalize \"cool example\" :end 5) ;; =\u003e \"Cool example\" (defparameter *my-string* (string \"BIG\")) ;; =\u003e *MY-STRING* (defparameter *my-downcase-string* (nstring-downcase *my-string*)) ;; =\u003e *MY-DOWNCASE-STRING* *my-downcase-string* ;; =\u003e \"big\" *my-string* ;; =\u003e \"big\" warning 对于 string-upcase,string-downcase 和 string-capitalize,string 是没有被修改的。但是如果在string中没有任何字符需要转换，那么返回值有可能是源string 或者 源string的副本 tips 在CL中 n开头的函数一般是destructive的 ","date":"2022-10-04","objectID":"/strings/:9:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"使用format函数控制 To lower case: (format t \"~(~a~)\" \"HELLO WORLD\") ;; =\u003e hello world Capitalize every word: (format t \"~:(~a~)\" \"HELLO WORLD\") ;; =\u003e Hello World Capitalize the first word: (format t \"~@(~a~)\" \"hello world\") ;; =\u003e Hello world To upper case (format t \"~@:(~a~)\" \"hello world\") ;; =\u003e HELLO WORLD ","date":"2022-10-04","objectID":"/strings/:9:1","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"将字符串左右的空格截掉 其实不单单可以截掉空格，还可以丢弃一些不需要的字符。string-trim,string-left-trim,string-right-trim 返回一个子串，子串不包含第一个参数中的字符。 (string-trim \" \" \" trim me \") ;; =\u003e \"trim me\" (string-trim \" et\" \" trim me \") ;; =\u003e \"rim m\" (string-left-trim \" et\" \" trim me \") ;; =\u003e \"rim me \" (string-right-trim \" et\" \" trim me \") ;; =\u003e \" trim m\" (string-right-trim '(#\\Space #\\e #\\t) \" trim me \") ;; = \u003e\" trim m\" (string-right-trim '(#\\Space #\\e #\\t #\\m) \" trim me \") ","date":"2022-10-04","objectID":"/strings/:10:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在symbol 和 字符串之间转换 intern 将string转化成symbol (in-package \"COMMON-LISP-USER\") ;; =\u003e #\u003cThe COMMON-LISP-USER package, 35/44 internal, 0/9 external\u003e (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL ;; =\u003e:INTERNAL (export 'MY-SYMBOL) ;; =\u003e T (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL ;; =\u003e :EXTERNAL (intern \"My-Symbol\") ;; =\u003e |My-Symbol| ;; =\u003e NIL (intern \"MY-SYMBOL\" \"KEYWORD\") ;; =\u003e :MY-SYMBOL ;; =\u003e NIL (intern \"MY-SYMBOL\" \"KEYWORD\") ;; =\u003e :MY-SYMBOL ;; =\u003e :EXTERNAL symbol-name 和 string 将symbol 转换成 string (symbol-name 'MY-SYMBOL) ;; =\u003e \"MY-SYMBOL\" (symbol-name 'my-symbol) ;; =\u003e \"MY-SYMBOL\" (symbol-name '|my-symbol|) ;; =\u003e \"my-symbol\" (string 'howdy) ;; =\u003e \"HOWDY\" ","date":"2022-10-04","objectID":"/strings/:11:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在string 和 character之间转换 coerce 将string(长度为1)转换成character. (coerce \"a\" 'character) ;; =\u003e #\\a (coerce (subseq \"cool\" 2 3) 'character) ;; =\u003e #\\o coerce 将字符串转换中字符list (coerce \"cool\" 'list) ;; =\u003e (#\\c #\\o #\\o #\\l) coerce 将字符list转换成string (coerce '(#\\h #\\e #\\y) 'string) ;; =\u003e \"hey\" coerce 将array 转换成string (defparameter *my-array* (make-array 5 :initial-element #\\x)) ;; =\u003e *MY-ARRAY* *my-array* ;; =\u003e #(#\\x #\\x #\\x #\\x #\\x) (coerce *my-array* 'string) ;; =\u003e \"xxxxx\" ","date":"2022-10-04","objectID":"/strings/:12:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在string中寻找一个元素 使用find,position 和他们的-if后缀的函数 查找string中的character (find #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e #\\t (find #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e #\\T (find #\\z \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e NIL (find-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;;=\u003e #\\1 (find-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :from-end t) ;; =\u003e #\\0 (position #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e 17 (position #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e 0 (position-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;; =\u003e 37 (position-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :from-end t) ;; =\u003e 43 使用count族函数计算字符在字符串中出现的次数 (count #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e 2 (count #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e 3 (count-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;; =\u003e 6 (count-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :start 38) ;; =\u003e 5 ","date":"2022-10-04","objectID":"/strings/:13:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在字符串中查找一个子串 (search \"we\" \"If we can't be free we can at least be cheap\") ;; =\u003e 3 (search \"we\" \"If we can't be free we can at least be cheap\" :from-end t) ;; =\u003e 20 (search \"we\" \"If we can't be free we can at least be cheap\" :start2 4) ;; =\u003e 20 (search \"we\" \"If we can't be free we can at least be cheap\" :end2 5 :from-end t) ;; =\u003e 3 (search \"FREE\" \"If we can't be free we can at least be cheap\") ;; =\u003e NIL (search \"FREE\" \"If we can't be free we can at least be cheap\" :test #'char-equal) ;; =\u003e 15 ","date":"2022-10-04","objectID":"/strings/:14:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"将string 转换成number to integer 会返回两个值，一个是被转换后的值，另一个是转换停止的位置 (parse-integer \"42\") ;; =\u003e 42 ;; =\u003e 2 (parse-integer \"42\" :start 1) ;; =\u003e 2 ;; =\u003e 2 (parse-integer \"42\" :end 1) ;; =\u003e 4 ;; =\u003e 1 (parse-integer \"42\" :radix 8) ;; =\u003e 34 ;; =\u003e2 (parse-integer \" 42 \") ;; =\u003e 42 ;; =\u003e 3 (parse-integer \" 42 is forty-two\" :junk-allowed t) ;; =\u003e 42 ;; =\u003e 3 (parse-integer \" 42 is forty-two\") Error in function PARSE-INTEGER: There's junk in this string: \" 42 is forty-two\". 转换成任意number: read-from-string (read-from-string \"#X23\") ;; =\u003e 35,4 (read-from-string \"4.5\") ;; =\u003e 4.5,3 (read-from-string \"6/8\") ;; =\u003e 3/4,3 (read-from-string \"#C(6/8 1)\") ;; =\u003e #C(3/4 1),9 (read-from-string \"1.2e2\") ;; =\u003e 120.00001,5 (read-from-string \"symbol\") ;; SYMBOL.6 (defparameter *foo* 42) ;; =\u003e *FOO* (read-from-string \"#.(setq *foo* \\\"gotcha\\\")\") ;; =\u003e \"gotcha\",23 *foo* ;; =\u003e \"gotcha\" ","date":"2022-10-04","objectID":"/strings/:15:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"转换成float parse-float 库提供转换成float的函数 (ql:quickload \"parse-float\") (parse-float:parse-float \"1.2e2\") ;; =\u003e 120.00001,5 ","date":"2022-10-04","objectID":"/strings/:16:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"number 转 string (write-to-string 250) ;; =\u003e \"250\" (write-to-string 250.02) ;; =\u003e \"250.02\" (write-to-string 250 :base 5) ;; =\u003e \"2000\" (write-to-string (/ 1 3)) ;; =\u003e \"1/3\" ","date":"2022-10-04","objectID":"/strings/:17:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"字符串比较 equal 和 equalp 都可以比较两个字符串是否相同，但是equal是大小写敏感的，而equalp不是。还有一些string专用的函数。 (string= \"Marx\" \"Marx\") ;; =\u003e T (string= \"Marx\" \"marx\") ;; =\u003e NIL (string-equal \"Marx\" \"marx\") ;; =\u003e T (string\u003c \"Groucho\" \"Zeppo\") ;; =\u003e 0 (string\u003c \"groucho\" \"Zeppo\") ;; =\u003e NIL (string-lessp \"groucho\" \"Zeppo\") ;; =\u003e 0 (mismatch \"Harpo Marx\" \"Zeppo Marx\" :from-end t :test #'char=) ;; =\u003e 3 ","date":"2022-10-04","objectID":"/strings/:18:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"String formatting see https://lispcookbook.github.io/cl-cookbook/strings.html#string-formatting ","date":"2022-10-04","objectID":"/strings/:19:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"捕获哪些东西被打印进了stream 在(with-output-to-string (mystream) …) 中任何打印进stream中的内容都会被捕获 (defun greet (name \u0026key (stream t)) ;; by default, print to standard output. (format stream \"hello ~a\" name)) (let ((output (with-output-to-string (stream) (greet \"you\" :stream stream)))) (format t \"Output is: '~a'. It is indeed a ~a, aka a string.~\u0026\" output (type-of output))) ;; Output is: 'hello you'. It is indeed a (SIMPLE-ARRAY CHARACTER (9)), aka a string. ;; NIL ","date":"2022-10-04","objectID":"/strings/:20:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"删除标点符号 使用(str:remove-punctuation s) 或者 (str:no-case s) (str:remove-punctuation \"HEY! What's up ??\") ;; \"HEY What s up\" (str:no-case \"HEY! What's up ??\") ;; \"hey what s up\" ","date":"2022-10-04","objectID":"/strings/:21:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"common lisp number 数值","date":"2022-10-04","objectID":"/numbers/","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"integer types CL 提供一个true integer类型，叫bignum,只受内存控制。 为了效率考虑，integers 可以被限制成fixnum type。integers 的范围可以这样查看 most-positive-fixnum 4611686018427387903 most-negative-fixnum -4611686018427387904 integer 相关的函数有 isqrt, 返回小于且最接近于指定数的平方根 (isqrt 10) ;; =\u003e 3 (isqurt 4) ;; =\u003e 2 gcd 返回最大的公分母 lcm 返回最小的公倍数 CL还提供了表示16进制和其他进制的方法 #xFF ;; =\u003e 255 #2r1010 ;; =\u003e 10 #4r33 ;; =\u003e 15 #8r11 ;; =\u003e 9 #16rFF ;; =\u003e 255 #36rz ;; =\u003e 35 ","date":"2022-10-04","objectID":"/numbers/:1:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"有理数 ratio 类型由两个bignums组成 * (/ (1+ (expt 2 100)) (expt 2 100)) 1267650600228229401496703205377/1267650600228229401496703205376 ratio 是 rational 的子类型 ","date":"2022-10-04","objectID":"/numbers/:2:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"浮点类型 CL 提供精度由小到大排列的short-float, single-float, double-float, and long-float 类型 常量short-float-epsilon, single-float-epsilon, double-float-epsilon and long-float-epsilon 表示了浮点类型的精度 ","date":"2022-10-04","objectID":"/numbers/:3:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"floating point literals (浮点字面量) *read-default-float-format*控制了浮点数读取的默认类型，默认是single-float,如果你想读入双精度的浮点数，你需要d0后缀 (type-of 1.24) ;; =\u003e SINGLE-FLOAT (type-of 1.24d0) ;; =\u003e DOUBLE-FLOAT Other suffixes are s (short), f (single float), d (double float), l (long float) and e (default; usually single float). 默认的type 是可以修改的 (setq *read-default-float-format* 'double-float) (type-of 1.24) ;; =\u003e DOUBLE-FLOAT warning 和其他语言不同的是，在十进制后面加小数点并不能将该数表示成浮点数 (type-of 10.) ;; =\u003e (INTEGER 0 4611686018427387903) (type-of 10.0) ;; =\u003e SINGLE-FLOAT ","date":"2022-10-04","objectID":"/numbers/:3:1","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"Float point errors 这个错误一般发生在小数点溢出的时候 (exp 1000) ;; Evaluation aborted on #\u003cFLOATING-POINT-OVERFLOW {10041720B3}\u003e. 这个错误可以被捕获和解决，或者他的行为可以被改变 (sb-int:set-floating-point-modes :traps '(:INVALID :DIVIDE-BY-ZERO)) (exp 1000) ;; =\u003e #.SB-EXT:SINGLE-FLOAT-POSITIVE-INFINITY (/ 1 (exp 1000)) ;; =\u003e 0.0 现在不会报任何的错误 在sbcl中，float-point 的模式可以被检查 (sb-int:get-floating-point-modes) ;; =\u003e (:TRAPS (:OVERFLOW :INVALID :DIVIDE-BY-ZERO) :ROUNDING-MODE :NEAREST ;; :CURRENT-EXCEPTIONS NIL :ACCRUED-EXCEPTIONS NIL :FAST-MODE NIL) ","date":"2022-10-04","objectID":"/numbers/:3:2","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"高精度计算 quicklisp 中有一个computable-reals库用于高精度计算 (ql:quickload :computable-reals) (use-package :computable-reals) (sqrt-r 2) ;; =\u003e +1.41421356237309504880... (sin-r (/r +pi-r+ 2)) ;; =\u003e +1.00000000000000000000... ","date":"2022-10-04","objectID":"/numbers/:3:3","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"复数 see https://lispcookbook.github.io/cl-cookbook/numbers.html#complex-types ","date":"2022-10-04","objectID":"/numbers/:4:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"Rounding floating-point and rational numbers ceiling,floor,round 和 truncate 可以将float数转换成integer. see https://lispcookbook.github.io/cl-cookbook/numbers.html#reading-numbers-from-strings ","date":"2022-10-04","objectID":"/numbers/:5:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"比较数字 这个真的没啥要将的，除了lisp使用前缀表达式。 直接看common lisp cookbook吧 see https://lispcookbook.github.io/cl-cookbook/numbers.html#comparing-numbers ","date":"2022-10-04","objectID":"/numbers/:6:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"随机数 random 函数用来生成随机数 (random 10) ;; =\u003e 7 (type-of (random 10)) ;; =\u003e (INTEGER 0 4611686018427387903) (type-of (random 10.0)) ;; =\u003e SINGLE-FLOAT (type-of (random 10d0)) ;; =\u003e DOUBLE-FLOAT 随机种子被存放在*random-state*中 使用make-random-state可以生成新的随机状态 如果想时候相同的随机集合多次，可以使用(make-random-state nil) (dotimes (i 3) (let ((*random-state* (make-random-state nil))) (format t \"~a~%\" (loop for i from 0 below 10 collecting (random 10))))) (8 3 9 2 1 8 0 0 4 1) (8 3 9 2 1 8 0 0 4 1) (8 3 9 2 1 8 0 0 4 1) ","date":"2022-10-04","objectID":"/numbers/:7:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"按位操作 这个地方common lisp cookbook 写的很好 see https://lispcookbook.github.io/cl-cookbook/numbers.html#bit-wise-operation ","date":"2022-10-04","objectID":"/numbers/:8:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"有关common lisp 的循环，和一些小技巧","date":"2022-10-04","objectID":"/loop_and_iteration/","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Introduction: loop,iterate,for,mapcar,series ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:0","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"loop loop 是一个内置的用来迭代的宏, 它最简单的形式是(loop (print “hello”)): 这个语句会无限打印\"hello\" 一个简单的迭代List的例子 (loop for x in '(1 2 3) do (print x)) 这个例子会返回Nil但是会打印他应该打印的 如果你需要将结果收集成一个list使用collect (loop for x in '(1 2 3) collect (* x 10)) loop 表达式有四个部分 设置要被迭代的变量 结束迭代的条件表达式 每次迭代要做的事情 每次退出时要做的事情 除此之外,loop表达式还能返回一个值 正常来说，我们很少使用所有的部分，但是我们可以随意组合他们 ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:1","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"iterate iterate 是一个很流行的迭代宏，要比loop更容易懂，但是拓展性要差一些。iterate并不是内置的，要先导入a。 (ql:quickload \"iterate\") (ues-package :iterate) iterate看起来是这样的 (iter (for in from 1 to 5) (collect (* i i))) warning 如果同时使用iterate 和 loop 会有命名冲突 使用display-iterate-clauses可以解决这个问题 (display-iterate-clauses '(for)) ;; FOR PREVIOUS \u0026OPTIONAL INITIALLY BACK Previous value of a variable ;; FOR FIRST THEN Set var on first, and then on subsequent iterations ;; ... ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:2","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"for for是一个可拓展的迭代宏，通常要比loop短。 for的最大好处就是，可以用在任何数据类型上(lists,vectors,hash-tables…) (for:for ((x over \u003cyour data structure\u003e)) (print ...)) for是一个第三方库，需要先quickload (ql:quickload \"for\") ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:3","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"map族 后面还有很多mapcar 和 map这样的例子。map 族还有mapcon,mapcan,maplist,mapc 和 mapl. (mapcar (lambda (it) (+ it 10)) '(1 2 3)) ;; =\u003e (11 12 13) map 更加通用 他可以接受List 和 vectors 作为参数，需要在第一个参数指定结果类型 (map 'vector (lambda (it) (+ it 10)) '(1 2 3)) ;; #(11 12 13) (map 'list (lambda (it) (+ it 10)) #(1 2 3)) ;; (11 12 13) (map 'string (lambda (it) (code-char it)) '#(97 98 99)) ;; \"abc\" 简写lambda函数 是不是觉得写lambda太烦， 其实有一些库可以提供简写lambda函数方法你可以去这里看看简写lambda的库有哪些lambda shorthand libraries 这里给出一个cl-punch的例子 (mapcar ^(* _ 10) '(1 2 3)) ;; =\u003e (10 20 30) ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:4","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"series 最后 你可能会喜欢series,一个库通过结合sequences,streams,和loop 来描述自己. Series 表达式看起来就像是在操作序列，但是可以获得相比loop 更高的效率。 Series第一次出现在 “Common Lisp the Language” (collect (mapping ((x (scan-range :from 1 :upto 5))) (* x x))) ;; =\u003e (1 4 9 16 25) Generators The Way I Want Them Generated Library 这是一个lazy sequences 库，和series类似，景观他很年轻，切不完全，但是他有很多现代化的API 比如take,filter,for,fold 并且易用 range :from 20) ;; #\u003cGTWIWTG::GENERATOR! {1001A90CA3}\u003e (take 4 (range :from 20)) ;; (20 21 22 23) ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:5","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"小妙招 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:0","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Looping forever,return (loop (print \"hello\")) return 用来返回结果 (loop for i in '(1 2 3) when (\u003e i 1) return i) ;; =\u003e 2 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:1","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"固定循环n次 dotimes (dotimes (n 3) (print n)) 这里dotimes只会返回Nil 有两种方法返回一个值 设置result在lambda list 中 (dotimes (n 3 :done) print(n)) ;; =\u003e ;; 0 ;; 1 ;; 2 ;; :DONE 使用return (dotimes (i 3) (if (\u003e i 1) (return :early-exit!) (print i))) ;; =\u003e ;; 0 ;; 1 ;; :EARLY-EXIT! loop…repeat (loop repeat 10 do (format t \"Hello!~%\")) 打印10次hello 返回nil (loop repeat 10 collect (random 10)) ;; =\u003e (5 1 3 5 4 0 7 4 9 1) 使用collect 会返回一个list Series (iterate ((n (scan-range :below 10))) (print n)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:2","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"循环无限次，在一个循环list上循环 前面提到了一个无限循环的方法，但是我们如何在一个list上无限循环呢 我们可以构造一个循环list (loop with list-a = '(1 2 3) with infinite-list = (setf (cdr (last list-a)) list-a) for item in infinite-list repeat 8 collect item) 构造循环列表有一个非常简单的方法使用#=语法 (defparameter list-a '#1=(1 2 3 . #1#)) (setf print-circle t) list-a 如果你只想再两个值之间交替地带，使用for…then (loop repeat 4 for up = t then (not up) do (print up)) T NIL T NIL ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:3","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Iterate 的for 循环 对于list 和 vectors: (iter (for item in '(1 2 3)) (print item)) (iter (for i in-vector #(1 2 3)) (print i)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:4","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"在一个list上进行循环 dolist (dolist (item '(1 2 3)) (print item)) loop 使用in (loop for x in '(a b c) do (print x)) ;; A ;; B ;; C ;; NIL (loop for x in '(a b c) collect x) ;; (A B C) 使用on 我们在cdr上迭代 (loop for i on '(1 2 3) do (print i)) ;; (1 2 3) ;; (2 3) ;; (3) mapcar (mapcar (lambda (x) (print (* x 10))) '(1 2 3)) 10 20 30 (10 20 30) mapcar 会将lambda函数的返回值组合成一个List返回 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:5","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"在一个vector上循环 loop:across (loop for i across #(1 2 3) do (print i)) Series (iterate ((i (scan #(123)))) (print i)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:6","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"在一个hash-table上循环 先创建一个hasht-table: (defparameter h (make-hash-table)) (setf (gethash 'a h) 1) (setf (gethash 'b h) 2) loop 在key上循环 (loop for k being the hash-key of h do(print k)) ;; b ;; a 在value上循环 (loop for k being the hash-key using (hash-value v) of h do (format t \"~a ~a~%\" k v)) ;; b 2 ;; a 1 maphash maphash 的lambda函数时一个拥有两个参数的函数两个参数分别是key,value (maphash (lambda (key val)) (format t \"key: ~a val: ~a~\u0026\" key val) h) ;; key: A val:1 ;; key: B val:2 ;; NIL dohash dohash 是第三方库trivial-do的一个macro,类似dolist (dohash (key value h) (format t \"key: ~A, value: ~A ~%\" key value)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:7","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"并行的在两个list上循环 loop (loop for x in '(a b c) for y in '(1 2 3) collect (list x y)) ;; ((A 1) (B 2) (C 3)) 如果想返回一个平整过的list(flat list),使用nconcing 替代collect: (loop for x in '(a b c) for y in '(1 2 3) nconcing (list x y)) ;; (A 1 B 2 C 3) 如果两个list的长度不同，会在短的结束的时候退出循环 (loop for x in '(a b c) for y in '(1 2 3 4 5) collect (list x y)) ;; ((A 1) (B 2) (C 3)) 我们可以在一个大的list上循环，并且手动的通过index访问小一点的List的元素,但是这样的效率是非常低的，我们可以让loop自动拓展短的list (loop for y in '(1 2 3 4 5) for x-list = '(a b c) then (cdr x-list) for x = (or (car x-list) 'z) collect (list x y)) ;; ((A 1) (B 2) (C 3) (Z 4) (Z 5)) 在这个代码段中，for … = … then (cdr …) 在每一次的循环中都会缩短一次list. 他的值一开始是’(a b c) 然后是 ‘(b c) 然后 ‘(c) 最后 nil mapcar (mapcar (lambda (x y) (list x y)) '(a b c) '(1 2 3)) ;; ((A 1) (B 2) (C 3)) 或者更简单: (mapcar #'list '(a b c) '(1 2 3)) ;; ((A 1) (B 2) (C 3)) 返回一个flat list: (mapcan (lambda (x y) (list x y)) '(a b c)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:8","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"嵌套循环(Nested loops) loop (loop for x from 1 to 3 collect (loop for y from 1 to x collect y)) ;;((1) (1 2) (1 2 3)) 如果要返回一个flat list,使用nconcing 替换第一个collect ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:9","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"计算一个中间值 使用= 与 for结合 (loop for x from 1 to 3 for y = (* x 10) collect y) ;; (10 20 30) 如果使用with,那么只会计算一次 (loop for x from 1 to 3 for y = (* x 10) with z = x collect (list x y z)) ;; ((1 10 1) (2 20 1) (3 30 1)) HyperSpec 对 with 的定义时这样的 with-clause::= with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}* 所以我们可以再=前面指明类型 并且用and 串起来 (loop for x from 1 to 3 for y integer = (* x 10) with z integer = x collect (list x y z)) (loop for x upto 3 with foo = :foo and bar = :bar collect list (x foo bar)) 我们也可以给for 一个 then 让他没次迭代都执行一次 (loop repeat 3 for intermediate = 10 then (incf intermediate) do (print intermediate)) 10 11 12 这里是一个在bool值之间不断切换的例子 (loop repeat 4 for up = t then (not up) do (print up)) T NIL T NIL ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:10","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"循环计数器 loop 对一个List进行迭代的同时进行计数。list的长度决定了迭代合适结束。 (loop for x in '(a b c d e) for y from 1 when (\u003e y 1) do (format t \", \") do (format t \"~A\" x)) A,B,C,D,E NIL 也可以用if语句 (loop for x in '(a b c d e) for y from 1 if (\u003e y 1) do (format t \", ~A\" x) else do (format t \"~A\" x)) A,B,C,D,E NIL ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:11","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"升降序，limits loop 升序 from… to…: include the last (loop for i from 0 to 10 do (print i)) ;; 0 1 2 3 4 5 6 7 8 9 10 from… below…: not include the last (loop for i from 0 below 10 do (print i)) ;; 0 1 2 3 4 5 6 7 8 9 降序 from… downto…: include (loop for i from 10 downto 0 do (print i)) ;; 10 9 8 7 6 5 4 3 2 1 0 from… above…: not include (loop for i from 10 above 0 do (print i)) ;; 10 9 8 7 6 5 4 3 2 1 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:12","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"步长 loop loop 使用by: (loop for i from 1 to 10 by 2 do (print i)) 如果by后面跟的是一个表达式那么只会执行一次 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:13","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Loop 和条件 loop 使用if, else 和 finally: (loop repeat 10 for x = (random 100) if (evenp x) collect x into evens else collect x into odds finally (return (values evens odds))) (42 82 24 92 92) (55 89 59 13 49) 如果要结合多个语句，那么if的body需要and关键字(and do, and count) (loop repeat 10 for x = (random 100) if (evenp x) collect x into evens and do (format t \"~a is even!~%\" x) else collect x into odds and count t into n-odds finally (return (values evens odds n-odds))) 46 is even! 8 is even! 76 is even! 58 is even! 0 is even! (46 8 76 58 0) (7 45 43 15 69) 5 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:14","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"用一个语句作为loop的开始(initially) (loop initially (format t \"~a \" 'loop-begin) for x below 3 do (format t \"~a \" x)) ;;LOOP-BEGIN 0 1 2 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:15","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"用一个test（until,while）来结束循环 loop until (loop for x in '(1 2 3 4 5) until (\u003e x 3) collect x) ;; (1 2 3) while (loop for x in '(1 2 3 4 5) while (\u003c x 4) collect x) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:16","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"循环命名 和 提前退出 loop loop named foo 语法允许你创建一个能够提前退出的循环。使用return-form,即可退出已经命名的循环，甚至可以退出嵌套的循环。 (loop named loop-1 for x from 0 to 10 by 2 do (loop for y from 0 to 100 by (1+ (random 3)) when (\u003c x y) do (return-from loop-1 (values x y)))) 0 2 有的时候你想要提前退出，但是一定要执行一些语句，你可以使用loop-finish (loop for x from 0 to 100 do (print x) when (\u003e= x 3) return x finally (print :done)) ;; 0 ;; 1 ;; 2 ;; 3 ;; 3 (loop for x from 0 to 100 do (print x) when (\u003e= x 3) do (loop-finish) finally (print :done) (return x)) ;; 0 ;; 1 ;; 2 ;; 3 ;; :DONE ;; 3 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:17","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Loop thereis never always thereis (loop for x in '(foo 2) thereis (numberp x)) T never (loop for x in '(foo 2) never (numberp x)) NIL always (loop for x in '(foo 2) always (numberp x)) NIL 他们和some,notany,every对应： (some #'numberp '(foo 2)) (notany #'numberp '(foo 2)) (every #'numberp '(foo 2)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:18","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Count (loop for i from 1 to 3 count (oddp i)) ;; 2 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:19","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Summation (loop for i from 1 to 3 sum (* i i )) ;; 14 将求和的结果放入变量中 (loop for i from 1 to 3 sum (* i i) into total do (print i) finally (print total)) 1 2 3 14 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:20","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Max and Min (loop for i from 1 to 3 maximize (mod i 3)) ;; 2 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:21","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"解构, 对 list 进行dotted pairs aka 模式匹配 (loop for (a b) in '((x 1) (y 2) (z 3)) collect (list b a)) ;; ((1 X) (2 Y) (3 Z)) (loop for (x . y) in '((1 . a) (2 . b) (3 . c)) collect y) ;; (A B C) 使用nil忽略 (loop for (a nil) in '((x 1) (y 2) (z 3)) collect a) ;; (X Y Z) 两个两个的遍历 (loop for (key value) on '(a 2 b 2 c 3) by #'cddr collect (list key (* 2 value))) ;;((A 2) (B 4) (C 6)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:22","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"common lisp 定义 和 调用","date":"2022-10-04","objectID":"/function/","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"定义一个函数 可以使用defunc 关键字定义一个有名字的函数: (defun \u003cname\u003e (list of arguments) \"docstring\" (function body)) 用学语言必学的打印hello world! 来举例 (defun hello-world () ;; define a function named hello-world (format t \"hello world!\")) ;; print hello world! and return nil 调用 (hello-world) ;; \"hello world!\" \u003c-- output printed by `foramt' function ;; nil \u003c-- return value return by format why docstring common lisp 可以再函数体开始之前 改写 docstring 为函数添加文档 lisp习惯使用这种方式来给函数写一些帮助文档，类似readme这种自述文件 docstring 是对函数的描述 about the return value common lisp 的函数默认会return 最后一个表达式的值 再这里就是 (format t \"hello world!\") 的返回值也就是nil ","date":"2022-10-04","objectID":"/function/:1:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"函数返回值 ","date":"2022-10-04","objectID":"/function/:2:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"required arguments 函数的必要参数 先看这个函数定义 (defun hello (name) ;;name 就是必要参数 \"say hello to `name'.\" (format t \"hello ~a !~\u0026\" name) ;; 这里直接使用name参数 ) 直接调用 (hello \"me\") ;; hello me! \u003c-- printed by `format' ;; Nil \u003c-- return value format 的格式控制符 common lisp format 类似c语言的printf。但是common lisp的格式控制符是以 ~ 为开头的 而且字符的意义也不同 比如C语言中 \\n 代表换行 而format中 ~\u0026就代表换行符。 ","date":"2022-10-04","objectID":"/function/:2:1","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"Optional arguments 函数的可选参数: \u0026optional 可选参数是定义再 \u0026optional 关键字后面。并且要保持有序，必须一个跟着一个出现。这里有点懵逼吧。废话不多说，直接上例子。 (defun hello (name \u0026optional age gender) (format t \"name: ~a age ~a gender ~a ~\u0026\" name age gender) ) 这条函数定义中 name 是必要函数，age 和 gender是可选参数。name是必填的，就是你在调用这个函数的时候，name是必须的。而 age 和 gender 你可以选择提供或者省略。但是当你想提供 gender 这个参数的时候，你必须也要提供 age 这个参数。不严谨的说，一个可选参数要想出现，就必须建立在他前面的一个可变参数已经提供的情况下。 (hello \"me\") ;; supply required argument name. avoid optional arguments age and gender (hello \"me\" 7) ;; supply required argument name, optional argument age and void gender (hello \"me\" 7 \"female\") ;; supply name age and gender (hello \"me\" \"female\") ;; wrong for practice。 You may use hello in this way grammaly but female won`t supplied to the gender arguments 如果可选参数再调用的时候没有绑定值 那值就为 nil (hello \"me\") ;; name: me age NIL gender NIL ","date":"2022-10-04","objectID":"/function/:2:2","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"Named paramenters 具名参数: \u0026key 有时候记住参数的顺序非常不方便，lisp 提供了使用参数名来提供参数的方式. 在\u0026key 后面跟上参数名即可定义具名参数 (defun hello (name \u0026key happy) \"if `happy' is `t,print a smiley\" (format t \"hello ~a\" name) (when happy (format t \":) ~\u0026\"))) 调用的时候用 :name value 这样的形式指定参数,定义了具名参数但是调用的时候不指定value 那具名参数的value 会为nil (hello \"me\") ;; ignore the happy paramenter,happy will be set to nil defaultly (hello \"me\" :happy t) ;; bind happy to t (hello \"me\" :happy nil) ;; bind happy to nil (hello \"me\" :happy) ;; wrong! this form is definitely wrong lisp中的 t and nil lisp 中用 t 代表true nil 代表false 和 空 有关函数参数数量的想法 具名参数是为了解决记住参数的顺序不方便而诞生的，但是如果函数的参数过多的话，会导致函数的行为会变得复杂多样。clean code 中并不鼓励函数参数的数量超过3个 你也可以定义多个具名参数 (defun hello (name \u0026key happy lisper cookbook-contributor-p) ...) 使用示例 (hello \"me\" :lisper t) (hello \"me\" :lisper t :happy t) (hello \"me\" :cookbook-contributor-p t :happy t) keys can be variable 类似 :happy 这样的符号其实可以作为一个变量的值就像这样。 (let ((key :happy) ;; bind :happy to key (val t)) ;; bind t to val (hello \"me\" key val)) ;; quote key and val let 可以声明一些只能在let代码快中使用的变量这个后面会细说 ","date":"2022-10-04","objectID":"/function/:2:3","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"混合可选和具名参数 先看一个例子 (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) 如果你直接这么定义函数，lisp的解释器会报warning ; in: DEFUN HELLO ; (SB-INT:NAMED-LAMBDA HELLO ; (\u0026OPTIONAL NAME \u0026KEY HAPPY) ; (BLOCK HELLO (FORMAT T \"hello ~a \" NAME) (WHEN HAPPY (FORMAT T \":)~\u0026\")))) ; ; caught STYLE-WARNING: ; \u0026OPTIONAL and \u0026KEY found in the same lambda list: (\u0026OPTIONAL (NAME \"John\") \u0026KEY ; HAPPY) ; ; compilation unit finished ; caught 1 STYLE-WARNING condition 虽然也能调用 (hello \"me\" :happy t) ;; hello me :) ;;nil 这种情况不能直接跳过optional的参数 直接指定key 参数 还是上面这个函数 (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) 如果你尝试省略name 直接指定 :happy 就会报错 (hello :happy t) ;; odd number of \u0026KEY arguments 因为optional 的参数必须是有序出现的，如果前面的参数未出现，就不能直接指定后面的参数。但是当指定完所有的optional参数后，你就可以按照key参数的规则去指定key参数 看这个函数定义(一个不恰当的例子) (defun hello (\u0026optional name \u0026key happy age) (format t \"hello ~a \" name) (when happy (format t \":)~\u0026\"))) (hello \"me\" :age 1) 这里直接忽略happy 关键字 指定age ","date":"2022-10-04","objectID":"/function/:2:4","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"key parameters 的默认值 可以使用一对包含键值的括号来指定默认值 (happy t) (defun hello (name \u0026key (happy t))) 这样happy 的默认值就被设成了t ","date":"2022-10-04","objectID":"/function/:2:5","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"如何确定具名参数(key parameter) 是否被指定 前面有提到过，具名参数如果不指定，就会默认为NIL。那问题就是，如何知道具名参数的调用者是否故意指定这个参数为NIL呢。因为参数为NIL可能会有自己特殊的意义，所以需要判断是否是调用者故意设为NIL. 我们使用二元组 tuple 设置默认值 \u0026key (:happy t) 我们可以使用三元组 triple来解决参数知否被故意指定为NIL \u0026key (:happy t happy-p) (defun hello (name \u0026key (happy nil happy-p)) (format t \"Key supplied? ~a~\u0026\" happy-p) (format t \"hello ~a \" name) (when happy-p (if happy (format t \":)\") (format t \":(\")))) (hello \"me\" :happy t) ;; Ky supplied? T ;; hllo me :) 从返回的结果可以看到 如果指定了:happy 那么happy-p 会被自动设置为 t 即被指定状态 lisp 中有关断言命名的convenstion(传统) lisp 中习惯对用来做判断的函数或变量后面加一个p 比如 stringp :用来判断是否为字符串的函数 listp : 用来判断是否为列表类型的函数 p是predicate的缩写 意为断言 ","date":"2022-10-04","objectID":"/function/:2:6","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"可变数量参数: \u0026rest 的时候，你会想要定义一些函数，可以接受很多个参数，但是具体多少个，你也不清楚。比如你想定义个函数把所有的参数都相加进行求和。 (defun sum (arg1 arg2 arg3 ... to arg100....)) 这样太累了，你不可能一个一个的敲。我们可以这样 (defun hello (\u0026rest numbers) (apply #'+ numbers)) 调用 (hello 1 2 3 4) ;; 10 \u003c-- returned by hello apply 函数 apply 的第一个参数接收一个拥有两个参数的回调函数 第二个参数接受一个列表（这里为了方便理解代码这么说，其实这是不严谨的） 就像这样 (apply #'func '(arg1 arg2 arg3)) arg1 arg2 arg3 将会作为func 的参数传递给func 并进行运算. 也就是说 apply的操作是将 list 展开成一个个参数并传给func。 比如(apply #+ ‘(1 2 3 4)) 和 (+ 1 2 3 4) 是等价的。 列表 ‘(1 2 3 4) 被展开成 1 2 3 4 传递给了func ","date":"2022-10-04","objectID":"/function/:2:7","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"允许额外的key: \u0026allow-other-keys 先看下下面的例子 (defun hello (name \u0026key happy) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; Error: unknown keyword argument 再看看这个 (defun hello (name \u0026key happy \u0026allow-other-keys) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; hello me 这里我们并没有给出 :lisper 这个关键字的定义 但是函数仍然允许我们这么调用而不是直接报错 《common lisp cook book》 中给出过一个实用的案例 (defun open-supersede (f \u0026rest other-keys \u0026key \u0026allow-other-keys) (print other-keys) (apply #'open f :if-exists :supersede other-keys)) 这个函数的定义要求必须有一个f参数，以及任意数量的other-keys 其实 \u0026key 以及\u0026allow-other-keys 被忽略了只做提示用（告诉调用者可以接受其他具名参数）。因为有\u0026rest 这个标志符在 除了f外 参数都会传到other-keys里面。所以\u0026key \u0026allow-other-keys就失去了语法上的意义。起码在编译器看来，他是无意义的。 但是如果你不按照函数签名指示的方式调用，内层的函数就很有可能报错，所以即使\u0026key \u0026allow-other-keys被编译器忽略(这种函数在定义时，甚至可以忽略\u0026key \u0026allow-other-keys关键字，功能并不会因为没有他们而受影响)，你也应该按照签名去调用函数。因为内层的函数需要依赖这个签名规则。 来看这个函数调用 (open-supersede \"test.log\" :if-does-not-exist :create) ;;(:IF-DOES-NOT-EXIST :CREATE) \u003c\u003c-- 由(print other-keys)打印 可以看到具名参数都被传给了\u0026rest 必要的函数文档 在写这种函数的时候，应该写上docstring 因为函数签名已经不能很好的描述函数了，我们应该加上docstring来描述函数，不要让调用者疑惑。 ","date":"2022-10-04","objectID":"/function/:2:8","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"函数返回值 common lisp 的返回值默认是函数的最后一个执行语句 你也可以使用(return-from \u003cfunction name\u003e \u003cname\u003e \u003cvalue\u003e) 显示的从具体函数内返回。注意这里是直接从\u003cfunction name\u003e 指定的函数中返回,不仅仅是从当前运行的函数中返回，也有可能直接从外层函数返回。 多数时候我们并不使用return-from ","date":"2022-10-04","objectID":"/function/:3:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"多返回值：values,multiple-value-bind and nth-value 我们使用values来构造一个多返回值 (defun foo (a b c) (values a b c)) 因为函数的最后一条语句的结果会被返回，所以values构造的多返回值会被直接返回给上层 (setf res (foo :a :b :c)) ;; :A \u003c\u003c-- res 为:A 这里res为:A而不是 :A :B :C 是因为这里的返回值接受者只有res 所以只有第一个:A 被接受 :B :C 都被自动忽略掉了. 接受多返回值得方法为multiple-value-bind。 multiple-value-bind 使用multiple-value-bind来解构多返回值。 (multiple-value-bind (res1 res2 res3) (foo :a :b :c) (format t \"res1 is ~a, res2 is ~a, res3 is ~a ~\u0026\" res1 res2 res3)) ;res1 is A, res2 is B res3 is C ;nil 通用格式 (multiple-value-bind (var-1 .. var-n) expr body) multiple-value-bind绑定的变量是局部的 使用multiple-value-bind的变量再它外面是访问不到的, 也就是说上面的例子中 res1 只能再(multipe-value-bind)的内部使用。而无法再外部使用 nth-value nth-value 是可以直接拿到指定索引的返回值 (nth-value 0 (values :a :b :c)) ;; =\u003e :A (nth-value 2 (values :a :b :c)) ;; =\u003e :C (nth-value 9 (values :a :b :c)) ;; =\u003e NIL 但是如果将 nth-value 用在List上，结果就不一样了 (nth-value 0 '(:a :b :c)) ;; =\u003e (:A :B :C) (nth-value 1 '(:a :b :c)) ;; =\u003e NIL Note (values) 将不会返回任何值 multiple-value-list multiple-value-list 将返回值构造成list (multiple-value-list (values 1 2 3)) ;; (1 2 3) 相反的操作有将list 构造成多返回值 (value-list '(1 2 3)) ","date":"2022-10-04","objectID":"/function/:3:1","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"匿名函数 lambda 使用lambda函数创建匿名函数 (lambda (x) (print x)) 我们可以用funcall 或者 apply 来调用匿名函数 如果一个未被引用的括号表达式内部第一个元素是一个匿名函数，那么这个匿名函数就会被调用 ((lambda (x) (print x)) \"hello\") 引用 lisp中 引用是指以’为开头的表达式或符号。‘将保护表达式或符号维持其本身。 比如(func arg) 这种形式的表达式将会自动被当做函数执行,有些情况我们并不想让他执行（比如传一个list 给函数做参数的时候的时候） (defun hello (arg)) (hello (1 2 3)) ;; illegal function call 这里(1 2 3) 将会被求值 并不会真的传一个(1 2 3) 给arg且会报 illegal function call 这样的错误。因为没有被’ 保护的函数会被自动当成函数并且运算。 所以正确的形式应该是 (defun hello (arg)) (hello '(1 2 3)) ‘就是保护表达式或变量维持其本身 ","date":"2022-10-04","objectID":"/function/:4:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"使用funcall 和 apply 调用函数 funcall 和 apply 类似，都是将参数规整成正确的形式然后传给回调函数 (funcall #'func arg1 arg2 .. argn) ;; ^^ 回调 要传给func的参数 不同点在于， funcall 不会自动展开list 列表 而apply 可以将列表展开成一个个参数传给回调func (funcall #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) 会原封不动的传给func (apply #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) 会被展开成 arg3 arg4 最后的形式就是 (apply #'func arg1 arg2 arg3 arg4) ","date":"2022-10-04","objectID":"/function/:4:1","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"使用 single quote ’ 还是 sharpsign-quote #’ 来引用函数? single quote ’ 和 sharpsign-quote #‘的不同在于 #’ 使用的是词法作用域(lexical scope) 会更安全点 (defun foo (x) (* x 100)) (flet ((foo (x) (1+ x))) (funcall #'foo 1)) ;; =\u003e 2, as expected ;; ;; But: (flet ((foo (x) (1+ x))) (funcall 'foo 1)) ;; =\u003e 100 lexical scope 词法作用域的意思是，当找一个变量或函数的时候（函数此时作为值进行传递）会默认去定义的地方去找而不是再函数运行的环境中去找。 上面的foo 一个是在外面声明的 一个是使用flet 保护起来的foo 对于funcall 来说 #’会去找flet 出来的foo 因为词法作用域要求在定义的地方去找需要的函数。 single quote ’ 使用的是动态作用域 会默认去运行环境中找所以 即使第二个flet 也声明了 foo 但是funcall 的时候还是去到外层寻找foo #’ 其实就是(function … )的语法糖 (function +) ;; #\u003cFUNCTION +\u003e (flet ((foo (x) (1+ x))) (print (function foo)) (funcall (function foo) 1)) ;; #\u003cFUNCTION (FLET FOO) {1001C0ACFB}\u003e ;; 2 ","date":"2022-10-04","objectID":"/function/:4:2","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"高级函数 能够返回函数的函数 (functions that return functions) (defun adder (n) (lambda (x) (+ x n))) 这样就定义了一个能够返回一个函数对象的adder函数 要想调用这个函数对象我们需要funcall 或者 apply (adder 5) ;; #\u003cCLOSURE (LAMBDA (X) :IN ADDER) {100994ACDB}\u003e (funcall (adder 5) 3) ;; 8 如果你想以正常的思维去调用这个函数对象，会报错 ((adder 3) 5) ;;In: (ADDER 3) 5 ;;((ADDER 3) 5) ;;Error: Illegal function call. 在common lisp 中 对于变量和方法 他们有不同的命名空间。 比如一个变量和一个函数可以有同一个名字, 这取决于他被运算的环境 ;; The symbol foo is bound to nothing: CL-USER\u003e (boundp 'foo) NIL CL-USER\u003e (fboundp 'foo) NIL ;; We create a variable: CL-USER\u003e (defparameter foo 42) FOO * foo 42 ;; Now foo is \"bound\": CL-USER\u003e (boundp 'foo) T ;; but still not as a function: CL-USER\u003e (fboundp 'foo) NIL ;; So let's define a function: CL-USER\u003e (defun foo (x) (* x x)) FOO ;; Now the symbol foo is bound as a function too: CL-USER\u003e (fboundp 'foo) T ;; Get the function: CL-USER\u003e (function foo) #\u003cFUNCTION FOO\u003e ;; and the shorthand notation: * #'foo #\u003cFUNCTION FOO\u003e ;; We call it: (funcall (function adder) 5) #\u003cCLOSURE (lambda (X) :IN ADDER) {100991761B}\u003e ;; and call the lambda: (funcall (funcall (function adder) 5) 3) 8 可以认为，每个symbol 在CL(common lisp)中多有多个cell(空间)存储不同的信息，比如有的表示一个value-cell 你可以用boundp 来测试是否绑定了一个value. 你可以使用symbol-value访问value-cell. 还有其他cell 比如function-cell 可以保存symbol 的function. 你可以用fboundp来测试，使用symbol-function 来访问这个function. 如果symbol 被运算，那它就被当做是一个variable 并且他的value-cell将被返回。如果是符合形式，即cons,被求值并且他的car是一个symbol，那么使用这个symbol的function-cell. 所以上面的((addr 3) 5)的调用会报错。因为(addr 3) 既不是符号 也不是lambda表达式. ;;; continued from above CL-USER\u003e (fboundp '*my-fun*) NIL CL-USER\u003e (setf (symbol-function '*my-fun*) (adder 3)) #\u003cCLOSURE (lambda (X) :IN ADDER) {10099A5EFB}\u003e CL-USER\u003e (fboundp '*my-fun*) T CL-USER\u003e (*my-fun* 5) 8 ","date":"2022-10-04","objectID":"/function/:5:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"Closures 闭包 Closures 允许捕获词法绑定的值 (let ((limit 3) (counter -1)) (defun my-counter() (if (\u003c counter limit) (incf counter) (setf counter 0)))) (my-counter) 0 (my-counter) 1 (my-counter) 2 (my-counter) 3 (my-counter) 0 lexical 这里可以看见，counter 和 limit 是在let后就已经存在的值。my-counter 会去找被let的limit 和 counter. let就是将let定义的值与下面的函数体(body)做绑定。 还可以这样 (defun repeater (n) (let ((counter -1)) (lambda () (if (\u003c counter n) (incf counter) (setf counter 0))))) (defparameter *my-repeater* (repeater 3)) (defparameter *my-repeater2* (repeater 2)) (funcall *my-repeater*) 0 (funcall *my-repeater*) 1 (funcall *my-repeater*) 2 (funcall *my-repeater2*) 0 (funcall *my-repeater*) 3 (funcall *my-repeater*) 0 这里可以看到my-repeater 和my-repeater之间是相互隔离的 各自拥有自己的counter. 这是因为repeater 被执行了两次而 lambda 表达式被定义了两次，而被let包裹的函数会去其定义的环境中寻找值，所以两者的counter是隔离的。 ","date":"2022-10-04","objectID":"/function/:6:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"TODO setf functions ","date":"2022-10-04","objectID":"/function/:7:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"柯里化 currying 维基百科上的解释是，把接受多个参数的函数转换成接受一个单一参数的函数 (defun curry (function \u0026rest args) (lambda (\u0026rest more-args) (apply function (append args more-args)))) 这个函数再第一次调用的时候会返回lambda函数 (funcall (curry #'+ 3) 5) ;;8 ","date":"2022-10-04","objectID":"/function/:8:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"common lisp 的一些基本数据结构","date":"2022-10-04","objectID":"/data_structure/","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Lists ","date":"2022-10-04","objectID":"/data_structure/:1:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Building lists. Cons cells,list list(列表) 也是一个 sequence(序列). list 由cons组成。 cons 有两个cell 一个叫 “car” 一个 叫 “cdr” 我们可以像这样构建一个简单的list (cons 1 2) ;;=\u003e (1 . 2) ;; 这是一个dotted pair 表示一个cons 它的底层结构可以抽象成这样 [o|o]--- 2 | 1 如果第一个cons的cdr 是另一个cons 并且最后一个cons 的cdr 是nil ,那么我们就得到了一个list (cons 1 (cons 2 nil)) ;; =\u003e (1 2) 底层结构是这样的 [o|o]---[o|/] ^ ^ 1 2 为什么不是dotted pair lisp printer 遇到这种结构的时候会自动将逗号省略。但是list还是由一个个dotted pair组成的。 更简单的 可以用list 函数来构建list (list 1 2) ;; =\u003e (1 2) 或者使用一个引用符号' '(1 2) ;; =\u003e (1 2) ","date":"2022-10-04","objectID":"/data_structure/:1:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Circular lists 循环列表 cons 的两个cell 可以 c存放任何值，所以也可以存放自己，或者列表的最后一个元素的cdr存储列表的第一个元素.这个时候就构成了循环列表。 引文最后一个元素的cdr 存的是列表的开始。 在开始之前，我们要将*print-circle* 设为t告诉printer 不要无限答应循环列表。 (setf *print-circle* t) 首先定义一个能构造循环列表的函数 (defun circular! (items) \"Modifies the last cdr of list ITEMS, returning a circular list\" (setf (cdr (last items)) items)) (circular! (list 1 2 3)) (fifth (circular! (list 1 2 3))) ;; =\u003e 2 对于循环列表list-length将会返回nil reader 也可以构建一个循环列表，使用sharpsign equal-sign notation. 一个object(对象) 可以以#n=作为前缀，n是一个无符号十进制整数。可以用#n#去引用已经定义的对象 '#42=(1 2 3 . #42#) ;; =\u003e #1=(1 2 3 . #1#) ","date":"2022-10-04","objectID":"/data_structure/:1:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"car/cdr or first/rest (and second… to tenth) (car (cons 1 2)) ;; return the car cell of a cons. here return 1 (cdr (cons 1 2)) ;; return the cdr cell of a cons.here return 2 (first '(1 2 3 4 5)) ;; return the car of first. here return 1 (second '(1 2 3 4 5)) ;; return the car of second. here return 2 (third '(1 2 3 4 5)) ;; return the car of third. here return 3 . . . (tenth '(1 2 3 4 5 6 7 8 9 10)) ;; return the car of tenth. here return 10 (rest '(rest)) ;; return (2 3) rest return cdr of the first cons setf 可以用来给列表中的元素赋值 (defparameter ll '(1 2 3 4)) (setf (first ll) 2) ll ;; now ll is (2 2 3 4) ","date":"2022-10-04","objectID":"/data_structure/:1:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"last,butlast,nbutlast(\u0026optional n) (last '(1 2 3)) ;; return last of cons of (1 2 3). here return (3) ;; =\u003e (3) (car (last '(1 2 3))) ;; or (first (last ...)) ;; =\u003e 3 (butlast '(1 2 3));; return the list except the last ;; =\u003e (1 2) ","date":"2022-10-04","objectID":"/data_structure/:1:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"reverse,nreverse 倒序 reverse 和 nreverse 都返回一个新的序列(sequence) nreverse 是毁灭性的(destructive)。前缀 n 代表 non-consing,代表他是直接在原有List上进行修改。 (defparameter mylist '(1 2 3)) ;; =\u003e (1 2 3) (reverse mylist) ;; =\u003e (3 2 1) mylist ;; =\u003e (1 2 3) (nreverse mylist) ;; =\u003e (3 2 1) mylist ;; =\u003e (1) in SBCL but implementation dependent. destructive 如果一个函数会修改他的他的操作元素 我们就说他是destructive的 ","date":"2022-10-04","objectID":"/data_structure/:1:5","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"append append 会将两个list合并成一个list (append (list 1 2) (list 3 4)) ;; =\u003e (1 2 3 4) append 的坑 append 返回的List会共享原有的list的cons 所以在其返回的list进行修改，也会影响原有的list ","date":"2022-10-04","objectID":"/data_structure/:1:6","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"push (item,place) push 是destructive的 他会将新的元素插入list的最前面 (defparameter mylist '(1 2 3)) (push 0 mylist) ;;=\u003e (0 1 2 3) mylist ;;=\u003e (0 1 2 3) (defparameter x ’(a (b c) d)) ;; =\u003e (A (B C) D) (push 5 (cadr x)) ;; =\u003e (5 B C) x ;; =\u003e (A (5 B C) D) CL 没有默认的尾插函数，如果想要尾插你可以先将list 进行 reverse 或者使用别的数据结构 ","date":"2022-10-04","objectID":"/data_structure/:1:7","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"pop pop 是 desctructive 和 push 相对 push 会往里面插入 而pop会将最前面的元素返回并删除 ","date":"2022-10-04","objectID":"/data_structure/:1:8","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"nthcdr (index ,list) 返回第n个cons 的 cdr。 (defparameter mylist '(1 2 3)) (nthcdr 1 mylist) ;; =\u003e (2) ","date":"2022-10-04","objectID":"/data_structure/:1:9","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"复合的car 和 cdr 我们可以复合 a 和 d 来做一些方便的操作。比如cadr 就是 返回 the car of cdr caar 就是返回 the car of car 这些操作通常在嵌套list中有些意义 (caar (list 1 2 3));; ==\u003e error (caar (list (list 1 2) 3)) ;; ==\u003e 1 (cadr (list (list 1 2) (list 3 4))) ;; ==\u003e (3 4) (caadr (list (list 1 2) (list 3 4))) ;; == \u003e 3 ","date":"2022-10-04","objectID":"/data_structure/:1:10","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"destructuring-bind (parameter*,list) 这个函数将List中的元素与参数绑定，我们可以析构tree,plists (destructuring-bind (x y z) (list 1 2 3) (list :x x :y y :z z)) ;; =\u003e (:X 1 :Y 2 :Z 3) 内部的sublist也可以绑定 (destructuring-bind (x (y1 y2) z) (list 1 (list 2 20) 3) (list :x x :y1 y1 :y2 y2 :z z)) ;; =\u003e (:X 1 :Y1 2 :Y2 20 :Z 3) parameter list 还可以用\u0026optional,\u0026rest 和 \u0026key (destructuring-bind (x (y1 \u0026optional y2) z) (list 1 (list 2) 3) (list :x x :y1 y1 :y2 y2 :z z)) ;; =\u003e (:X 1 :Y1 2 :Y2 NIL :Z 3) (destructuring-bind (\u0026key x y z) (list :z 1 :y 2 :x 3) (list :x x :y y :z z)) ;; =\u003e (:X 3 :Y 2 :Z 1) \u0026whole parameter 会被绑定到整个list. 他必须再第一个 其余的参数必须在它后面 (destructuring-bind (\u0026whole whole-list \u0026key x y z) (list :z 1 :y 2 :x 3) (list :x x :y y :z z :whole whole-list)) ;; =\u003e (:X 3 :Y 2 :Z 1 :WHOLE (:Z 1 :Y 2 :X 3)) ","date":"2022-10-04","objectID":"/data_structure/:1:11","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"null,listp 断言 null 和 not 相同，但是看起来更好 用来判断一个列表是否为空 listp 判断一个对象是否是一个cons cell ","date":"2022-10-04","objectID":"/data_structure/:1:12","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"ldiff,tailp,list*,make-list,fill,revappend,nreconc,consp,atom 只介绍几个常用的，其余的可以去查文档（太多了，不想写（小声bb） 很多其实不常用，就不写了） make-list 构造一个list (make-list 3 :initial-element \"ta\") ;; =\u003e (\"ta\" \"ta\" \"ta\") fill 用指定对象填充list (make-list 3) ;; =\u003e (NIL NIL NIL) (fill * \"hello\") ;; =\u003e (\"hello\" \"hello\" \"hello\") tailp 用来判断是否有共享的列表结构，也就是是否有相同的cons cell(use EQL for predicate),而不仅仅是cons cell的内容 (tailp t '(1 2 3 4 . t)) ;; =\u003e T (tailp nil '(1 2 3 4 . nil)) ;; =\u003e T (tailp nil '(1 2 3 4)) ;; =\u003e T (tailp #1=\"e\" '(1 2 3 4 . #1#)) ;; =\u003e T (defparameter *tail* (list 3 4 5)) (defparameter *larger* (list* 1 2 *tail*)) (defparameter *replica* (copy-list *larger*)) (tailp *tail* *replica*) ;; ==\u003e nil (tailp *tail* *larger*) ;; ==\u003e t ","date":"2022-10-04","objectID":"/data_structure/:1:13","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"member (elt,list) 返回以elt开始的剩下的元素 默认使用eql作为比较函数 接受:test :test-not :key(functions or symbols) (member 2 '(1 2 3)) ","date":"2022-10-04","objectID":"/data_structure/:1:14","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"替换tree中的对象:subst,sublis subst 和 subst-if 在tree中查找所有和element相同的元素 并 用另一个element 替换 (可以用:test 指定判断相同的函数) (subst 'one 1 '(1 2 3)) ;; =\u003e (one 2 3) (subst '(1 . one) '(1 . 1) '((1 . 1) (2 . 2) (3 . 3)) :test #'equal) ;; ((1 . ONE) (2 . 2) (3 . 3)) sublis 第一个参数是一个list(每个元素都是一个 dot list),每个dot list 有2个元素(x . y) 表示将 x 替换 为 y sublis 接受:test 和 :key 参数 :test 是一个接受key 和 subtree为参数的函数 (sublis '((t . \"foo\")) (\"one\" 2 (\"three\" (4 5))) :key #'stringp) ;; (\"foo\" 2 (\"foo\" (4 5))) ","date":"2022-10-04","objectID":"/data_structure/:1:15","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Sequences 序列 lists vectors strings 都是序列 大多数和序列有关的函数都接受keyword 参数。所有keyword 参数都是可选的，并且可以以任意顺序出现 :test参数默认使用eql (对于strings 来说 用:equal) :key 参数可以接受nil 和 单参数的函数（这个函数声明了我们具体要怎么看待序列中的每个元素） (defparameter my-alist (list (cons 'foo \"foo\") (cons 'bar \"bar\"))) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) (find 'bar my-alist) ;; =\u003e NIL (find 'bar my-alist :key 'car) ","date":"2022-10-04","objectID":"/data_structure/:2:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"断言: every , some…. every 的作用是判断列表中的元素是否都满足某个条件 (都满足就返回真) (defparameter foo '(1 2 3)) (every #'evenp foo) ;; =\u003e NIL some 则只需要一些元素满足条件即可 (一些满足就返回真) (defparameter foo '(1 2 3)) (every #'evenp foo) ;; =\u003e NIL notany 只要不是所有都满足就返回真 ","date":"2022-10-04","objectID":"/data_structure/:2:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"常用函数 alexandria库 《common lisp cookbook》中一直提到有一个\"alexandria\"的库里面有很多非常实用的函数，是对common lisp 的一种扩充，可以去看一看 length(sequence) 返回序列的长度 elt(sequence,index) find by index count (foo sequence) 返回 sequence中 出现foo的次数 可接受:from-end,:start,:end 相关的还有count-if,count-not(test-function sequence) subseq (sequence start,[end]) 返回子序列左闭右开[start,end): (subseq (list 1 2 3) 0) ;; (1 2 3) (subseq (list 1 2 3) 1 2) ;; (2) end不能大于( + (length sequence) 1) 因为这样会越界: (defparameter my-list '(1 2 3 4)) (subseq my-list 0 (+ length(my-list) 1)) ;; =\u003e Error: the bounding indices 0 and 5 are bad for a sequence of length 3. 如果果可能越界，用alexandria-2:subseq*: (alexandria-2:subseq* (list 1 2 3) 0 99) subseq 是\"setf\" able 的 但是只有当新的序列的长度和要被替换的序列长度一致的时候才会生效 (defparameter my-list '(1 2 3 4)) ;; =\u003e(1 2 3 4) (setf (subseq my-list 0 2) '(2 3)) my-list ;; =\u003e (2 2 3 4) sort,stable-sort(sequence,test[,key function]) 这两个函数时destructive的，所以在排序前，可能会优先使用copy-seq 拷贝一份出来 (sort (copy-seq seq) :test #'string\u003c) 就像名字中说的一样 sort是不稳定的而stable-sort是稳定的 find,position(foo,sequence) - get index also find-if,find-if-not,position-if,position-if-not(test sequence) (find 20 '(10 20 30)) ;; 20 (position 20 '(10 20 30)) ;; 1 search and mismatch (sequence-a, sequence-b) search 会在sequence-b 中寻找和sequence-a 一样的subsequence。他会返回sequence-a 在 sequence-b 中的位置，如果没找到就是nil. 参数有 from-end,end1,end2 以及上面提到的test 和 key (search '(20 30) '(10 20 30 40)) ;; 1 (search '(\"b\" \"c\") '(\"a\" \"b\" \"c\")) ;; nil (search '(\"b\" \"c\") '(\"a\" \"b\" \"c\") :test #'equal) ;;1 (search \"bc\" \"abc\") ;;1 mismatch 返回两个序列开始不一样的地方 (mismatch '(10 20 99) '(10 20 30)) ;; 2 (mismatch \"hellolisper\" \"helloworld\") ;; 5 (mismatch \"same\" \"same\") ;; NIL (mismatch \"foo\" \"bar\") ;; 0 substitute,nsubstitute[if,if-not] 返回一个同类型的序列，这个序列将会用新的元素替代就的元素 (substitute #\\o #\\x \"hellx\") ;; =\u003e \"hello\" (substitute :a :x '(:a :x :x)) ;; =\u003e (:A :A :A) (substitute \"a\" \"x\" '(\"a\" \"x\" \"x\") :test #'string=) ;; =\u003e (\"a\" \"a\" \"a\") replace (sequence-a,sequence-b,\u0026key start1,end1) 破坏性的用sequence-b 中的元素替换sequence-a中的元素 完整的函数签名: (replace sequence1 sequence2 \u0026rest args \u0026key (start1 0) (end1 nil) (start2 0)(end2 nil)) (replace \"xxx\" \"foo\") \"foo\" (replace \"xxx\" \"foo\" :start1 1) \"xfo\" (replace \"xxx\" \"foo\" :start1 1 :start2 1) \"xoo\" (replace \"xxx\" \"foo\" :start1 1 :start2 1 :end2 2) \"xox\" remove,delete(foo sequence) 返回一个不包含foo的新sequence 接受:start/end 和 :count参数 (remove \"foo\" '(\"foo\" \"bar\" \"foo\") :test 'equal) ;; =\u003e (\"bar\") remove-duplicates,delete-duplicates(sequence) 去重操作 delete与remove 不同的地方在于 delete会直接操作原始的sequence 接受 from-end test test-not start end key (remove-duplicates '(:foo :foo :bar)) (:FOO :BAR) (remove-duplicates '(\"foo\" \"foo\" \"bar\")) (\"foo\" \"foo\" \"bar\") (remove-duplicates '(\"foo\" \"foo\" \"bar\") :test #'string-equal) (\"foo\" \"bar\") mapping (map,mapcar,remove-if[-not],…) mapcar 只能用于list 而map 适用于vector list 但是由于map 可以用于多种结构 所以要指定返回值类型实参。(map ’list function vector) mapcar 可以接受多个list 映射操作会在最短的list被操作完是中断 (defparameter foo '(1 2 3)) (map 'list (lambda (it) (* 10 it)) foo) reduce (function,sequence). 首先会将function作用于列表第一个和第二个元素，然后将function作用于这个结果与下一个元素直到处理完所有元素 如果指定了特殊参数:initial-value. 首先就不会将function作用于列表的第一个和第二个元素，而是首先将function作用于:initial-value 和第一个值 (reduce '- '(1 2 3 4)) ;; =\u003e -8 (reduce '- '(1 2 3 4) :initial-value 100) ;; =\u003e 90 Creating lists with variables 由于quote ’ 会保护表达式不被求值，所以我们得用list来新建列表，但是list 函数所有的参数都会先被求值然后再构造成列表. 如果只是想特定的变量被求职，我们可以使用backquote ` 来构造List 先来个正常的quote (defparameter *var* \"bar\") ;; First try: '(\"foo\" *var* \"baz\") ;; no backquote ;; =\u003e (\"foo\" *VAR* \"baz\") ;; nope 再来个backquote `(\"foo\" ,*var* \"baz\") ;; backquote, comma ;; =\u003e (\"foo\" \"bar\" \"baz\") ;; good 在backquote 后面 以comma , 开头的变量会被正常求值 如果变量是一个list的话 (defparameter *var* '(\"bar\" \"baz\")) ;;First try: `(\"foo\" ,*var*) ;; =\u003e (\"foo\" (\"bar\" \"baz\")) ;; nested list `(\"foo\" ,@*var*) ;; =\u003e (\"foo\" \"bar\" \"baz\") ","date":"2022-10-04","objectID":"/data_structure/:2:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"集合操作Set 首先，一个集合不会包含两个同样的元素，并且集合内部是无需的. 大多数函数都有循环利用已经有的变量的函数版本(破坏性的) 区别于正常的 他们以\"n\"开头. 他们都可以接受:key 和 :test 参数 intersection list的交集 (defparameter list-a '(0 1 2 3)) (defparameter list-b '(0 2 4)) (intersection list-a list-b) ;; =\u003e (2 0) set-difference 作差 (set-difference list-a list-b) ;; =\u003e (3 1) (set-difference list-b list-a) ;; =\u003e (4) union 并集 (union list-a list-b) ;; =\u003e (3 1 0 2 4) ;; order can be different in your lisp 补集 set-exclusive-or (set-exclusive-or list-a list-b) ;; =\u003e (4 3 1) adjoin 添加 会返回新的集合，原有集合不会被修改 (adjoin 3 list-a) ;; =\u003e (0 1 2 3) (adjoin 5 list-a) ;; =\u003e (5 0 1 2 3) ;; \u003c-- element added in front. list-a ;; =\u003e (0 1 2 3) ;; \u003c-- original list unmodified. subsetp 是否为子集 (subsetp '(1 2 3) list-a) ;; =\u003e T (subsetp '(1 1 1) list-a) ;; =\u003e T (subsetp '(3 2 1) list-a) ;; =\u003e T (subsetp '(0 3) list-a) ;; =\u003e T ","date":"2022-10-04","objectID":"/data_structure/:2:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Fset-immutable data structure 也可以去quicklisp 看看FSet库 ","date":"2022-10-04","objectID":"/data_structure/:2:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"array 和 vector Arrays 的访问时间复杂度是常数时间的 他们可以是fixed 或者 adjustable的。 一个simple array 既不能被displaced(置换) 也不能被adjust(调整) 更不会有fill-pointer 除非我们用:displaced-to, :adjust-array,:fill-pointer 指定, Vector 不同于 array的地方在于 他的维度只能固定再1维 vector 也是一个序列(sequence) ","date":"2022-10-04","objectID":"/data_structure/:3:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"创建和调整array make-array(sizes-list :adjustable :initial-element ) common lisp 至少可以指定7个维度，买个维度可以至少容纳1023个元素，如果提供了:initial-element 那么这个值会作为初始值 (make-array '(2 3) :initial-element nil) adjust-array(array,sizes-list :element-type : initial-element) adjust-array 用于调整函数的维度 ","date":"2022-10-04","objectID":"/data_structure/:3:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"访问 : aref (array i [j…]) aref (array i j k …) 取指定索引上的元素 row-major-aref(array i) 和 (aref i i i ….) 相同 用来去主轴上的元素 返回的结果都可以被setf 赋值 (defparameter myarray (make-array '(2 2 2) :initial-element 1)) myarray ;; =\u003e #3A(((1 1) (1 1)) ((1 1) (1 1))) (aref myarray 0 0 0) ;; =\u003e 1 (setf (aref myarray 0 0 0) 9) ;; =\u003e 9 (row-major-aref myarray 0) ;; =\u003e 9 ","date":"2022-10-04","objectID":"/data_structure/:3:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"sizes array-total-size(array): 返回array 中一共有多少个元素 array-dimensions(array): 返回array每一维的长度 array-dimension(array i): 返回第i维的长度 array-rank: 返回函数一共有多少维 (defparameter myarray (make-array '(2 2 2))) ;; =\u003e MYARRAY myarray ;; =\u003e #3A(((0 0) (0 0)) ((0 0) (0 0))) (array-rank myarray) ;; =\u003e 3 (array-dimensions myarray) ;; =\u003e (2 2 2) (array-dimension myarray 0) ;; =\u003e 2 (array-total-size myarray) ;; =\u003e 8 ","date":"2022-10-04","objectID":"/data_structure/:3:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Vector 创建vector 可以使用vector 或者读取宏 #(). 他会返回一个simple vector (vector 1 2 3) ;; =\u003e #(1 2 3) #(1 2 3) ;; =\u003e #(1 2 3) vector-push (foo vector): 将fill-pointer 指向的元素替换成foo vector-push-extend (foo vector [extension-num])t: 与vector-push相似，但是如果fill-pointer比较大，他会拓展数组 vector-pop (vector): 返回fill-pointer 指向的元素 并删除 fill-pointer (vector). setfable.: 返回array的fill-pointer and see also the sequence functions. fill-pointer fill-pointer 就是vector-push要push的index位置（或者vector-push-extend）.也叫填充句柄。如果一个元素他的index大于这个fill-pointer 那么他就是active的 如果小于fill-pointer 就是inactive的 ","date":"2022-10-04","objectID":"/data_structure/:3:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Hash Table ","date":"2022-10-04","objectID":"/data_structure/:4:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"创建一个hash table make-hash-table 创建一个hash table。make-hash-table 没有必要参数。:test 参数指定用来判断key是否相同的函数 Note see shorter notations in the Serapeum or Rutils libraries. For example, Serapeum has dict, and Rutils a #h reader macro. ","date":"2022-10-04","objectID":"/data_structure/:4:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"获取hash table 中的元素 gethash 接受两个必要参数 一个要获取的元素的key 一个hash table. 它返回key绑定的value 和 一个bool 值表示是否在hash table中找到这个值. 它还有一个可选参数default 表示找不到时的默认值 (defparameter my-table (make-hash-table)) (gethash 'bar my-table 'default-value) ;; =\u003e default-value,NIL 获取 hashtable中所有的value or key (ql:quickload \"alexandria\") (alexandria:hash-table-keys my-table) ","date":"2022-10-04","objectID":"/data_structure/:4:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"向hash table 添加一个元素 可以使用gethash+setf 向hash table 中添加元素 CL-USER\u003e (defparameter *my-hash* (make-hash-table)) *MY-HASH* CL-USER\u003e (setf (gethash 'one-entry *my-hash*) \"one\") \"one\" CL-USER\u003e (setf (gethash 'another-entry *my-hash*) 2/4) 1/2 CL-USER\u003e (gethash 'one-entry *my-hash*) \"one\" T CL-USER\u003e (gethash 'another-entry *my-hash*) 1/2 T ","date":"2022-10-04","objectID":"/data_structure/:4:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"判断hash table 中某个key是否存在 gethash 的第一个返回值会返回对应key绑定的value 但是有的时候我们可能会刻意让这个value 为 nil。 所以使用第一个返回值是不可靠的。第二个返回值会明确告诉我们这个键值对是否存在，所以判断是否存在可以这样。 (if (nth-value 1 (gethash 'bar my-table)) \"Key exists\" \"Key does not exist\") ","date":"2022-10-04","objectID":"/data_structure/:4:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"从hash table 中删除 remhash (remove-hash的缩写) 专门用来删除一个哈希表条目。当hash table中有这个条目的时候 返回T 否则就返回 NIL (defparameter *my-hash* (make-hash-table)) ;; ==\u003e ,*MY-HASH* (setf (gethash 'first-key *my-hash*) 'one) ;; =\u003e ONE (gethash 'first-key *my-hash*) ;; =\u003e ONE,T (remhash 'first-key *my-hash*) ;; =\u003eT (gethash 'first-key *my-hash*) ;; =\u003e NIL,NIL CL-USER\u003e (gethash 'no-entry *my-hash*) ;; =\u003e NIL,NIL CL-USER\u003e (remhash 'no-entry *my-hash*) ;; =\u003e NIL CL-USER\u003e (gethash 'no-entry *my-hash*) ;; =\u003e NIL,NIL ","date":"2022-10-04","objectID":"/data_structure/:4:5","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"clear a hash table 使用clrhash 清空一个hash table (defparameter my-hash (make-hash-table)) (setf (gethash 'first-key my-hash) 'one) (setf (gethash 'second-key my-hash) 'two) my-hash ;; =\u003e #\u003chash-table :TEST eql :COUNT 2 {10097BF4E3}\u003e (clrhash my-hash) ;; =\u003e #\u003chash-table :TEST eql :COUNT 0 {10097BF4E3}\u003e (gethash 'first-key myhash) ;; =\u003e NIL,NIL (gethash 'second-key myhash) ;; =\u003e NIL,NIL ","date":"2022-10-04","objectID":"/data_structure/:4:6","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"遍历hash table 使用maphash 遍历 (defparameter my-hash (make-hash-table)) (setf (gethash 'first-key *my-hash*) 'one) (setf (gethash 'second-key *my-hash*) 'two) (setf (gethash 'third-key *my-hash*) nil) (setf (gethash nil *my-hash*) 'nil-value) (defun print-hash-entry (key value) (format t \"The value associated with the key ~S is ~S~%\" key value)) (maphash #'print-hash-entry *my-hash*) ;; =\u003e The value associated with the key FIRST-KEY is ONE ;; =\u003e The value associated with the key SECOND-KEY is TWO ;; =\u003e The value associated with the key THIRD-KEY is NIL ;; =\u003e The value associated with the key NIL is NIL-VALUE 使用with-hash-table-iterator with-hash-table-iterator 是一个宏 他会为hash-table 创建迭代器，每次迭代会返回三个返回值 第一个返回值返回是否有这个entry 第二个返回值返回key 第三个返回值返回value 如果遍历到了最后，只会返回一个nil (with-hash-table-iterator (my-iterator my-hash) (loop (multiple-value-bind (entry-p key value) (my-iterator) (if entry-p (print-hash-entry key value) (return))))) ;; =\u003e The value associated with the key FIRST-KEY is ONE ;; =\u003e The value associated with the key SECOND-KEY is TWO ;; =\u003e The value associated with the key THIRD-KEY is NIL ;; =\u003e The value associated with the key NIL is NIL-VALUE ;; =\u003e NIL 遍历keys 或者 values 如果只想遍历keys 或者 values 可以使用Alexandria的maphash-keys 和 maphash-values ","date":"2022-10-04","objectID":"/data_structure/:4:7","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"计算hash table 中的entry 数量 可以使用hash-table-count (defparameter *my-hash* (make-hash-table)) (hash-table-count *my-hash*) ;; =\u003e 0 (setf (gethash 'first *my-hash*) 1) (setf (gethash 'second *my-hash*) 2) (setf (gethash 'third *my-hash*) 3) (hash-table-count *my-hash*) (setf (gethash 'second *my-hash*) 'two) (hash-table-count *my-hash*) ;; =\u003e 3 (clrhash *my-hash*) (hash-table-count *my-hash*) ","date":"2022-10-04","objectID":"/data_structure/:4:8","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"线程安全的hash table common lisp 的标准中，hash-table不是线程安全的，但是在SBCL中，我们可以给make-hash-table传一个 :synchronized 参数来构造一个线程安全的hash table (defparameter *my-hash* (make-hash-table :synchronized t)) 但是在修改时，需要使用sb-ext:with-locked-hash-table将操作保护起来 (sb-ext:with-locked-hash-table (my-hash) (setf (gethash :a my-hash) :new-value)) cl-gserver library cl-gserver 实现了一套actors/agent system 可以简化多线程变成的困难 ","date":"2022-10-04","objectID":"/data_structure/:4:9","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Alist (associated list) 一个association list 就是一个存放cons cells 的list (defparameter *my-alist* (list (cons 'foo \"foo\") (cons 'bar \"bar\"))) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) 内部构造就像这样 [o|o]---[o|/] | | | [o|o]---\"bar\" | | | BAR | [o|o]---\"foo\" | FOO ","date":"2022-10-04","objectID":"/data_structure/:5:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"构造 Construct 第一种方法 (setf *my-alist* '((:foo . \"foo\") (:bar . \"bar\"))) 第二种方法是使用pairlis (pairlis '(:foo :bar) '(\"foo\" \"bar\")) ;; =\u003e ((:BAR . \"bar\") (:FOO . \"foo\")) Alist 就是一个list 所以一个key可以绑定多个值 (setf *alist-with-duplicate-keys* '((:a . 1) (:a . 2) (:b . 3) (:a . 4) (:c . 5))) ","date":"2022-10-04","objectID":"/data_structure/:5:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"访问 Access 要获取一个key 我们使用assoc (可以指定 :test 如果key的类型为strings默认用 equal) 它会返回整个cons cell, 所以可以配合cdr 或者second 获取对应的值。Alexandria 还提供了assoc-value list key 这个函数更加的方便 (alexandria:assoc-value my-alist :foo) ;; =\u003e :foo , (:foo . \"foo\") assoc-if(predicate alist) 找到第一个满足predicate的cons cell (setf alist '((1 . :a) (2 . :b) (3 . :c))) (assoc-if #'evenp alist) rassoc 按值查找 (setf alist '((1 . :a) (2 . :b) (4 . :d) )) (rassoc :a alist) ;; =\u003e (1 . :a) 去重 使用remove-if-not 这个函数的作用是返回一个只包含不满足predicate的列表 (remove-if-not #'(lambda (entry) (eq :a entry)) alist-with-duplicate-keys :key #'car) ","date":"2022-10-04","objectID":"/data_structure/:5:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"插入和删除 push 插入一个entry (push (cons 'team \"team\") my-alist) ;; =\u003e ((TEAM . \"team\") (FOO . \"foo\") (BAR . \"bar\")) 删除remove pop 等 remove 需要指定key 关键字 告诉remove 怎么读取entry (remove 'team my-alist) ;; =\u003e ((TEAM . \"team\") (FOO . \"foo\") (BAR . \"bar\")) ;; didn't remove anything (remove 'team my-alist :key 'car) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) ;; returns a copy ","date":"2022-10-04","objectID":"/data_structure/:5:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"更新entries replace a value *my-alist* ;; =\u003e '((:FOO . \"foo\") (:BAR . \"bar\")) (assoc :foo *my-alist*) ;; =\u003e (:FOO . \"foo\") (setf (cdr (assoc :foo *my-alist*)) \"new-value\") ;; =\u003e \"new-value\" *my-alist* ;; =\u003e '((:foo . \"new-value\") (:BAR . \"bar\")) replace a key *my-alist* ;; =\u003e '((:FOO . \"foo\") (:BAR . \"bar\"))) (setf (car (assoc :bar *my-alist*)) :new-key) ;; =\u003e :NEW-KEY *my-alist* ;; =\u003e '((:FOO . \"foo\") (:NEW-KEY . \"bar\"))) ","date":"2022-10-04","objectID":"/data_structure/:5:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Plist (property list) plist 是一个简单地list 内部又 key ,value 交错组成。他的key是一个symbol (defparameter my-plist (list 'foo \"foo\" 'bar \"bar\")) 底层结构就像这样 [o|o]---[o|o]---[o|o]---[o|/] | | | | FOO \"foo\" BAR \"bar\" 我们可以使用getf (list elt)来获取一个元素（返回value） (defparameter my-plist (list 'foo \"foo\" 'bar \"bar\")) ;; =\u003e (FOO \"foo\" BAR \"bar\") (setf (getf my-plist 'foo) \"foo!!!\") ;; =\u003e \"foo!!!\" remf 用来删除一个元素 (remf my-plist 'foo) ;; =\u003e (BAR \"bar\") ","date":"2022-10-04","objectID":"/data_structure/:6:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Structures 结构体 structures 可以将数据存储在具名的slots中，并且支持单继承。 CLOS (Common Lisp Object System)提供一个更灵活的Classes. 但是structures 可以提供更好的性能 ","date":"2022-10-04","objectID":"/data_structure/:7:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"定义 使用defstruct (defstruct person id name age) 在创建时 slots 默认值为nil 要想自定义默认值 (defstruct person id (name \"john doe\") age) 也可以指定默认类型 (defstruct person id (name \"john doe\" :type string) age) ","date":"2022-10-04","objectID":"/data_structure/:7:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"创建 使用make-\u003cstructure-name\u003e, 对于上面的person 使用make-person (defparameter me (make-person)) ;; =\u003e ME me ;;=\u003e #S(PERSON :ID NIL :NAME \"john doe\" :AGE NIL) 也可以使用关键字指定参数值 (defparameter me (make-person :name 123)) 还可以自定义构造函数，但是一旦自定义了构造函数，那么默认构造函数就将不发再被使用 (defstruct (person (:constructor create-person (id name age))) id name age) ","date":"2022-10-04","objectID":"/data_structure/:7:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"访问slot的值 structure被定义后，会自动定义 \u003cname-of-the-struct\u003e-+slot-name这样的函数 (person-name me) ","date":"2022-10-04","objectID":"/data_structure/:7:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"设置slot的值 使用setf来设置值 (setf (person-name me) \"Cookbook author\") ","date":"2022-10-04","objectID":"/data_structure/:7:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"判断类型 就像默认构造，默认也会生成断言函数来判断类型 (person-p me) ","date":"2022-10-04","objectID":"/data_structure/:7:5","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"限制 在定义改变后，实例并不会更新 (defstruct person id (name \"john doe\" :type string) email) attempt to redefine the STRUCTURE-OBJECT class PERSON incompatibly with the current definition [Condition of type SIMPLE-ERROR] Restarts: 0: [CONTINUE] Use the new definition of PERSON, invalidating already-loaded code and instances. 1: [RECKLESSLY-CONTINUE] Use the new definition of PERSON as if it were compatible, allowing old accessors to use new instances and allowing new accessors to use old instances. 2: [CLOBBER-IT] (deprecated synonym for RECKLESSLY-CONTINUE) 3: [RETRY] Retry SLIME REPL evaluation request. 4: [*ABORT] Return to SLIME's top level. 5: [ABORT] abort thread (#\u003cTHREAD \"repl-thread\" RUNNING {1002A0FFA3}\u003e) CLOS CLOS是没有这种限制的 后面会介绍到 ","date":"2022-10-04","objectID":"/data_structure/:7:6","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Tree tree-equal,copy-tree. 会自顶向下递归进入cons cell 的car 和 cdr ","date":"2022-10-04","objectID":"/data_structure/:8:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Sycamore purely functional weight-balanced binary trees https://github.com/ndantam/sycamore Features: Fast, purely functional weight-balanced binary trees. Leaf nodes are simple-vectors, greatly reducing tree height. Interfaces for tree Sets and Maps (dictionaries). Ropes Purely functional pairing heaps Purely functional amortized queue. ","date":"2022-10-04","objectID":"/data_structure/:8:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"控制打印多少数据 \\*print-length\\*, \\*print-level\\*) print-length 和 print-level默认都为nil 默认，如果你有一个非常长的list, 那么在REPL中打印就会非常的长。使用print-length 控制打印元素的最大数量 (setf *print-length* 2) (list :A :B :C :D :E) ;; (:A :B ...) print-level用来控制打印的深度 (let ((*print-level* 2)) (print '(:a (:b (:c (:d :e)))))) ;; (:A (:B #)) \u003c= *print-level* in action ;; (:A (:B (:C (:D :E)))) \u003c= the list is returned, the let binding is not in effect anymore. ","date":"2022-10-04","objectID":"/data_structure/:9:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"common lisp I/O 操作","date":"2022-10-04","objectID":"/input_output/","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"流 和很多流行的语言一样，流用来控制数据的读取和写入。 输入的缺省是*standard-input*,输出的缺省是*standard-output*,这两个是标准的输入输出流。 ","date":"2022-10-04","objectID":"/input_output/:1:0","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"pathname pathname 指定了一个文件的可以直接方式，路径包含：host、device、directory、name、type和version。make-pathname 函数专门用来构造一个pathname。 (setf path (make-pathname :name \"myfile\")) ;; #P\"myfile ","date":"2022-10-04","objectID":"/input_output/:1:1","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"open 开启文件的最基本的函数时open, 需要一个pathname, 和一些选择性的关键字参数。开启成功后，会创建一个文件的流。 参数 :direction 用来控制流的方向可以 指定 :input 表示只输入, :output 表示只输出, :io 表示既可以输入也可以输出。 参数 :if-exists 说明当文件已经存在时该怎么做；通常与:supersede配合使用表示如果存在就取代它 (setf str (open path :direction :output :if-exists :supersede)) ;; \u003cStream C017E6\u003e ","date":"2022-10-04","objectID":"/input_output/:1:2","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"对流进行操作 输出 打开一个可以输出的文件 (setf str (open path :direction :output :if-exists :supersede)) 最简单的，我们可以使用format 函数将内容输出到流中 (format str \"Something~%\") ;; NIL 此时文件中可能有Something这个内容。也可能没有。因为流并不会马上将内容写入文件。我们可以直接close 这样内容就会立刻进入文件中。 (close str) ;; NIL warning 输出完后，记得关闭文件。因为流不保证写入流的内容会立刻保存到文件中 输入 打开一个可以输入的文件 (setf str (open path :direction :input)) 可以使用read-line 读取一行文字 with-open-file 大部分时间，我们不使用open和close来操作文件的I/O。with-open-file宏更方便。第一个参数是一个列表(stream-value， path ,parameters-to-open-func), 第二个参数是要执行的代码主题。当代码主体执行完毕后，这个流就会被自动关闭，所以操作自然被保存在文件中。 (with-open-file (str path :direction :output :if-exists :supersede) (format str \"Something~%\")) ","date":"2022-10-04","objectID":"/input_output/:1:3","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"流的输入函数 流的输入有两个常用函数read-line和read. read-line read-line 读取一行，并用字符串返回。默认从标准输入中读取 (progn (format t \"Please enter you name: \") (read-line)) read-line接受4个可选参数 (read-line stream errp 'return-value-if-errp-is-nil) 这里errp 表示在遇到end-of-file时是否产生错误 return-value-if-errp-is-nil表示若errp为nil应该返回什么 (defun pseudo-cat (file) (with-open-file (str file :direction :input) (do ((line (read-line str nil 'eof) (read-line str nil 'eof))) ((eql line 'eof)) (format t \"~A~%\" line)))) read 如果想把read解析成lisp对象 使用read. read一次读取一个表达式。在表达式结束时停止读取。读取的内容必须是合法的Lisp语法。 ","date":"2022-10-04","objectID":"/input_output/:2:0","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"流的输出函数 流有三个最基本的输出函数prin1, princ, terpri prin1和 princ 的差别在于prin1 给程序产生输出，而princ 给人类产生输出。也就是说prin1产生的输出是程序可读的，而princ 产生的输出更接近人的读取直觉。 (prin1 \"Hello\") ;; \"Heool\" (princ \"Hello\") ;; Hello terpri只会打印出一个新行 format format类似c语言的printf 和其他语言中的格式化输出函数。format主要的复杂在于格式化控制，可以在使用的时候查阅文档，这里就不赘述了。 ","date":"2022-10-04","objectID":"/input_output/:3:0","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"宏字符(Macro Characters) 宏字符是获得read特别待遇的字符，一个宏字符或者宏字符组合也叫做read-macro(读取宏)。Common Lisp预定义的读取宏很多都是缩写。比如quote的读取宏是’ ‘a 会被展开成 (quote a) ","date":"2022-10-04","objectID":"/input_output/:4:0","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"dispatching 派发读取宏都已#作为派发字符，比如#‘是(function …)的缩写，同样 ‘是 (quote …)的缩写。#(…)产生一个vector, #nA(…)产生数组；#\\产生一个字符; #S(n …)产生一个结构。 ","date":"2022-10-04","objectID":"/input_output/:4:1","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"  \"Common Lisp Object System使用\"\n  ","date":"2022-10-04","objectID":"/fundamental_clos/","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"CLOS is the “Common Lisp Object System”, arguably one of the most powerful object systems available in any language. Some of its features include: it is dynamic, making it a joy to work with in a Lisp REPL. For example, changing a class definition will update the existing objects, given certain rules which we have control upon. it supports multiple dispatch and multiple inheritance, it is different from most object systems in that class and method definitions are not tied together, it has excellent introspection capabilities, it is provided by a meta-object protocol, which provides a standard interface to the CLOS, and can be used to create new object systems. The functionality belonging to this name was added to the Common Lisp language between the publication of Steele’s first edition of “Common Lisp, the Language” in 1984 and the formalization of the language as an ANSI standard ten years later. This page aims to give a good understanding of how to use CLOS, but only a brief introduction to the MOP. To learn the subjects in depth, you will need two books: Object-Oriented Programming in Common Lisp: a Programmer`s Guide to CLOS the Art of the Metaobject Protocol ","date":"2022-10-04","objectID":"/fundamental_clos/:0:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Classes and instances 先来个简单的例子 包含class的定义，对象的创建，slot的访问，methods的指定，以及继承 (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper))) ;; =\u003e #\u003cSTANDARD-CLASS PERSON\u003e (defvar p1 (make-instance 'person :name \"me\" )) ;; ^^^^ initarg ;; =\u003e #\u003cPERSON {1006234593}\u003e (name p1) ;;^^^ accessor ;; =\u003e \"me\" (lisper p1) ;; =\u003e nil ;; ^^ initform (slot unbound by default) (setf (lisper p1) t) (defclass child (person) ()) (defclass child (person) ((can-walk-p :accessor can-walk-p :initform t))) ;; #\u003cSTANDARD-CLASS CHILD\u003e (can-walk-p (make-instance 'child)) ;; T ","date":"2022-10-04","objectID":"/fundamental_clos/:1:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Defining classes (defclass) CLOS中定义一个新的数据类型使用defclass macro (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper))) 这样我们就得到了一个CLOS 类型（class）叫做person,person 有两个slot 一个叫做name 一个叫做lisper。 (class-of p1) #\u003cSTANDARD-CLASS PERSON\u003e (type-of p1) PERSON defclass 的通用形式 (defclass \u003cclass-name\u003e (list of super classes) ((slot-1 :slot-option slot-argument) (slot-2,etc)) (:optional-class-option :another-optional-class-option)) 所以person class 并没有显式的继承任何class. 但是他默认继承了standard-object. 我们也可以写一个非常小的class 不用slot options (defclass point () (x y z)) 甚至都不需要slot (defclass point()()) ","date":"2022-10-04","objectID":"/fundamental_clos/:2:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"创建对象(make-instance) (defvar p1 (make-instance 'person :name \"me\")) 更实用的方法是定义构造函数 (defun make-person (name \u0026key lisper) (make-instance 'person :name name :lisper lisper)) ","date":"2022-10-04","objectID":"/fundamental_clos/:3:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Slots ","date":"2022-10-04","objectID":"/fundamental_clos/:4:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"A function that always works(slot-value) 在任何时候都可以用来用来访问slot的函数时 (slot-value \u003cobject\u003e \u003cslot-name\u003e) (defvar pt (make-instance 'point)) (inspect pt) The object is a STANDARD-OBJECT of type POINT. 0. X: \"unbound\" 1. Y: \"unbound\" 2. Z: \"unbound\" 这样你可以获得一个point对象，但是他的slots 默认是没有绑定的，尝试访问他们会导致UNBOUND-SLOT condition (slot-value pt 'x) ;; =\u003e condition: the slot is unbound slot-value 是可以被setf 的 (setf (slot-value pt 'x) 1) (slot-value pt 'x) ;; =\u003e 1 ","date":"2022-10-04","objectID":"/fundamental_clos/:4:1","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"初始化和默认值(initarg,initform) :initarg :foo 是用来传给make-instance 让make-instance 给slot 设置值的关键字 (make-instance 'person :name \"me\") :initform \u003cval\u003e 是当我们没有显式指定initarg时，设置的默认值。在defclass的词法作用域中 (defclass foo () ((a :initarg :a :initform (error \"you didn`t supply an initial value for slot a\")))) (make-instance 'foo) ;; =\u003e enters the debugger ","date":"2022-10-04","objectID":"/fundamental_clos/:4:2","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Getters and Setters (accessor,reader,writer) :accessor foo: accessor 既是getter 也是 setter. (name p1) ;; =\u003e \"me\" (type-of #'name) STANDARD-GENERIC-FUNCTION reader and writer 就是他们描述的功能，只有:writer是setf-able的 如果你不指定他们，你仍然可以使用slot-value 呢可以指定不止一个:accessor,:reader 或者 :initarg 这里介绍两个macros 让访问slot更加简洁 with-slots 可以一次访问多个slot-value (with-slots (name lisper) c1 (format t \"got ~a, ~a~\u0026\" name lisper)) or (with-slots ((n name) (l lisper)) c1 (format t \"got ~a, ~a~\u0026\" n l)) with-accessor 也差不多，但是使用的accessor (with-accessors ((name name) (lisper lisper)) p1 (format t \"name: ~a, lisper: ~a\" name lisper)) ","date":"2022-10-04","objectID":"/fundamental_clos/:4:3","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Class VS instance slots :allocation 用来说明这个slot是local的还是shared local slot 是默认的，也就是说，实例之间是不共享的 这时:allocation == :instance shared slot 在实例间是共享的，我们可以用:allocation :class 来设置 在下面的例子中，注意 p2的species槽的值是如何变化的，以及是如何影响所有class的instance的 (defclass person () ((name :initarg :name :accessor name) (species :initform 'homo-sapiens :accessor species :allocation :class))) ;; Note that the slot \"lisper\" was removed in existing instances. (inspect p1) ;; The object is a STANDARD-OBJECT of type PERSON. ;; 0. NAME: \"me\" ;; 1. SPECIES: HOMO-SAPIENS ;; \u003e q (defvar p2 (make-instance 'person)) (species p1) (species p2) ;; HOMO-SAPIENS (setf (species p2) 'homo-numericus) ;; HOMO-NUMERICUS (species p1) ;; HOMO-NUMERICUS (species (make-instance 'person)) ;; HOMO-NUMERICUS (let ((temp (make-instance 'person))) (setf (species temp) 'homo-lisper)) ;; HOMO-LISPER (species (make-instance 'person)) ;; HOMO-LISPER ","date":"2022-10-04","objectID":"/fundamental_clos/:4:4","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Slot documentation 任何slot 都可以接受一个:documentation option ","date":"2022-10-04","objectID":"/fundamental_clos/:4:5","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Slot type :type 用来检查slot的类型，但是只有很少一部分的实现支持:type 类型检查 ","date":"2022-10-04","objectID":"/fundamental_clos/:4:6","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"find-class,class-name,class-of (find-class 'point) ;; #\u003cSTANDARD-CLASS POINT 275B78DC\u003e (class-name (find-class 'point)) ;; POINT (class-of my-point) ;; #\u003cSTANDARD-CLASS POINT 275B78DC\u003e (typep my-point (class-of my-point)) ;; T ","date":"2022-10-04","objectID":"/fundamental_clos/:5:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Subclasses 和 inheritance child 是 person 的子类, 所有object 都继承自standard-object and t. 所有child instance 也是 person 的 instance (type-of cl) ;; child (subtypep (type of cl) 'person) ;; T (ql:quickload \"closer-mop\") ;; ... (closer-mop:subclassp (class-of cl) 'person) 一个subclass 继承了他所有的 parents` 的slots, 并且，他可以覆盖父类们的任何slot options. child class的优先级是这样的 child \u003c- person \u003c-- standard-object \u003c- t 我们可以用closer-mop:class-precedence-list 去查看 (closer-mop:class-precedence-list (class-of c1)) ;; (#\u003cstandard-class child\u003e ;; #\u003cstandard-class person\u003e ;; #\u003cstandard-class standard-object\u003e ;; #\u003csb-pcl::slot-class sb-pcl::slot-object\u003e ;; #\u003csb-pcl:system-class t\u003e) 但是child的直接父类只是 (closer-mop:class-direct-superclasses (class-of c1)) ;; (#\u003cstandard-class person\u003e) 我们还可以用更多的方法来inspect classes,比如class-direct-[subclasses, slots, default-initargs] slots 以如下方式结合 :accessor and :reader are combined by the union of accessors and readers from all the inherited slots. :initarg: the union of initialization arguments from all the inherited slots. :initform: we get the most specific default initial value form, i.e. the first :initform for that slot in the precedence list. :allocation is not inherited. It is controlled solely by the class being defined and defaults to :instance. ","date":"2022-10-04","objectID":"/fundamental_clos/:6:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Multiple inheritance (defclass baby (child person) ()) 现代语言不提倡多重继承 ","date":"2022-10-04","objectID":"/fundamental_clos/:7:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Redefining and changing a class 这一节简短的包含两个话题 重定义已经存在的class 改变已经一个class 的instance 要重定义一个class,只需要在执行榆次defclass, 他会替换所有的旧的定义，包括实例，继承。 (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper))) (setf pl (make-instance 'person :name \"me\")) changing,adding,removing slots… (lisper p1) ;; NIL (defclass person () ((name :initarg :name :accessor name) (lisper :initform t ;; \u003c-- from nil to t :accessor lisper))) (lisper p1) ;; NIL (of course!) (lisper (make-instance 'person :name \"You\")) ;; T (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper) (age ;; \u003c-- new slot :initarg :arg :initform 18 ;; \u003c-- default value :accessor age))) (age p1) ;; =\u003e 18. Correct. This is the default initform for this new slot. (slot-value p1 'bwarf) ;; =\u003e \"the slot bwarf is missing from the object #\u003cperson…\u003e\" (setf (age p1) 30) (age p1) ;; =\u003e 30 (defclass person () ((name :initarg :name :accessor name))) (slot-value p1 'lisper) ;; =\u003e slot lisper is missing. (lisper p1) ;; =\u003e there is no applicable method for the generic function lisper when called with arguments #(lisper). 要改变一个实例的class, 可以使用change-class: (change-class p1 'child) ;; we can also set slots of the new class: (change p1 'child :can-walk-p nil) (class-of p1) ;; #\u003cSTANDARD-CLASS CHILD\u003e (can-walk-p p1) ;; T ","date":"2022-10-04","objectID":"/fundamental_clos/:8:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Pretty printing 每次我们打印一个object 我们会获得一个这样的输出 #\u003cPERSON {1006234593}\u003e 如果想要更多的信息，比如 #\u003cPERSON me lisper: t\u003e 要想更加好看的打印可以指定 class 的 generic print-object 方法 (defmethod print-object ((obj person) stream) (print-unreadable-object (obj stream :type t) (with-accessors ((name name) (lisper lisper)) obj (format stream \"~a, lisper: ~a\" name lisper)))) p1 ;; #\u003cPERSON me, lisper: T\u003e print-unreadable-object 打印#\u003c…\u003e, 这表明 object 的reader无法再深入的读取. :type t 参数要求答应object-type的前缀，也就是 PERSON. 没有它我们会得到 #\u003cme,lisper: T\u003e 我们使用了with-accessors macro,但是对于简单的情况这样做就可以了的 (defmethod print-object ((obj person) stream) (print-unreadable-object (obj stream :type t) (format stream \"~a, lisper: ~a\" (name obj) (lisper obj)))) warning 尝试访问一个没有被绑定的slot会导致错误，所以应该先使用slot-boundp判断 下面的代码重现了默认的打印方式 (defmethod print-object ((obj person) stream) (print-unreadable-object (obj stream :type t :identity t))) 这里:identity为t时将会打印地址 ","date":"2022-10-04","objectID":"/fundamental_clos/:9:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Classes of traditional lisp types 这节不是很明白贴出原文地址吧 Classes of traditional lisp types ","date":"2022-10-04","objectID":"/fundamental_clos/:10:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Introspection 其实Introspection就是各种判断CLOS instance内部结构的断言函数，如果你需要非常了解这些函数的话推荐去看看closer-mop 库和CLOS \u0026 MOP specifications 这里列出一些函数 closer-mop:class-default-initargs closer-mop:class-direct-default-initargs closer-mop:class-direct-slots closer-mop:class-direct-subclasses closer-mop:class-direct-superclasses closer-mop:class-precedence-list closer-mop:class-slots closer-mop:classp closer-mop:extract-lambda-list closer-mop:extract-specializer-names closer-mop:generic-function-argument-precedence-order closer-mop:generic-function-declarations closer-mop:generic-function-lambda-list closer-mop:generic-function-method-class closer-mop:generic-function-method-combination closer-mop:generic-function-methods closer-mop:generic-function-name closer-mop:method-combination closer-mop:method-function closer-mop:method-generic-function closer-mop:method-lambda-list closer-mop:method-specializers closer-mop:slot-definition closer-mop:slot-definition-allocation closer-mop:slot-definition-initargs closer-mop:slot-definition-initform closer-mop:slot-definition-initfunction closer-mop:slot-definition-location closer-mop:slot-definition-name closer-mop:slot-definition-readers closer-mop:slot-definition-type closer-mop:slot-definition-writers closer-mop:specializer-direct-generic-functions closer-mop:specializer-direct-methods closer-mop:standard-accessor-method ","date":"2022-10-04","objectID":"/fundamental_clos/:11:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"See also ","date":"2022-10-04","objectID":"/fundamental_clos/:12:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"defclass/std: write shorter classes defclass/std 提供了一个简写defclass的macro 默认他会提供一个initarg 和一个绑定为nil的initform 给你的slot定义 比如 (defclass/std example() ((slot1 slot2 slot3))) 会被展开为 (defclass example() ((slot1 :accessor slot1 :initarg :slot1 :initform nil) (slot2 :accessor slot2 :initarg :slot2 :initform nil) (slot3 :accessor slot3 :initarg :slot3 :initform nil))) 他很方便灵活，但是common lisp 社区很少使用他，你可以自行决定是否使用他 ","date":"2022-10-04","objectID":"/fundamental_clos/:12:1","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Methods ","date":"2022-10-04","objectID":"/fundamental_clos/:13:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"先来个潜入 之前有过person 和 child 类的定义 (defclass person() ((name :initarg :name :accessor name))) (defclass child (person) ()) (setf p1 (make-instance 'person :name \"me\")) (setf p2 (make-instance 'child :name \"Alice\")) (defmethod greet (obj) (format t \"Are you a person ? You are a ~a.~\u0026\" (type-of obj))) ;; style-warning: Implicitly creating new generic function common-lisp-user::greet. ;; #\u003cSTANDARD-METHOD GREET (t) {1008EE4603}\u003e (greet :anything) ;; Are you a person ? You are a KEYWORD. ;; NIL (greet p1) ;; Are you a person ? You are a PERSON. (defgeneric greet (obj) (:documentation \"say hello\")) ;; STYLE-WARNING: redefining COMMON-LISP-USER::GREET in DEFGENERIC ;; #\u003cSTANDARD-GENERIC-FUNCTION GREET (2)\u003e (defmethod greet ((obj person)) (format t \"Hello ~a !~\u0026\" (name obj))) ;; #\u003cSTANDARD-METHOD GREET (PERSON) {1007C26743}\u003e (greet p1) ;; =\u003e \"Hello me !\" (greet c1) ;; =\u003e \"Hello Alice !\" (defmethod greet ((obj child)) (format t \"ur so cute~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET (CHILD) {1008F3C1C3}\u003e (greet p1) ;; =\u003e \"Hello me !\" (greet c1) ;; =\u003e \"ur so cute\" ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; Method combination: before, after, around. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (defmethod greet :before ((obj person)) (format t \"-- before person~\u0026\")) #\u003cSTANDARD-METHOD GREET :BEFORE (PERSON) {100C94A013}\u003e (greet p1) ;; -- before person ;; Hello me (defmethod greet :before ((obj child)) (format t \"-- before child~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :BEFORE (CHILD) {100AD32A43}\u003e (greet c1) ;; -- before child ;; -- before person ;; ur so cute (defmethod greet :after ((obj person)) (format t \"-- after person~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :AFTER (PERSON) {100CA2E1A3}\u003e (greet p1) ;; -- before person ;; Hello me ;; -- after person (defmethod greet :after ((obj child)) (format t \"-- after child~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :AFTER (CHILD) {10075B71F3}\u003e (greet c1) ;; -- before child ;; -- before person ;; ur so cute ;; -- after person ;; -- after child (defmethod greet :around ((obj child)) (format t \"Hello my dear~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :AROUND (CHILD) {10076658E3}\u003e (greet c1) ;; Hello my dear ;; call-next-method (defmethod greet :around ((obj child)) (format t \"Hello my dear~\u0026\") (when (next-method-p) (call-next-method))) ;; #\u003cstandard-method greet :around (child) {100AF76863}\u003e (greet c1) ;; Hello my dear ;; -- before child ;; -- before person ;; ur so cute ;; -- after person ;; -- after child ;;;;;;;;;;;;;;;;; ;; Adding in \u0026key ;;;;;;;;;;;;;;;;; ;; In order to add \"\u0026key\" to our generic method, we need to remove its definition first. (fmakunbound 'greet) ;; with Slime: C-c C-u (slime-undefine-function) (defmethod greet ((obj person) \u0026key talkative) (format t \"Hello ~a~\u0026\" (name obj)) (when talkative (format t \"blah\"))) (defgeneric greet (obj \u0026key \u0026allow-other-keys) (:documentation \"say hi\")) (defmethod greet (obj \u0026key \u0026allow-other-keys) (format t \"Are you a person ? You are a ~a.~\u0026\" (type-of obj))) (defmethod greet ((obj person) \u0026key talkative \u0026allow-other-keys) (format t \"Hello ~a !~\u0026\" (name obj)) (when talkative (format t \"blah\"))) (greet p1 :talkative t) ;; ok (greet p1 :foo t) ;; still ok ;;;;;;;;;;;;;;;;;;;;;;; (defgeneric greet (obj) (:documentation \"say hello\") (:method (obj) (format t \"Are you a person ? You are a ~a~\u0026.\" (type-of obj))) (:method ((obj person)) (format t \"Hello ~a !~\u0026\" (name obj))) (:method ((obj child)) (format t \"ur so cute~\u0026\"))) ;;;;;;;;;;;;;;;; ;;; Specializers ;;;;;;;;;;;;;;;; (defgeneric feed (obj meal-type) (:method (obj meal-type) (declare (ignorable meal-type)) (format t \"eating~\u0026\"))) (defmethod feed (obj (meal-type (eql :dessert))) (declare (ignorable meal-type)) (format t \"mmh, dessert !~\u0026\")) (feed c1 :dessert) ;; mmh, dessert ! (defmethod feed ((obj child) (meal-type (eql :soup))) (declare (ignorable meal-type)) (format t \"bwark~\u0026\")) (feed p1 :soup) ;; eating (feed c1 :soup) ;; bwark ","date":"2022-10-04","objectID":"/fundamental_clos/:13:1","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Generic functions (defgeneric,defmethod) 在lisp方法中 generic function 是一个相关联的方法集合。所有同名的方法都属于同一个generic function defmethod 和 defun 很相似。他将函数名和函数体相关联，但是函数体只有当参数的类型和lambda list定义的类型相匹配时才会被执行。 他们可以有optional,keyword 和 \u0026rest参数 lambda list lambda list 其实就是参数列表 defgeneric 用来定义generic function, 如果我们使用defmethod 的时候没有对应的defgeneric时，一个generic function就会被自动创建 使用defgenerics 是一个好习惯，我们可以添加默认的实现，甚至是documentation (defgeneric greet (obj) (:documentation \"says hi\") (:method (obj) (format t \"Hi\"))) 一个方法的lambda list 所需要的参数可能有三种形式 a simple variable: (defmethod greet (foo) ...) 这个method 可以接受任何的参数 一个variable 和一个specializer (defmethod greet ((foo person)) ...) 在这种情况下，foo 被绑定只有特定的class 比如person 和其 subclass才能使用这个方法 如果参数与specializer不匹配，那么就会报错 对于optional \u0026key 参数我们不能使用specialize a variable 和一个eql specializer (defmethod feed ((obj child) (meal-type (eql :soup))) (declare (ignorable meal-type)) (format t \"bwark~\u0026\")) (feed cl :soup) ;; \"bwark\" 你可以定义很多同名的函数，只要他们的specializers不同。系统会选择最具体的函数进行调用。通用函数调用的优先级是 参数决定了一个或多个可用方法，如果在调用中的参数和参数的specializers匹配，那么参数可用 如果没有可用方法，就会报错. 如果只有一个，立刻调用 如果多于一个，最具体的会被调用。 最具体可用的方法由传入参数所属类别的优先级决定。由左往右审视参数。如果有一个可用方法的第一个参数，此参数特化给某个类，其类的优先级高于其它可用方法的第一个参数，则此方法就是最具体的可用方法。平手时比较第二个参数，以此类推。 notes It is an error to define a method with the same function name as an ordinary function. If you really want to do that, use the shadowing mechanism. To add or remove keys or rest arguments to an existing generic method’s lambda list, you will need to delete its declaration with fmakunbound (or C-c C-u (slime-undefine-function) with the cursor on the function in Slime) and start again. Otherwise, you’ll see: Methods can be redefined (exactly as for ordinary functions). The order in which methods are defined is irrelevant, although any classes on which they specialize must already exist. An unspecialized argument is more or less equivalent to being specialized on the class t. The only difference is that all specialized arguments are implicitly taken to be “referred to” (in the sense of declare ignore.) Each defmethod form generates (and returns) a CLOS instance, of class standard-method. An eql specializer won’t work as is with strings. Indeed, strings need equal or equalp to be compared. But, we can assign our string to a variable and use the variable both in the eql specializer and for the function call. All the methods with the same function name belong to the same generic function. All slot accessors and readers defined by defclass are methods. They can override or be overridden by other methods on the same generic function. ","date":"2022-10-04","objectID":"/fundamental_clos/:13:2","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Multimethods mutlimethods 显式的指出，函数的parameters不止一个。而且我们很难确定他到底属于那个class #+begin_src lisp (defgeneric hug (a b) (:documentation “Hug between two persons”)) (defmethod hug ((a person) (b person)) :person-person-hug) (defmethod hug ((a person) (b child)) :person-child-hug) #+end_src ","date":"2022-10-04","objectID":"/fundamental_clos/:14:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"控制setters (setf-ing methods) 在lisp 中，我们可以定义setf counterparts of functions or methods. 我们可能想在如何更新object上 获得更多的控制 (defmethod (setf name) (new-val (obj person)) (if (equalp new-val \"jame bond\") (format t \"Dude that`s not possible.~\u0026\") (setf (slot-value obj 'name) new-val))) (setf (name p1) \"james bond\") ;; -\u003e no rename ","date":"2022-10-04","objectID":"/fundamental_clos/:15:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Dispatch mechanism and next methods 这段不讲了，现代语言用的不多，感觉有点糟粕了。有兴趣自己去看吧 Dispatch mechanism and next methods ","date":"2022-10-04","objectID":"/fundamental_clos/:16:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Method qualifiers (before,after,around) 这个也是牛牛牛，但是我学过的语言都没这个。也是自己去看吧 Method qualifiers ","date":"2022-10-04","objectID":"/fundamental_clos/:17:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Other method combinations 这个更离谱，自己去看 other method combinations ","date":"2022-10-04","objectID":"/fundamental_clos/:18:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"common lisp 的错误和异常处理","date":"2022-10-04","objectID":"/error_and_exception_handlering/","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"这一节后半段需要CLOS的知识, 所以为了不产生疑惑，在读到define-condition的时候先去看看CLOS CLOS ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:0:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"Ignoring all errors, returning nil 有时候你知道函数会失败，并且你想忽略这个错误，可以使用ignore-errors (ignore-errors (/ 3 0)) ; in: IGNORE-ERRORS (/ 3 0) ; (/ 3 0) ; ; caught STYLE-WARNING: ; Lisp error during constant folding: ; arithmetic error DIVISION-BY-ZERO signalled ; Operation was (/ 3 0). ; ; compilation unit finished ; caught 1 STYLE-WARNING condition NIL #\u003cDIVISION-BY-ZERO {1008FF5F13}\u003e 3/0 是一个错误，我们收到了警告。但是函数会正常返回nil，函数执行的状态被返回，失败了。 ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:1:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"Catching any condition (handler-case) ignore-errors是建立在handler-case上的。我们可以通过捕获err重写上面的例子,但是我们可以返回我们想返回的东西 (handler-case (/ 3 0) (error (c) (format t \"We caught a condition.~\u0026\") (values 0 c))) ; in: HANDLER-CASE (/ 3 0) ; (/ 3 0) ; ; caught STYLE-WARNING: ; Lisp error during constant folding: ; Condition DIVISION-BY-ZERO was signalled. ; ; compilation unit finished ; caught 1 STYLE-WARNING condition We caught a condition. 0 #\u003cDIVISION-BY-ZERO {1004846AE3}\u003e 可以看到我们返回了0 和 c handler-case的通用模板是 (handler-case (code that errors out) (condition-type (the-condition) ;; \u003c-- optional argument (code)) (another-condition (the-condition) ...)) 我们也可以用t 来捕获条件 (handler-case (progn (format t \"This won`t work...~%\") (/3 0)) (t (c) (format t \"Got an exception: ~a~%\" c) (values 0 c))) ;; … ;; This won't work… ;; Got an exception: arithmetic error DIVISION-BY-ZERO signalled ;; Operation was (/ 3 0). ;; 0 ;; #\u003cDIVISION-BY-ZERO {100608F0F3}\u003e ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:2:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"捕获一个特殊的条件 我们可以指定哪些条件需要处理 (handler-case (/ 3 0) (division-by-zero (c) (format t \"Caught division by zero: ~a~%\" c))) ;; … ;; Caught division by zero: arithmetic error DIVISION-BY-ZERO signalled ;; Operation was (/ 3 0). ;; NIL 这个和try/catch形式非常像，但是我们可以做更多的事情 ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:3:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"handler-case vs handler-bind handler-case和其他语言的try/catch非常像 handler-bind 用在哪些当错误出现时我们需要绝对控制的情况下。他允许我们交互的使用debugger和编程化的restart, ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:4:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"defining and make conditions 我们可以使用define-condition 定义condtions，使用make-condition 初始化他们 (define-condition my-division-by-zero (error) ()) (make-condition 'my-division-by-zero) ;; #\u003cMY-DIVISION-BY-ZERO {1005A5FE43}\u003e 定义condition时，最好给出更多的信息 (define-condition my-division-by-zero (error) ((dividend :initarg :dividend :initform nil :reader dividend)) ;; \u003c-- we'll get the dividend with (dividend condition). See the CLOS tutorial if needed. (:documentation \"Custom error when we encounter a division by zero.\")) ;; good practice ;) ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:5:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"common lisp 的文件和文件夹操作","date":"2022-10-04","objectID":"/file_and_directory/","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"本节主要介绍UIOP中的一些有关文件和文件操作方面的使用。获取你也应该直接看一看UIOP的官方文档. UIOP 当然，也别忘了 Files and File I/O in Practicial Common Lisp ","date":"2022-10-04","objectID":"/file_and_directory/:0:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"测试文件是否存在 probe-file 专门用来测试文件是否存在。如果返回Nil文件不存在，返回truename则文件存在 truename Many file systems permit more than one filename to designate a particular file. Even where multiple names are possible, most file systems have a convention for generating a canonical filename in such situations. Such a canonical filename (or the pathname representing such a filename) is called a truename. 为了可移植性，可以使用返回pathname的uiop:probe-file* 或者uiop:file-exists-p（如果文件存在的话） $ ln -s /etc/passwd foo (probe-file \"/etc/passwd\") #p\"/etc/passwd\" (probe-file \"foo\") #p\"/etc/passwd\" (probe-file \"bar\") NIL ","date":"2022-10-04","objectID":"/file_and_directory/:1:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"展开~（家目录环境变量） 我们使用uiop:native-namestring: (uiop:native-namestring \"~/.emacs.d/\") 如果文件不存在，他也会被展开 (uiop:native-namestring \"~/foo987.txt\") ;; \"/home/me/foo987.txt\" 在许多lisp实现上(CCL,ABCL,ECL,CLISP,LispWorks),namestring 很像。在 SBCL上，如果文件不存在，或者目录不存在，namestring不会展开path 而是直接返回参数 要测试文件是否存在也可以使用truename,但是在SBCL上，如果文件不存在，会直接返回错误。 ","date":"2022-10-04","objectID":"/file_and_directory/:2:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"创建文件夹 (ensure-directories-exist \"fbbboo/bar/baz/\") 这样会创建fbbboo bar baz 不要忘记在尾部加上斜杠 ","date":"2022-10-04","objectID":"/file_and_directory/:3:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"删除文件夹 uiop:delete-directory-tree 和一个pathname(#p),一个尾部斜杠 和:validate (uiop:delete-directory-tree #p\"dirtest/\" :validate t) 也可以使用pathname 函数创建一个pathname (defun rmdir (path) (uiop:delete-directory-tree (pathname path) :validate t)) uiop 还有一个delete-empty-directory 用来删除空的文件夹 ","date":"2022-10-04","objectID":"/file_and_directory/:4:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"合并文件和文件夹 merge-pathnames 专用来合并路径，如果你想在后面添加一个文件夹，第二个参数必须带上末尾斜杠 (merge-pathnames \"otherpath\" \"/home/vince/projects/\") ;; =\u003e #p\"/home/vince/projects/otherpath\" 这里otherpath被当做文件 (merge-pathnames \"otherpath\" \"/home/vince/projects\") ;; #P\"/home/vince/otherpath\" ;; ^^ no \"projects\", because it was seen as a file. (merge-pathnames \"otherpath/\" \"/home/vince/projects\") ;; #P\"/home/vince/otherpath/projects\" ;; ^^ inserted here ","date":"2022-10-04","objectID":"/file_and_directory/:5:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"获取当前目录(CWD) 使用uiop/os:getcwd: (uiop/os:getcwd) ;; #P\"/home/vince/projects/cl-cookbook/\" ;; ^ with a trailing slash, useful for merge-pathnames ","date":"2022-10-04","objectID":"/file_and_directory/:6:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"获取以lisp工程为根目录的相对路径的绝对路径 使用asdf:system-relative-pathname system path. (asdf:system-relative-pathname \"mysystem\" \"src/web\") ;; =\u003e #P\"/home/vince/projects/mysystem/src/web/\" ","date":"2022-10-04","objectID":"/file_and_directory/:7:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"opening a file 打开文件其实之前有写过，这里不赘述。直接给出cookbook 的连接（主要，我自己已经看过了,不想多写哈哈哈哈） opening a file 也可以去看看我之前写的Input-Output ","date":"2022-10-04","objectID":"/file_and_directory/:8:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"Reading files ","date":"2022-10-04","objectID":"/file_and_directory/:9:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"将文件读入string 或 行list中 read-file-string (uiop:read-file-string \"file.txt\") read-file-lines (uiop:read-file-lines \"file.txt\") ","date":"2022-10-04","objectID":"/file_and_directory/:9:1","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"read-line or read-char 这两个函数的性能不高，可以加入缓冲区解决这个问题 (with-output-to-string (out) (with-open-file (in \"/path/to/big/file\") (loop with buffer = (make-array 8192 :element-type 'character) for n-characters = (read-sequence buffer in) while (\u003c 0 n-characters) do (write-sequence buffer out :start 0 :end n-characters)))) ","date":"2022-10-04","objectID":"/file_and_directory/:9:2","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"以utf-8的格式读取 (with-open-file (in \"/path/to/big/file\" :external-format :utf-8) ) ","date":"2022-10-04","objectID":"/file_and_directory/:9:3","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"将SBCL的默认字符集设为utf-8 在~/.sbclrc中加入 (setf sb-impl::*default-external-format* :utf-8) 或者 (setf sb-alien::*default-c-string-external-format* :utf-8) ","date":"2022-10-04","objectID":"/file_and_directory/:9:4","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"向文件中写入内容 (with-open-file (f \u003cpathname\u003e :direction :output :if-exists :supersede :if-does-not-exist :create) (write-sequence s f)) 如果文件存在，你也可以使用:append 来追加内容 使用库 Alexandria 有一个函数叫write-string-into-file (alexandria:write-string-into-file content \"file.txt\") ","date":"2022-10-04","objectID":"/file_and_directory/:9:5","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"获取文件后缀 (pathname-type \"~/foo.org\") ;; =\u003e \"org\" ","date":"2022-10-04","objectID":"/file_and_directory/:10:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"获取文件属性(size,access time,….) Osicat(in quicklisp)是一个轻量级操作系统接口。使用Osicat 可以获取环境变量，操作files directories pathnames (ql:quickload \"osicat\") (let ((stat (osicat-posix:stat #P\"./files.md\"))) (osicat-posix:stat-size stat)) ;; =\u003e 10629 可以使用以下函数获取更多的属性 osicat-posix:stat-dev osicat-posix:stat-gid osicat-posix:stat-ino osicat-posix:stat-uid osicat-posix:stat-mode osicat-posix:stat-rdev osicat-posix:stat-size osicat-posix:stat-atime osicat-posix:stat-ctime osicat-posix:stat-mtime osicat-posix:stat-nlink osicat-posix:stat-blocks osicat-posix:stat-blksize ","date":"2022-10-04","objectID":"/file_and_directory/:11:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"列出所有的文件和文件夹 有些函数可以返回pathnames (namestring #p\"/foo/bar/baz.txt\") ==\u003e \"/foo/bar/baz.txt\" (directory-namestring #p\"/foo/bar/baz.txt\") ==\u003e \"/foo/bar/\" (file-namestring #p\"/foo/bar/baz.txt\") ==\u003e \"baz.txt\" ","date":"2022-10-04","objectID":"/file_and_directory/:12:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"返回文件夹中的文件(不包括文件夹) (uiop:directory-files \"./\") 返回一连串的pathnames: (#P\"/home/vince/projects/cl-cookbook/.emacs\" #P\"/home/vince/projects/cl-cookbook/.gitignore\" #P\"/home/vince/projects/cl-cookbook/AppendixA.jpg\" #P\"/home/vince/projects/cl-cookbook/AppendixB.jpg\" #P\"/home/vince/projects/cl-cookbook/AppendixC.jpg\" #P\"/home/vince/projects/cl-cookbook/CHANGELOG\" #P\"/home/vince/projects/cl-cookbook/CONTRIBUTING.md\" […] ","date":"2022-10-04","objectID":"/file_and_directory/:12:1","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"返回所有的子文件夹 (uiop:subdirectories \"/Users/qibinyang/test\") (#P\"/Users/qibinyang/test/assertTest/\" #P\"/Users/qibinyang/test/center/\" #P\"/Users/qibinyang/test/client1/\" #P\"/Users/qibinyang/test/client2/\" #P\"/Users/qibinyang/test/test/\") ","date":"2022-10-04","objectID":"/file_and_directory/:12:2","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"}]