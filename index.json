[{"categories":["lisp"],"content":"common lisp 中的 macros","date":"2022-05-01","objectID":"/macros/","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"macro 在计算机科学中的意义是语言语法上的拓展。lisp 的 macro非常强大，但是需要多实践。 ","date":"2022-05-01","objectID":"/macros/:0:0","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"macros 是如何工作的 一个macro 是一段原始的lisp代码，它对另一段假定的lisp代码进行操作，将其转换成更接近于可执行的Lisp代码。有点复杂，举个例子。 (setq2 x y e) 当lisp解释器看到这段代码时，会将它视为 (progn (setq v1 e) (setq v2 e)) 实际上，这并不完全正确。macro允许我们通过一段程序，将输入的代码加工成另一个代码 ","date":"2022-05-01","objectID":"/macros/:1:0","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"Quote 我们可以这样定义seq2macro: (defmacro setq2 (v1 v2 e) (list 'progn (list 'setq v1 e) (list 'setq v2 e))) 这段macro接受两个variables 和 一个expression 他会返回一段代码。在lisp中，code是用lists表示的，所以 返回list也就代表一段code. 我们使用了quote符号，一个非常特殊的操作符 每个被quated的对象会被运算成它自己 (+ 1 2) evaluates to 3 但是 (quote (+ 1 2)) evalutes to (+ 1 2) (quote (foo bar baz)) evalutes to (foo bar baz) ’ 是quote的所缩写 ‘foo 和 (quote foo 是一样的) 还记得之前说过 ‘用来保护表达式不被求值。‘开头的表达式都会保持原样 所以最后生成的代码是这样的 (progn (setq v1 e) (setq v2 e)) 这时我们就可以使用他了 (defparameter v1 1) (defparameter v2 2) (setq v1 v2 3) ;; 3 ","date":"2022-05-01","objectID":"/macros/:2:0","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"Macroexpand 当你开始写macro的时候，你肯定想知道macro究竟生成了哪些代码。macroexpandkey可以做到这样的事情。 (macroexpand '(setq2 v1 v2 3)) ;; (PROGN (SETQ V1 3) (SETQ V2 3)) ;; T 更复杂一点的 (macroexpand '(setq2 v1 v2 (+ z 3))) ;; (PROGN (SETQ V1 (+ z 3)) (SETQ V2 (+ z 3))) ;; T 可以看到，e并没有被evaluated 而是保持原样。 我们会需要一个comma(,)符号，用来将被保护的表达式求值 ","date":"2022-05-01","objectID":"/macros/:3:0","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"Evaluation Context 在宏定义中，不能再次调用宏，这会导致宏嵌套。如果需要调用某些功能，可以重新定义一个函数，而不是宏。这是因为在执行态时执行的是编译时宏的展开。也就是说，在编译一个函数时，中途遇到了表达式 (setq2 x y (+ z 3)，编译器就会将 setq2 宏展开并编译成可执行状态（如机器语言或是字节码）。也就是说，当编译器遇到 setq2 表达式时，他就要切换去执行 setq2 主体内容。而如果在 setq2 里面再嵌套宏时，编译器就会去处理另一个宏，然后就出不来了，导致 setq2 无法继续执行。 在编译时，所有代码都是可以处理的，但是宏嵌套打破了这个规则 错误示例: (defmacro setq2 (v1 v2 e) (let ((e1 (some-computation e))) (list 'progn (list 'setq v1 e1) (list 'setq v2 e1)))) (defmacro some-computation (exp) ...) ;; _Wrong!_ 正确示例: (defmacro setq2 (v1 v2 e) (let ((e1 (some-compatation e))) (list 'progn (list 'setq v1 e1) (list 'setq v2 e1)))) (defun some-computation (exp) ...) ;; _Right!_ 我们必须要告诉macro 参数是如何传递给幕后函数的。在函数调用中我们很容易做到这样的事情，我们使用lambda-list 语法，例如\u0026optional, \u0026rest, \u0026key，但是在macro中所有的形参都是macro形式的，而不是他们的值。看下面的例子 (defmacro foo (x \u0026optional y \u0026key (ctx 'null)) ...) _If we call it thus ..._ |_The parameters' values are ..._ -----------------------------|----------------------------------- `(foo a)` | `x=a`, `y=nil`, `cxt=null` `(foo (+ a 1) (- y 1))` |`x=(+ a 1)`, `y=(- y 1)`, `cxt=null` `(foo a b :cxt (zap zip))` |`x=a`, `y=b`, `cxt=(zap zip)` 你需要清楚的是在宏中变量是不会被求值的，只会保持原样。 看下面的例子 (defmacro setq-reversible (e1 e2 direction) (case direction (:normal (list 'setq e1 e2)) (:backward (list 'setq e2 e1)) (t (error \"Unknown direction: ~a\" direction)))) 看看他的展开 (macroexpand '(setq-reversible x y :normal)) ;;(SETQ X Y) ;;T (macroexpand '(setq-reversible x y :backward)) ;;(SETQ Y X) ;;T 如果你传递了一个错误的参数, 宏展开就会报错 (macroexpand '(setq-reversible x y :other-way-around)) 我们可以使用backquote 和 comma 来解决宏展开时报错的问题 (defmacro setq-reversible (v1 v2 direction) (case direction (:normal (list 'setq v1 v2)) (:backward (list 'setq v2 v1)) (t `(error \"Unknown direction: ~a\" ,direction)))) ;; ^^ backquote ^^ comma: get the value inside the backquote. (macroexpand '(SETQ-REVERSIBLE v1 v2 :other-way-around)) ;; (ERROR \"Unknown direction: ~a\" :OTHER-WAY-AROUND) ;; T 使用宏的时候传入错误的方向还是会报错，但是在展开宏的时候，不会报错。 ","date":"2022-05-01","objectID":"/macros/:4:0","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"Backquote and comma backquote(`)字符表明，在他后面的expression,任何不以comma为前缀的表达式都会被quoted,而以comma为前缀的将会被evaluate `(progn (setq ,v1 ,e) (setq ,v2 ,e)) ;;^ backquote ^ ^ ^ ^ commas `(v1 = ,v1) ;; =\u003e (V1 = 3) ","date":"2022-05-01","objectID":"/macros/:5:0","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"comma-splice ,@ ,@会将（本来应该是列表的）参数展开。将列表的元素插入模板来取代列表 (setf lst '(a b c)) ;; =\u003e (A B C) `(lst is ,lst) ;; =\u003e (LST IS (A B C)) `(its elements are ,@lst) ;; =\u003e (ITS ELEMENTS ARE A B C) ","date":"2022-05-01","objectID":"/macros/:5:1","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"Quote-comma ‘, 如果想把表达式的字面打出来，我们需要使用’, (defmacro explain-exp (exp) `(format t \"~s = ~s\" ',exp ,exp)) (explain-exp (+ 2 3)) ;; (+ 2 3) = 5 ","date":"2022-05-01","objectID":"/macros/:5:2","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"Gensym 如果想创建零时变量，我们使用gensym function. 他会返回一个全新的变量，并且不会在别的地方出现 (defmacro setq2 (v1 v2 e) (let ((tempvar (gensym))) `(let ((,tempvar ,e)) (progn (setq ,v1 ,tempvar) (setq ,v2 ,tempvar))))) 现在 (setq2 x y (+ x 2)) 会被展开成 (let ((#:g2003 (+ x 2))) (progn (setq x #:g2003) (setq y #:g2003))) ","date":"2022-05-01","objectID":"/macros/:6:0","tags":["common-lisp"],"title":"common lisp macros","uri":"/macros/"},{"categories":["lisp"],"content":"Common Lisp Object System 的使用","date":"2022-04-30","objectID":"/fundamentals-of-clos/","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"CLOS is the “Common Lisp Object System”, arguably one of the most powerful object systems available in any language. Some of its features include: it is dynamic, making it a joy to work with in a Lisp REPL. For example, changing a class definition will update the existing objects, given certain rules which we have control upon. it supports multiple dispatch and multiple inheritance, it is different from most object systems in that class and method definitions are not tied together, it has excellent introspection capabilities, it is provided by a meta-object protocol, which provides a standard interface to the CLOS, and can be used to create new object systems. The functionality belonging to this name was added to the Common Lisp language between the publication of Steele’s first edition of “Common Lisp, the Language” in 1984 and the formalization of the language as an ANSI standard ten years later. This page aims to give a good understanding of how to use CLOS, but only a brief introduction to the MOP. To learn the subjects in depth, you will need two books: Object-Oriented Programming in Common Lisp: a Programmer`s Guide to CLOS the Art of the Metaobject Protocol ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:0:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Classes and instances 先来个简单的例子 包含class的定义，对象的创建，slot的访问，methods的指定，以及继承 (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper))) ;; =\u003e #\u003cSTANDARD-CLASS PERSON\u003e (defvar p1 (make-instance 'person :name \"me\" )) ;; ^^^^ initarg ;; =\u003e #\u003cPERSON {1006234593}\u003e (name p1) ;;^^^ accessor ;; =\u003e \"me\" (lisper p1) ;; =\u003e nil ;; ^^ initform (slot unbound by default) (setf (lisper p1) t) (defclass child (person) ()) (defclass child (person) ((can-walk-p :accessor can-walk-p :initform t))) ;; #\u003cSTANDARD-CLASS CHILD\u003e (can-walk-p (make-instance 'child)) ;; T ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:1:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Defining classes (defclass) CLOS中定义一个新的数据类型使用defclass macro (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper))) 这样我们就得到了一个CLOS 类型（class）叫做person,person 有两个slot 一个叫做name 一个叫做lisper。 (class-of p1) #\u003cSTANDARD-CLASS PERSON\u003e (type-of p1) PERSON defclass 的通用形式 (defclass \u003cclass-name\u003e (list of super classes) ((slot-1 :slot-option slot-argument) (slot-2,etc)) (:optional-class-option :another-optional-class-option)) 所以person class 并没有显式的继承任何class. 但是他默认继承了standard-object. 我们也可以写一个非常小的class 不用slot options (defclass point () (x y z)) 甚至都不需要slot (defclass point()()) ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:2:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"创建对象(make-instance) (defvar p1 (make-instance 'person :name \"me\")) 更实用的方法是定义构造函数 (defun make-person (name \u0026key lisper) (make-instance 'person :name name :lisper lisper)) ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:3:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Slots ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:4:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"A function that always works(slot-value) 在任何时候都可以用来用来访问slot的函数时 (slot-value \u003cobject\u003e \u003cslot-name\u003e) (defvar pt (make-instance 'point)) (inspect pt) The object is a STANDARD-OBJECT of type POINT. 0. X: \"unbound\" 1. Y: \"unbound\" 2. Z: \"unbound\" 这样你可以获得一个point对象，但是他的slots 默认是没有绑定的，尝试访问他们会导致UNBOUND-SLOT condition (slot-value pt 'x) ;; =\u003e condition: the slot is unbound slot-value 是可以被setf 的 (setf (slot-value pt 'x) 1) (slot-value pt 'x) ;; =\u003e 1 ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:4:1","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"初始化和默认值(initarg,initform) :initarg :foo 是用来传给make-instance 让make-instance 给slot 设置值的关键字 (make-instance 'person :name \"me\") :initform \u003cval\u003e 是当我们没有显式指定initarg时，设置的默认值。在defclass的词法作用域中 (defclass foo () ((a :initarg :a :initform (error \"you didn`t supply an initial value for slot a\")))) (make-instance 'foo) ;; =\u003e enters the debugger ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:4:2","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Getters and Setters (accessor,reader,writer) :accessor foo: accessor 既是getter 也是 setter. (name p1) ;; =\u003e \"me\" (type-of #'name) STANDARD-GENERIC-FUNCTION reader and writer 就是他们描述的功能，只有:writer是setf-able的 如果你不指定他们，你仍然可以使用slot-value 呢可以指定不止一个:accessor,:reader 或者 :initarg 这里介绍两个macros 让访问slot更加简洁 with-slots 可以一次访问多个slot-value (with-slots (name lisper) c1 (format t \"got ~a, ~a~\u0026\" name lisper)) or (with-slots ((n name) (l lisper)) c1 (format t \"got ~a, ~a~\u0026\" n l)) with-accessor 也差不多，但是使用的accessor (with-accessors ((name name) (lisper lisper)) p1 (format t \"name: ~a, lisper: ~a\" name lisper)) ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:4:3","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Class VS instance slots :allocation 用来说明这个slot是local的还是shared local slot 是默认的，也就是说，实例之间是不共享的 这时:allocation == :instance shared slot 在实例间是共享的，我们可以用:allocation :class 来设置 在下面的例子中，注意 p2的species槽的值是如何变化的，以及是如何影响所有class的instance的 (defclass person () ((name :initarg :name :accessor name) (species :initform 'homo-sapiens :accessor species :allocation :class))) ;; Note that the slot \"lisper\" was removed in existing instances. (inspect p1) ;; The object is a STANDARD-OBJECT of type PERSON. ;; 0. NAME: \"me\" ;; 1. SPECIES: HOMO-SAPIENS ;; \u003e q (defvar p2 (make-instance 'person)) (species p1) (species p2) ;; HOMO-SAPIENS (setf (species p2) 'homo-numericus) ;; HOMO-NUMERICUS (species p1) ;; HOMO-NUMERICUS (species (make-instance 'person)) ;; HOMO-NUMERICUS (let ((temp (make-instance 'person))) (setf (species temp) 'homo-lisper)) ;; HOMO-LISPER (species (make-instance 'person)) ;; HOMO-LISPER ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:4:4","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Slot documentation 任何slot 都可以接受一个:documentation option ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:4:5","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Slot type :type 用来检查slot的类型，但是只有很少一部分的实现支持:type 类型检查 ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:4:6","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"find-class,class-name,class-of (find-class 'point) ;; #\u003cSTANDARD-CLASS POINT 275B78DC\u003e (class-name (find-class 'point)) ;; POINT (class-of my-point) ;; #\u003cSTANDARD-CLASS POINT 275B78DC\u003e (typep my-point (class-of my-point)) ;; T ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:5:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Subclasses 和 inheritance child 是 person 的子类, 所有object 都继承自standard-object and t. 所有child instance 也是 person 的 instance (type-of cl) ;; child (subtypep (type of cl) 'person) ;; T (ql:quickload \"closer-mop\") ;; ... (closer-mop:subclassp (class-of cl) 'person) 一个subclass 继承了他所有的 parents` 的slots, 并且，他可以覆盖父类们的任何slot options. child class的优先级是这样的 child \u003c- person \u003c-- standard-object \u003c- t 我们可以用closer-mop:class-precedence-list 去查看 (closer-mop:class-precedence-list (class-of c1)) ;; (#\u003cstandard-class child\u003e ;; #\u003cstandard-class person\u003e ;; #\u003cstandard-class standard-object\u003e ;; #\u003csb-pcl::slot-class sb-pcl::slot-object\u003e ;; #\u003csb-pcl:system-class t\u003e) 但是child的直接父类只是 (closer-mop:class-direct-superclasses (class-of c1)) ;; (#\u003cstandard-class person\u003e) 我们还可以用更多的方法来inspect classes,比如class-direct-[subclasses, slots, default-initargs] slots 以如下方式结合 :accessor and :reader are combined by the union of accessors and readers from all the inherited slots. :initarg: the union of initialization arguments from all the inherited slots. :initform: we get the most specific default initial value form, i.e. the first :initform for that slot in the precedence list. :allocation is not inherited. It is controlled solely by the class being defined and defaults to :instance. ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:6:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Multiple inheritance (defclass baby (child person) ()) 现代语言不提倡多重继承 ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:7:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Redefining and changing a class 这一节简短的包含两个话题 重定义已经存在的class 改变已经一个class 的instance 要重定义一个class,只需要在执行榆次defclass, 他会替换所有的旧的定义，包括实例，继承。 (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper))) (setf pl (make-instance 'person :name \"me\")) changing,adding,removing slots… (lisper p1) ;; NIL (defclass person () ((name :initarg :name :accessor name) (lisper :initform t ;; \u003c-- from nil to t :accessor lisper))) (lisper p1) ;; NIL (of course!) (lisper (make-instance 'person :name \"You\")) ;; T (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper) (age ;; \u003c-- new slot :initarg :arg :initform 18 ;; \u003c-- default value :accessor age))) (age p1) ;; =\u003e 18. Correct. This is the default initform for this new slot. (slot-value p1 'bwarf) ;; =\u003e \"the slot bwarf is missing from the object #\u003cperson…\u003e\" (setf (age p1) 30) (age p1) ;; =\u003e 30 (defclass person () ((name :initarg :name :accessor name))) (slot-value p1 'lisper) ;; =\u003e slot lisper is missing. (lisper p1) ;; =\u003e there is no applicable method for the generic function lisper when called with arguments #(lisper). 要改变一个实例的class, 可以使用change-class: (change-class p1 'child) ;; we can also set slots of the new class: (change p1 'child :can-walk-p nil) (class-of p1) ;; #\u003cSTANDARD-CLASS CHILD\u003e (can-walk-p p1) ;; T ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:8:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Pretty printing 每次我们打印一个object 我们会获得一个这样的输出 #\u003cPERSON {1006234593}\u003e 如果想要更多的信息，比如 #\u003cPERSON me lisper: t\u003e 要想更加好看的打印可以指定 class 的 generic print-object 方法 (defmethod print-object ((obj person) stream) (print-unreadable-object (obj stream :type t) (with-accessors ((name name) (lisper lisper)) obj (format stream \"~a, lisper: ~a\" name lisper)))) p1 ;; #\u003cPERSON me, lisper: T\u003e print-unreadable-object 打印#\u003c…\u003e, 这表明 object 的reader无法再深入的读取. :type t 参数要求答应object-type的前缀，也就是 PERSON. 没有它我们会得到 #\u003cme,lisper: T\u003e 我们使用了with-accessors macro,但是对于简单的情况这样做就可以了的 (defmethod print-object ((obj person) stream) (print-unreadable-object (obj stream :type t) (format stream \"~a, lisper: ~a\" (name obj) (lisper obj)))) warning 尝试访问一个没有被绑定的slot会导致错误，所以应该先使用slot-boundp判断 下面的代码重现了默认的打印方式 (defmethod print-object ((obj person) stream) (print-unreadable-object (obj stream :type t :identity t))) 这里:identity为t时将会打印地址 ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:9:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Classes of traditional lisp types 这节不是很明白贴出原文地址吧 Classes of traditional lisp types ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:10:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Introspection 其实Introspection就是各种判断CLOS instance内部结构的断言函数，如果你需要非常了解这些函数的话推荐去看看closer-mop 库和CLOS \u0026 MOP specifications 这里列出一些函数 closer-mop:class-default-initargs closer-mop:class-direct-default-initargs closer-mop:class-direct-slots closer-mop:class-direct-subclasses closer-mop:class-direct-superclasses closer-mop:class-precedence-list closer-mop:class-slots closer-mop:classp closer-mop:extract-lambda-list closer-mop:extract-specializer-names closer-mop:generic-function-argument-precedence-order closer-mop:generic-function-declarations closer-mop:generic-function-lambda-list closer-mop:generic-function-method-class closer-mop:generic-function-method-combination closer-mop:generic-function-methods closer-mop:generic-function-name closer-mop:method-combination closer-mop:method-function closer-mop:method-generic-function closer-mop:method-lambda-list closer-mop:method-specializers closer-mop:slot-definition closer-mop:slot-definition-allocation closer-mop:slot-definition-initargs closer-mop:slot-definition-initform closer-mop:slot-definition-initfunction closer-mop:slot-definition-location closer-mop:slot-definition-name closer-mop:slot-definition-readers closer-mop:slot-definition-type closer-mop:slot-definition-writers closer-mop:specializer-direct-generic-functions closer-mop:specializer-direct-methods closer-mop:standard-accessor-method ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:11:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"See also ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:12:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"defclass/std: write shorter classes defclass/std 提供了一个简写defclass的macro 默认他会提供一个initarg 和一个绑定为nil的initform 给你的slot定义 比如 (defclass/std example() ((slot1 slot2 slot3))) 会被展开为 (defclass example() ((slot1 :accessor slot1 :initarg :slot1 :initform nil) (slot2 :accessor slot2 :initarg :slot2 :initform nil) (slot3 :accessor slot3 :initarg :slot3 :initform nil))) 他很方便灵活，但是common lisp 社区很少使用他，你可以自行决定是否使用他 ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:12:1","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Methods ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:13:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"先来个潜入 之前有过person 和 child 类的定义 (defclass person() ((name :initarg :name :accessor name))) (defclass child (person) ()) (setf p1 (make-instance 'person :name \"me\")) (setf p2 (make-instance 'child :name \"Alice\")) (defmethod greet (obj) (format t \"Are you a person ? You are a ~a.~\u0026\" (type-of obj))) ;; style-warning: Implicitly creating new generic function common-lisp-user::greet. ;; #\u003cSTANDARD-METHOD GREET (t) {1008EE4603}\u003e (greet :anything) ;; Are you a person ? You are a KEYWORD. ;; NIL (greet p1) ;; Are you a person ? You are a PERSON. (defgeneric greet (obj) (:documentation \"say hello\")) ;; STYLE-WARNING: redefining COMMON-LISP-USER::GREET in DEFGENERIC ;; #\u003cSTANDARD-GENERIC-FUNCTION GREET (2)\u003e (defmethod greet ((obj person)) (format t \"Hello ~a !~\u0026\" (name obj))) ;; #\u003cSTANDARD-METHOD GREET (PERSON) {1007C26743}\u003e (greet p1) ;; =\u003e \"Hello me !\" (greet c1) ;; =\u003e \"Hello Alice !\" (defmethod greet ((obj child)) (format t \"ur so cute~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET (CHILD) {1008F3C1C3}\u003e (greet p1) ;; =\u003e \"Hello me !\" (greet c1) ;; =\u003e \"ur so cute\" ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; Method combination: before, after, around. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (defmethod greet :before ((obj person)) (format t \"-- before person~\u0026\")) #\u003cSTANDARD-METHOD GREET :BEFORE (PERSON) {100C94A013}\u003e (greet p1) ;; -- before person ;; Hello me (defmethod greet :before ((obj child)) (format t \"-- before child~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :BEFORE (CHILD) {100AD32A43}\u003e (greet c1) ;; -- before child ;; -- before person ;; ur so cute (defmethod greet :after ((obj person)) (format t \"-- after person~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :AFTER (PERSON) {100CA2E1A3}\u003e (greet p1) ;; -- before person ;; Hello me ;; -- after person (defmethod greet :after ((obj child)) (format t \"-- after child~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :AFTER (CHILD) {10075B71F3}\u003e (greet c1) ;; -- before child ;; -- before person ;; ur so cute ;; -- after person ;; -- after child (defmethod greet :around ((obj child)) (format t \"Hello my dear~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :AROUND (CHILD) {10076658E3}\u003e (greet c1) ;; Hello my dear ;; call-next-method (defmethod greet :around ((obj child)) (format t \"Hello my dear~\u0026\") (when (next-method-p) (call-next-method))) ;; #\u003cstandard-method greet :around (child) {100AF76863}\u003e (greet c1) ;; Hello my dear ;; -- before child ;; -- before person ;; ur so cute ;; -- after person ;; -- after child ;;;;;;;;;;;;;;;;; ;; Adding in \u0026key ;;;;;;;;;;;;;;;;; ;; In order to add \"\u0026key\" to our generic method, we need to remove its definition first. (fmakunbound 'greet) ;; with Slime: C-c C-u (slime-undefine-function) (defmethod greet ((obj person) \u0026key talkative) (format t \"Hello ~a~\u0026\" (name obj)) (when talkative (format t \"blah\"))) (defgeneric greet (obj \u0026key \u0026allow-other-keys) (:documentation \"say hi\")) (defmethod greet (obj \u0026key \u0026allow-other-keys) (format t \"Are you a person ? You are a ~a.~\u0026\" (type-of obj))) (defmethod greet ((obj person) \u0026key talkative \u0026allow-other-keys) (format t \"Hello ~a !~\u0026\" (name obj)) (when talkative (format t \"blah\"))) (greet p1 :talkative t) ;; ok (greet p1 :foo t) ;; still ok ;;;;;;;;;;;;;;;;;;;;;;; (defgeneric greet (obj) (:documentation \"say hello\") (:method (obj) (format t \"Are you a person ? You are a ~a~\u0026.\" (type-of obj))) (:method ((obj person)) (format t \"Hello ~a !~\u0026\" (name obj))) (:method ((obj child)) (format t \"ur so cute~\u0026\"))) ;;;;;;;;;;;;;;;; ;;; Specializers ;;;;;;;;;;;;;;;; (defgeneric feed (obj meal-type) (:method (obj meal-type) (declare (ignorable meal-type)) (format t \"eating~\u0026\"))) (defmethod feed (obj (meal-type (eql :dessert))) (declare (ignorable meal-type)) (format t \"mmh, dessert !~\u0026\")) (feed c1 :dessert) ;; mmh, dessert ! (defmethod feed ((obj child) (meal-type (eql :soup))) (declare (ignorable meal-type)) (format t \"bwark~\u0026\")) (feed p1 :soup) ;; eating (feed c1 :soup) ;; bwark ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:13:1","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Generic functions (defgeneric,defmethod) 在lisp方法中 generic function 是一个相关联的方法集合。所有同名的方法都属于同一个generic function defmethod 和 defun 很相似。他将函数名和函数体相关联，但是函数体只有当参数的类型和lambda list定义的类型相匹配时才会被执行。 他们可以有optional,keyword 和 \u0026rest参数 lambda list lambda list 其实就是参数列表 defgeneric 用来定义generic function, 如果我们使用defmethod 的时候没有对应的defgeneric时，一个generic function就会被自动创建 使用defgenerics 是一个好习惯，我们可以添加默认的实现，甚至是documentation (defgeneric greet (obj) (:documentation \"says hi\") (:method (obj) (format t \"Hi\"))) 一个方法的lambda list 所需要的参数可能有三种形式 a simple variable: (defmethod greet (foo) ...) 这个method 可以接受任何的参数 一个variable 和一个specializer (defmethod greet ((foo person)) ...) 在这种情况下，foo 被绑定只有特定的class 比如person 和其 subclass才能使用这个方法 如果参数与specializer不匹配，那么就会报错 对于optional \u0026key 参数我们不能使用specialize a variable 和一个eql specializer (defmethod feed ((obj child) (meal-type (eql :soup))) (declare (ignorable meal-type)) (format t \"bwark~\u0026\")) (feed cl :soup) ;; \"bwark\" 你可以定义很多同名的函数，只要他们的specializers不同。系统会选择最具体的函数进行调用。通用函数调用的优先级是 参数决定了一个或多个可用方法，如果在调用中的参数和参数的specializers匹配，那么参数可用 如果没有可用方法，就会报错. 如果只有一个，立刻调用 如果多于一个，最具体的会被调用。 最具体可用的方法由传入参数所属类别的优先级决定。由左往右审视参数。如果有一个可用方法的第一个参数，此参数特化给某个类，其类的优先级高于其它可用方法的第一个参数，则此方法就是最具体的可用方法。平手时比较第二个参数，以此类推。 notes It is an error to define a method with the same function name as an ordinary function. If you really want to do that, use the shadowing mechanism. To add or remove keys or rest arguments to an existing generic method’s lambda list, you will need to delete its declaration with fmakunbound (or C-c C-u (slime-undefine-function) with the cursor on the function in Slime) and start again. Otherwise, you’ll see: Methods can be redefined (exactly as for ordinary functions). The order in which methods are defined is irrelevant, although any classes on which they specialize must already exist. An unspecialized argument is more or less equivalent to being specialized on the class t. The only difference is that all specialized arguments are implicitly taken to be “referred to” (in the sense of declare ignore.) Each defmethod form generates (and returns) a CLOS instance, of class standard-method. An eql specializer won’t work as is with strings. Indeed, strings need equal or equalp to be compared. But, we can assign our string to a variable and use the variable both in the eql specializer and for the function call. All the methods with the same function name belong to the same generic function. All slot accessors and readers defined by defclass are methods. They can override or be overridden by other methods on the same generic function. ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:13:2","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Multimethods mutlimethods 显式的指出，函数的parameters不止一个。而且我们很难确定他到底属于那个class #+begin_src lisp (defgeneric hug (a b) (:documentation “Hug between two persons”)) (defmethod hug ((a person) (b person)) :person-person-hug) (defmethod hug ((a person) (b child)) :person-child-hug) #+end_src ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:14:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"控制setters (setf-ing methods) 在lisp 中，我们可以定义setf counterparts of functions or methods. 我们可能想在如何更新object上 获得更多的控制 (defmethod (setf name) (new-val (obj person)) (if (equalp new-val \"jame bond\") (format t \"Dude that`s not possible.~\u0026\") (setf (slot-value obj 'name) new-val))) (setf (name p1) \"james bond\") ;; -\u003e no rename ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:15:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Dispatch mechanism and next methods 这段不讲了，现代语言用的不多，感觉有点糟粕了。有兴趣自己去看吧 Dispatch mechanism and next methods ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:16:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Method qualifiers (before,after,around) 这个也是牛牛牛，但是我学过的语言都没这个。也是自己去看吧 Method qualifiers ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:17:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"Other method combinations 这个更离谱，自己去看 other method combinations ","date":"2022-04-30","objectID":"/fundamentals-of-clos/:18:0","tags":["common-lisp","clos"],"title":"CLOS基础","uri":"/fundamentals-of-clos/"},{"categories":["lisp"],"content":"common lisp 的错误和异常处理","date":"2022-04-30","objectID":"/error-and-exception-handling/","tags":["common-lisp"],"title":"Common Lisp Error and Exception Handling","uri":"/error-and-exception-handling/"},{"categories":["lisp"],"content":"这一节后半段需要CLOS的知识, 所以为了不产生疑惑，在读到define-condition的时候先去看看CLOS CLOS ","date":"2022-04-30","objectID":"/error-and-exception-handling/:0:0","tags":["common-lisp"],"title":"Common Lisp Error and Exception Handling","uri":"/error-and-exception-handling/"},{"categories":["lisp"],"content":"Ignoring all errors, returning nil 有时候你知道函数会失败，并且你想忽略这个错误，可以使用ignore-errors (ignore-errors (/ 3 0)) ; in: IGNORE-ERRORS (/ 3 0) ; (/ 3 0) ; ; caught STYLE-WARNING: ; Lisp error during constant folding: ; arithmetic error DIVISION-BY-ZERO signalled ; Operation was (/ 3 0). ; ; compilation unit finished ; caught 1 STYLE-WARNING condition NIL #\u003cDIVISION-BY-ZERO {1008FF5F13}\u003e 3/0 是一个错误，我们收到了警告。但是函数会正常返回nil，函数执行的状态被返回，失败了。 ","date":"2022-04-30","objectID":"/error-and-exception-handling/:1:0","tags":["common-lisp"],"title":"Common Lisp Error and Exception Handling","uri":"/error-and-exception-handling/"},{"categories":["lisp"],"content":"Catching any condition (handler-case) ignore-errors是建立在handler-case上的。我们可以通过捕获err重写上面的例子,但是我们可以返回我们想返回的东西 (handler-case (/ 3 0) (error (c) (format t \"We caught a condition.~\u0026\") (values 0 c))) ; in: HANDLER-CASE (/ 3 0) ; (/ 3 0) ; ; caught STYLE-WARNING: ; Lisp error during constant folding: ; Condition DIVISION-BY-ZERO was signalled. ; ; compilation unit finished ; caught 1 STYLE-WARNING condition We caught a condition. 0 #\u003cDIVISION-BY-ZERO {1004846AE3}\u003e 可以看到我们返回了0 和 c handler-case的通用模板是 (handler-case (code that errors out) (condition-type (the-condition) ;; \u003c-- optional argument (code)) (another-condition (the-condition) ...)) 我们也可以用t 来捕获条件 (handler-case (progn (format t \"This won`t work...~%\") (/3 0)) (t (c) (format t \"Got an exception: ~a~%\" c) (values 0 c))) ;; … ;; This won't work… ;; Got an exception: arithmetic error DIVISION-BY-ZERO signalled ;; Operation was (/ 3 0). ;; 0 ;; #\u003cDIVISION-BY-ZERO {100608F0F3}\u003e ","date":"2022-04-30","objectID":"/error-and-exception-handling/:2:0","tags":["common-lisp"],"title":"Common Lisp Error and Exception Handling","uri":"/error-and-exception-handling/"},{"categories":["lisp"],"content":"捕获一个特殊的条件 我们可以指定哪些条件需要处理 (handler-case (/ 3 0) (division-by-zero (c) (format t \"Caught division by zero: ~a~%\" c))) ;; … ;; Caught division by zero: arithmetic error DIVISION-BY-ZERO signalled ;; Operation was (/ 3 0). ;; NIL 这个和try/catch形式非常像，但是我们可以做更多的事情 ","date":"2022-04-30","objectID":"/error-and-exception-handling/:3:0","tags":["common-lisp"],"title":"Common Lisp Error and Exception Handling","uri":"/error-and-exception-handling/"},{"categories":["lisp"],"content":"handler-case vs handler-bind handler-case和其他语言的try/catch非常像 handler-bind 用在哪些当错误出现时我们需要绝对控制的情况下。他允许我们交互的使用debugger和编程化的restart, ","date":"2022-04-30","objectID":"/error-and-exception-handling/:4:0","tags":["common-lisp"],"title":"Common Lisp Error and Exception Handling","uri":"/error-and-exception-handling/"},{"categories":["lisp"],"content":"defining and make conditions 我们可以使用define-condition 定义condtions，使用make-condition 初始化他们 (define-condition my-division-by-zero (error) ()) (make-condition 'my-division-by-zero) ;; #\u003cMY-DIVISION-BY-ZERO {1005A5FE43}\u003e 定义condition时，最好给出更多的信息 (define-condition my-division-by-zero (error) ((dividend :initarg :dividend :initform nil :reader dividend)) ;; \u003c-- we'll get the dividend with (dividend condition). See the CLOS tutorial if needed. (:documentation \"Custom error when we encounter a division by zero.\")) ;; good practice ;) ","date":"2022-04-30","objectID":"/error-and-exception-handling/:5:0","tags":["common-lisp"],"title":"Common Lisp Error and Exception Handling","uri":"/error-and-exception-handling/"},{"categories":["lisp"],"content":"common lisp 的文件和文件夹操作","date":"2022-04-29","objectID":"/files-and-directories/","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"本节主要介绍UIOP中的一些有关文件和文件操作方面的使用。获取你也应该直接看一看UIOP的官方文档. UIOP 当然，也别忘了 Files and File I/O in Practicial Common Lisp ","date":"2022-04-29","objectID":"/files-and-directories/:0:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"测试文件是否存在 probe-file 专门用来测试文件是否存在。如果返回Nil文件不存在，返回truename则文件存在 truename Many file systems permit more than one filename to designate a particular file. Even where multiple names are possible, most file systems have a convention for generating a canonical filename in such situations. Such a canonical filename (or the pathname representing such a filename) is called a truename. 为了可移植性，可以使用返回pathname的uiop:probe-file* 或者uiop:file-exists-p（如果文件存在的话） $ ln -s /etc/passwd foo (probe-file \"/etc/passwd\") #p\"/etc/passwd\" (probe-file \"foo\") #p\"/etc/passwd\" (probe-file \"bar\") NIL ","date":"2022-04-29","objectID":"/files-and-directories/:1:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"展开~（家目录环境变量） 我们使用uiop:native-namestring: (uiop:native-namestring \"~/.emacs.d/\") 如果文件不存在，他也会被展开 (uiop:native-namestring \"~/foo987.txt\") ;; \"/home/me/foo987.txt\" 在许多lisp实现上(CCL,ABCL,ECL,CLISP,LispWorks),namestring 很像。在 SBCL上，如果文件不存在，或者目录不存在，namestring不会展开path 而是直接返回参数 要测试文件是否存在也可以使用truename,但是在SBCL上，如果文件不存在，会直接返回错误。 ","date":"2022-04-29","objectID":"/files-and-directories/:2:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"创建文件夹 (ensure-directories-exist \"fbbboo/bar/baz/\") 这样会创建fbbboo bar baz 不要忘记在尾部加上斜杠 ","date":"2022-04-29","objectID":"/files-and-directories/:3:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"删除文件夹 uiop:delete-directory-tree 和一个pathname(#p),一个尾部斜杠 和:validate (uiop:delete-directory-tree #p\"dirtest/\" :validate t) 也可以使用pathname 函数创建一个pathname (defun rmdir (path) (uiop:delete-directory-tree (pathname path) :validate t)) uiop 还有一个delete-empty-directory 用来删除空的文件夹 ","date":"2022-04-29","objectID":"/files-and-directories/:4:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"合并文件和文件夹 merge-pathnames 专用来合并路径，如果你想在后面添加一个文件夹，第二个参数必须带上末尾斜杠 (merge-pathnames \"otherpath\" \"/home/vince/projects/\") ;; =\u003e #p\"/home/vince/projects/otherpath\" 这里otherpath被当做文件 (merge-pathnames \"otherpath\" \"/home/vince/projects\") ;; #P\"/home/vince/otherpath\" ;; ^^ no \"projects\", because it was seen as a file. (merge-pathnames \"otherpath/\" \"/home/vince/projects\") ;; #P\"/home/vince/otherpath/projects\" ;; ^^ inserted here ","date":"2022-04-29","objectID":"/files-and-directories/:5:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"获取当前目录(CWD) 使用uiop/os:getcwd: (uiop/os:getcwd) ;; #P\"/home/vince/projects/cl-cookbook/\" ;; ^ with a trailing slash, useful for merge-pathnames ","date":"2022-04-29","objectID":"/files-and-directories/:6:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"获取以lisp工程为根目录的相对路径的绝对路径 使用asdf:system-relative-pathname system path. (asdf:system-relative-pathname \"mysystem\" \"src/web\") ;; =\u003e #P\"/home/vince/projects/mysystem/src/web/\" ","date":"2022-04-29","objectID":"/files-and-directories/:7:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"opening a file 打开文件其实之前有写过，这里不赘述。直接给出cookbook 的连接（主要，我自己已经看过了,不想多写哈哈哈哈） opening a file 也可以去看看我之前写的Input-Output ","date":"2022-04-29","objectID":"/files-and-directories/:8:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"Reading files ","date":"2022-04-29","objectID":"/files-and-directories/:9:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"将文件读入string 或 行list中 read-file-string (uiop:read-file-string \"file.txt\") read-file-lines (uiop:read-file-lines \"file.txt\") ","date":"2022-04-29","objectID":"/files-and-directories/:9:1","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"read-line or read-char 这两个函数的性能不高，可以加入缓冲区解决这个问题 (with-output-to-string (out) (with-open-file (in \"/path/to/big/file\") (loop with buffer = (make-array 8192 :element-type 'character) for n-characters = (read-sequence buffer in) while (\u003c 0 n-characters) do (write-sequence buffer out :start 0 :end n-characters)))) ","date":"2022-04-29","objectID":"/files-and-directories/:9:2","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"以utf-8的格式读取 (with-open-file (in \"/path/to/big/file\" :external-format :utf-8) ) ","date":"2022-04-29","objectID":"/files-and-directories/:9:3","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"将SBCL的默认字符集设为utf-8 在~/.sbclrc中加入 (setf sb-impl::*default-external-format* :utf-8) 或者 (setf sb-alien::*default-c-string-external-format* :utf-8) ","date":"2022-04-29","objectID":"/files-and-directories/:9:4","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"向文件中写入内容 (with-open-file (f \u003cpathname\u003e :direction :output :if-exists :supersede :if-does-not-exist :create) (write-sequence s f)) 如果文件存在，你也可以使用:append 来追加内容 使用库 Alexandria 有一个函数叫write-string-into-file (alexandria:write-string-into-file content \"file.txt\") ","date":"2022-04-29","objectID":"/files-and-directories/:9:5","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"获取文件后缀 (pathname-type \"~/foo.org\") ;; =\u003e \"org\" ","date":"2022-04-29","objectID":"/files-and-directories/:10:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"获取文件属性(size,access time,….) Osicat(in quicklisp)是一个轻量级操作系统接口。使用Osicat 可以获取环境变量，操作files directories pathnames (ql:quickload \"osicat\") (let ((stat (osicat-posix:stat #P\"./files.md\"))) (osicat-posix:stat-size stat)) ;; =\u003e 10629 可以使用以下函数获取更多的属性 osicat-posix:stat-dev osicat-posix:stat-gid osicat-posix:stat-ino osicat-posix:stat-uid osicat-posix:stat-mode osicat-posix:stat-rdev osicat-posix:stat-size osicat-posix:stat-atime osicat-posix:stat-ctime osicat-posix:stat-mtime osicat-posix:stat-nlink osicat-posix:stat-blocks osicat-posix:stat-blksize ","date":"2022-04-29","objectID":"/files-and-directories/:11:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"列出所有的文件和文件夹 有些函数可以返回pathnames (namestring #p\"/foo/bar/baz.txt\") ==\u003e \"/foo/bar/baz.txt\" (directory-namestring #p\"/foo/bar/baz.txt\") ==\u003e \"/foo/bar/\" (file-namestring #p\"/foo/bar/baz.txt\") ==\u003e \"baz.txt\" ","date":"2022-04-29","objectID":"/files-and-directories/:12:0","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"返回文件夹中的文件(不包括文件夹) (uiop:directory-files \"./\") 返回一连串的pathnames: (#P\"/home/vince/projects/cl-cookbook/.emacs\" #P\"/home/vince/projects/cl-cookbook/.gitignore\" #P\"/home/vince/projects/cl-cookbook/AppendixA.jpg\" #P\"/home/vince/projects/cl-cookbook/AppendixB.jpg\" #P\"/home/vince/projects/cl-cookbook/AppendixC.jpg\" #P\"/home/vince/projects/cl-cookbook/CHANGELOG\" #P\"/home/vince/projects/cl-cookbook/CONTRIBUTING.md\" […] ","date":"2022-04-29","objectID":"/files-and-directories/:12:1","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"返回所有的子文件夹 (uiop:subdirectories \"/Users/qibinyang/test\") (#P\"/Users/qibinyang/test/assertTest/\" #P\"/Users/qibinyang/test/center/\" #P\"/Users/qibinyang/test/client1/\" #P\"/Users/qibinyang/test/client2/\" #P\"/Users/qibinyang/test/test/\") ","date":"2022-04-29","objectID":"/files-and-directories/:12:2","tags":["common-lisp"],"title":"Common Lisp Files and Directories","uri":"/files-and-directories/"},{"categories":["lisp"],"content":"有关common lisp 的循环，和一些小技巧","date":"2022-04-22","objectID":"/loop-iteration-mapping/","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"Introduction: loop,iterate,for,mapcar,series ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:0","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"loop loop 是一个内置的用来迭代的宏, 它最简单的形式是(loop (print “hello”)): 这个语句会无限打印\"hello\" 一个简单的迭代List的例子 (loop for x in '(1 2 3) do (print x)) 这个例子会返回Nil但是会打印他应该打印的 如果你需要将结果收集成一个list使用collect (loop for x in '(1 2 3) collect (* x 10)) loop 表达式有四个部分 设置要被迭代的变量 结束迭代的条件表达式 每次迭代要做的事情 每次退出时要做的事情 除此之外,loop表达式还能返回一个值 正常来说，我们很少使用所有的部分，但是我们可以随意组合他们 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:1","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"iterate iterate 是一个很流行的迭代宏，要比loop更容易懂，但是拓展性要差一些。iterate并不是内置的，要先导入a。 (ql:quickload \"iterate\") (ues-package :iterate) iterate看起来是这样的 (iter (for in from 1 to 5) (collect (* i i))) warning 如果同时使用iterate 和 loop 会有命名冲突 使用display-iterate-clauses可以解决这个问题 (display-iterate-clauses '(for)) ;; FOR PREVIOUS \u0026OPTIONAL INITIALLY BACK Previous value of a variable ;; FOR FIRST THEN Set var on first, and then on subsequent iterations ;; ... ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:2","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"for for是一个可拓展的迭代宏，通常要比loop短。 for的最大好处就是，可以用在任何数据类型上(lists,vectors,hash-tables…) (for:for ((x over \u003cyour data structure\u003e)) (print ...)) for是一个第三方库，需要先quickload (ql:quickload \"for\") ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:3","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"map族 后面还有很多mapcar 和 map这样的例子。map 族还有mapcon,mapcan,maplist,mapc 和 mapl. (mapcar (lambda (it) (+ it 10)) '(1 2 3)) ;; =\u003e (11 12 13) map 更加通用 他可以接受List 和 vectors 作为参数，需要在第一个参数指定结果类型 (map 'vector (lambda (it) (+ it 10)) '(1 2 3)) ;; #(11 12 13) (map 'list (lambda (it) (+ it 10)) #(1 2 3)) ;; (11 12 13) (map 'string (lambda (it) (code-char it)) '#(97 98 99)) ;; \"abc\" 简写lambda函数 是不是觉得写lambda太烦， 其实有一些库可以提供简写lambda函数方法你可以去这里看看简写lambda的库有哪些lambda shorthand libraries 这里给出一个cl-punch的例子 (mapcar ^(* _ 10) '(1 2 3)) ;; =\u003e (10 20 30) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:4","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"series 最后 你可能会喜欢series,一个库通过结合sequences,streams,和loop 来描述自己. Series 表达式看起来就像是在操作序列，但是可以获得相比loop 更高的效率。 Series第一次出现在 “Common Lisp the Language” (collect (mapping ((x (scan-range :from 1 :upto 5))) (* x x))) ;; =\u003e (1 4 9 16 25) Generators The Way I Want Them Generated Library 这是一个lazy sequences 库，和series类似，景观他很年轻，切不完全，但是他有很多现代化的API 比如take,filter,for,fold 并且易用 range :from 20) ;; #\u003cGTWIWTG::GENERATOR! {1001A90CA3}\u003e (take 4 (range :from 20)) ;; (20 21 22 23) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:5","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"小妙招 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:0","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"Looping forever,return (loop (print \"hello\")) return 用来返回结果 (loop for i in '(1 2 3) when (\u003e i 1) return i) ;; =\u003e 2 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:1","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"固定循环n次 dotimes (dotimes (n 3) (print n)) 这里dotimes只会返回Nil 有两种方法返回一个值 设置result在lambda list 中 (dotimes (n 3 :done) print(n)) ;; =\u003e ;; 0 ;; 1 ;; 2 ;; :DONE 使用return (dotimes (i 3) (if (\u003e i 1) (return :early-exit!) (print i))) ;; =\u003e ;; 0 ;; 1 ;; :EARLY-EXIT! loop…repeat (loop repeat 10 do (format t \"Hello!~%\")) 打印10次hello 返回nil (loop repeat 10 collect (random 10)) ;; =\u003e (5 1 3 5 4 0 7 4 9 1) 使用collect 会返回一个list Series (iterate ((n (scan-range :below 10))) (print n)) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:2","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"循环无限次，在一个循环list上循环 前面提到了一个无限循环的方法，但是我们如何在一个list上无限循环呢 我们可以构造一个循环list (loop with list-a = '(1 2 3) with infinite-list = (setf (cdr (last list-a)) list-a) for item in infinite-list repeat 8 collect item) 构造循环列表有一个非常简单的方法使用#=语法 (defparameter list-a '#1=(1 2 3 . #1#)) (setf print-circle t) list-a 如果你只想再两个值之间交替地带，使用for…then (loop repeat 4 for up = t then (not up) do (print up)) T NIL T NIL ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:3","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"Iterate 的for 循环 对于list 和 vectors: (iter (for item in '(1 2 3)) (print item)) (iter (for i in-vector #(1 2 3)) (print i)) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:4","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"在一个list上进行循环 dolist (dolist (item '(1 2 3)) (print item)) loop 使用in (loop for x in '(a b c) do (print x)) ;; A ;; B ;; C ;; NIL (loop for x in '(a b c) collect x) ;; (A B C) 使用on 我们在cdr上迭代 (loop for i on '(1 2 3) do (print i)) ;; (1 2 3) ;; (2 3) ;; (3) mapcar (mapcar (lambda (x) (print (* x 10))) '(1 2 3)) 10 20 30 (10 20 30) mapcar 会将lambda函数的返回值组合成一个List返回 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:5","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"在一个vector上循环 loop:across (loop for i across #(1 2 3) do (print i)) Series (iterate ((i (scan #(123)))) (print i)) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:6","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"在一个hash-table上循环 先创建一个hasht-table: (defparameter h (make-hash-table)) (setf (gethash 'a h) 1) (setf (gethash 'b h) 2) loop 在key上循环 (loop for k being the hash-key of h do(print k)) ;; b ;; a 在value上循环 (loop for k being the hash-key using (hash-value v) of h do (format t \"~a ~a~%\" k v)) ;; b 2 ;; a 1 maphash maphash 的lambda函数时一个拥有两个参数的函数两个参数分别是key,value (maphash (lambda (key val)) (format t \"key: ~a val: ~a~\u0026\" key val) h) ;; key: A val:1 ;; key: B val:2 ;; NIL dohash dohash 是第三方库trivial-do的一个macro,类似dolist (dohash (key value h) (format t \"key: ~A, value: ~A ~%\" key value)) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:7","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"并行的在两个list上循环 loop (loop for x in '(a b c) for y in '(1 2 3) collect (list x y)) ;; ((A 1) (B 2) (C 3)) 如果想返回一个平整过的list(flat list),使用nconcing 替代collect: (loop for x in '(a b c) for y in '(1 2 3) nconcing (list x y)) ;; (A 1 B 2 C 3) 如果两个list的长度不同，会在短的结束的时候退出循环 (loop for x in '(a b c) for y in '(1 2 3 4 5) collect (list x y)) ;; ((A 1) (B 2) (C 3)) 我们可以在一个大的list上循环，并且手动的通过index访问小一点的List的元素,但是这样的效率是非常低的，我们可以让loop自动拓展短的list (loop for y in '(1 2 3 4 5) for x-list = '(a b c) then (cdr x-list) for x = (or (car x-list) 'z) collect (list x y)) ;; ((A 1) (B 2) (C 3) (Z 4) (Z 5)) 在这个代码段中，for … = … then (cdr …) 在每一次的循环中都会缩短一次list. 他的值一开始是’(a b c) 然后是 ‘(b c) 然后 ‘(c) 最后 nil mapcar (mapcar (lambda (x y) (list x y)) '(a b c) '(1 2 3)) ;; ((A 1) (B 2) (C 3)) 或者更简单: (mapcar #'list '(a b c) '(1 2 3)) ;; ((A 1) (B 2) (C 3)) 返回一个flat list: (mapcan (lambda (x y) (list x y)) '(a b c)) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:8","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"嵌套循环(Nested loops) loop (loop for x from 1 to 3 collect (loop for y from 1 to x collect y)) ;;((1) (1 2) (1 2 3)) 如果要返回一个flat list,使用nconcing 替换第一个collect ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:9","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"计算一个中间值 使用= 与 for结合 (loop for x from 1 to 3 for y = (* x 10) collect y) ;; (10 20 30) 如果使用with,那么只会计算一次 (loop for x from 1 to 3 for y = (* x 10) with z = x collect (list x y z)) ;; ((1 10 1) (2 20 1) (3 30 1)) HyperSpec 对 with 的定义时这样的 with-clause::= with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}* 所以我们可以再=前面指明类型 并且用and 串起来 (loop for x from 1 to 3 for y integer = (* x 10) with z integer = x collect (list x y z)) (loop for x upto 3 with foo = :foo and bar = :bar collect list (x foo bar)) 我们也可以给for 一个 then 让他没次迭代都执行一次 (loop repeat 3 for intermediate = 10 then (incf intermediate) do (print intermediate)) 10 11 12 这里是一个在bool值之间不断切换的例子 (loop repeat 4 for up = t then (not up) do (print up)) T NIL T NIL ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:10","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"循环计数器 loop 对一个List进行迭代的同时进行计数。list的长度决定了迭代合适结束。 (loop for x in '(a b c d e) for y from 1 when (\u003e y 1) do (format t \", \") do (format t \"~A\" x)) A,B,C,D,E NIL 也可以用if语句 (loop for x in '(a b c d e) for y from 1 if (\u003e y 1) do (format t \", ~A\" x) else do (format t \"~A\" x)) A,B,C,D,E NIL ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:11","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"升降序，limits loop 升序 from… to…: include the last (loop for i from 0 to 10 do (print i)) ;; 0 1 2 3 4 5 6 7 8 9 10 from… below…: not include the last (loop for i from 0 below 10 do (print i)) ;; 0 1 2 3 4 5 6 7 8 9 降序 from… downto…: include (loop for i from 10 downto 0 do (print i)) ;; 10 9 8 7 6 5 4 3 2 1 0 from… above…: not include (loop for i from 10 above 0 do (print i)) ;; 10 9 8 7 6 5 4 3 2 1 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:12","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"步长 loop loop 使用by: (loop for i from 1 to 10 by 2 do (print i)) 如果by后面跟的是一个表达式那么只会执行一次 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:13","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"Loop 和条件 loop 使用if, else 和 finally: (loop repeat 10 for x = (random 100) if (evenp x) collect x into evens else collect x into odds finally (return (values evens odds))) (42 82 24 92 92) (55 89 59 13 49) 如果要结合多个语句，那么if的body需要and关键字(and do, and count) (loop repeat 10 for x = (random 100) if (evenp x) collect x into evens and do (format t \"~a is even!~%\" x) else collect x into odds and count t into n-odds finally (return (values evens odds n-odds))) 46 is even! 8 is even! 76 is even! 58 is even! 0 is even! (46 8 76 58 0) (7 45 43 15 69) 5 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:14","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"用一个语句作为loop的开始(initially) (loop initially (format t \"~a \" 'loop-begin) for x below 3 do (format t \"~a \" x)) ;;LOOP-BEGIN 0 1 2 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:15","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"用一个test（until,while）来结束循环 loop until (loop for x in '(1 2 3 4 5) until (\u003e x 3) collect x) ;; (1 2 3) while (loop for x in '(1 2 3 4 5) while (\u003c x 4) collect x) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:16","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"循环命名 和 提前退出 loop loop named foo 语法允许你创建一个能够提前退出的循环。使用return-form,即可退出已经命名的循环，甚至可以退出嵌套的循环。 (loop named loop-1 for x from 0 to 10 by 2 do (loop for y from 0 to 100 by (1+ (random 3)) when (\u003c x y) do (return-from loop-1 (values x y)))) 0 2 有的时候你想要提前退出，但是一定要执行一些语句，你可以使用loop-finish (loop for x from 0 to 100 do (print x) when (\u003e= x 3) return x finally (print :done)) ;; 0 ;; 1 ;; 2 ;; 3 ;; 3 (loop for x from 0 to 100 do (print x) when (\u003e= x 3) do (loop-finish) finally (print :done) (return x)) ;; 0 ;; 1 ;; 2 ;; 3 ;; :DONE ;; 3 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:17","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"Loop thereis never always thereis (loop for x in '(foo 2) thereis (numberp x)) T never (loop for x in '(foo 2) never (numberp x)) NIL always (loop for x in '(foo 2) always (numberp x)) NIL 他们和some,notany,every对应： (some #'numberp '(foo 2)) (notany #'numberp '(foo 2)) (every #'numberp '(foo 2)) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:18","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"Count (loop for i from 1 to 3 count (oddp i)) ;; 2 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:19","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"Summation (loop for i from 1 to 3 sum (* i i )) ;; 14 将求和的结果放入变量中 (loop for i from 1 to 3 sum (* i i) into total do (print i) finally (print total)) 1 2 3 14 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:20","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"Max and Min (loop for i from 1 to 3 maximize (mod i 3)) ;; 2 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:21","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"解构, 对 list 进行dotted pairs aka 模式匹配 (loop for (a b) in '((x 1) (y 2) (z 3)) collect (list b a)) ;; ((1 X) (2 Y) (3 Z)) (loop for (x . y) in '((1 . a) (2 . b) (3 . c)) collect y) ;; (A B C) 使用nil忽略 (loop for (a nil) in '((x 1) (y 2) (z 3)) collect a) ;; (X Y Z) 两个两个的遍历 (loop for (key value) on '(a 2 b 2 c 3) by #'cddr collect (list key (* 2 value))) ;;((A 2) (B 4) (C 6)) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:2:22","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"common-lisp 中与number相关的知识点","date":"2022-04-22","objectID":"/numbers/","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"integer types CL 提供一个true integer类型，叫bignum,只受内存控制。 为了效率考虑，integers 可以被限制成fixnum type。integers 的范围可以这样查看 most-positive-fixnum 4611686018427387903 most-negative-fixnum -4611686018427387904 integer 相关的函数有 isqrt, 返回小于且最接近于指定数的平方根 (isqrt 10) ;; =\u003e 3 (isqurt 4) ;; =\u003e 2 gcd 返回最大的公分母 lcm 返回最小的公倍数 CL还提供了表示16进制和其他进制的方法 #xFF ;; =\u003e 255 #2r1010 ;; =\u003e 10 #4r33 ;; =\u003e 15 #8r11 ;; =\u003e 9 #16rFF ;; =\u003e 255 #36rz ;; =\u003e 35 ","date":"2022-04-22","objectID":"/numbers/:1:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"有理数 ratio 类型由两个bignums组成 * (/ (1+ (expt 2 100)) (expt 2 100)) 1267650600228229401496703205377/1267650600228229401496703205376 ratio 是 rational 的子类型 ","date":"2022-04-22","objectID":"/numbers/:2:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"浮点类型 CL 提供精度由小到大排列的short-float, single-float, double-float, and long-float 类型 常量short-float-epsilon, single-float-epsilon, double-float-epsilon and long-float-epsilon 表示了浮点类型的精度 ","date":"2022-04-22","objectID":"/numbers/:3:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"floating point literals (浮点字面量) *read-default-float-format*控制了浮点数读取的默认类型，默认是single-float,如果你想读入双精度的浮点数，你需要d0后缀 (type-of 1.24) ;; =\u003e SINGLE-FLOAT (type-of 1.24d0) ;; =\u003e DOUBLE-FLOAT Other suffixes are s (short), f (single float), d (double float), l (long float) and e (default; usually single float). 默认的type 是可以修改的 (setq *read-default-float-format* 'double-float) (type-of 1.24) ;; =\u003e DOUBLE-FLOAT warning 和其他语言不同的是，在十进制后面加小数点并不能将该数表示成浮点数 (type-of 10.) ;; =\u003e (INTEGER 0 4611686018427387903) (type-of 10.0) ;; =\u003e SINGLE-FLOAT ","date":"2022-04-22","objectID":"/numbers/:3:1","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"Float point errors 这个错误一般发生在小数点溢出的时候 (exp 1000) ;; Evaluation aborted on #\u003cFLOATING-POINT-OVERFLOW {10041720B3}\u003e. 这个错误可以被捕获和解决，或者他的行为可以被改变 (sb-int:set-floating-point-modes :traps '(:INVALID :DIVIDE-BY-ZERO)) (exp 1000) ;; =\u003e #.SB-EXT:SINGLE-FLOAT-POSITIVE-INFINITY (/ 1 (exp 1000)) ;; =\u003e 0.0 现在不会报任何的错误 在sbcl中，float-point 的模式可以被检查 (sb-int:get-floating-point-modes) ;; =\u003e (:TRAPS (:OVERFLOW :INVALID :DIVIDE-BY-ZERO) :ROUNDING-MODE :NEAREST ;; :CURRENT-EXCEPTIONS NIL :ACCRUED-EXCEPTIONS NIL :FAST-MODE NIL) ","date":"2022-04-22","objectID":"/numbers/:3:2","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"高精度计算 quicklisp 中有一个computable-reals库用于高精度计算 (ql:quickload :computable-reals) (use-package :computable-reals) (sqrt-r 2) ;; =\u003e +1.41421356237309504880... (sin-r (/r +pi-r+ 2)) ;; =\u003e +1.00000000000000000000... ","date":"2022-04-22","objectID":"/numbers/:3:3","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"复数 see https://lispcookbook.github.io/cl-cookbook/numbers.html#complex-types ","date":"2022-04-22","objectID":"/numbers/:4:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"Rounding floating-point and rational numbers ceiling,floor,round 和 truncate 可以将float数转换成integer. see https://lispcookbook.github.io/cl-cookbook/numbers.html#reading-numbers-from-strings ","date":"2022-04-22","objectID":"/numbers/:5:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"比较数字 这个真的没啥要将的，除了lisp使用前缀表达式。 直接看common lisp cookbook吧 see https://lispcookbook.github.io/cl-cookbook/numbers.html#comparing-numbers ","date":"2022-04-22","objectID":"/numbers/:6:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"随机数 random 函数用来生成随机数 (random 10) ;; =\u003e 7 (type-of (random 10)) ;; =\u003e (INTEGER 0 4611686018427387903) (type-of (random 10.0)) ;; =\u003e SINGLE-FLOAT (type-of (random 10d0)) ;; =\u003e DOUBLE-FLOAT 随机种子被存放在*random-state*中 使用make-random-state可以生成新的随机状态 如果想时候相同的随机集合多次，可以使用(make-random-state nil) (dotimes (i 3) (let ((*random-state* (make-random-state nil))) (format t \"~a~%\" (loop for i from 0 below 10 collecting (random 10))))) (8 3 9 2 1 8 0 0 4 1) (8 3 9 2 1 8 0 0 4 1) (8 3 9 2 1 8 0 0 4 1) ","date":"2022-04-22","objectID":"/numbers/:7:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"按位操作 这个地方common lisp cookbook 写的很好 see https://lispcookbook.github.io/cl-cookbook/numbers.html#bit-wise-operation ","date":"2022-04-22","objectID":"/numbers/:8:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"有关common-lisp string的知识以及操作","date":"2022-04-22","objectID":"/strings/","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"你应该知道，string 在 common lisp 中它既是arrays 也是 sequences. 也就是说，arrays 和 sequences的操作都可以应用在string上。如果你找不到某个string特有的函数，你应该去找一找arrays 和 sequences的函数。 还有一些额外的libraries 托管在 quicklisp上，这里只给出英文介绍 ASDF3, which is included with almost all Common Lisp implementations, includes Utilities for Implementation- and OS- Portability (UIOP), which defines functions to work on strings (strcat, string-prefix-p, string-enclosed-p, first-char, last-char, split-string, stripln). Some external libraries available on Quicklisp bring some more functionality or some shorter ways to do. str defines trim, words, unwords, lines, unlines, concat, split, shorten, repeat, replace-all, starts-with?, ends-with?, blankp, emptyp, … Serapeum is a large set of utilities with many string manipulation functions. cl-change-case has functions to convert strings between camelCase, param-case, snake_case and more. They are also included into str. mk-string-metrics has functions to calculate various string metrics efficiently (Damerau-Levenshtein, Hamming, Jaro, Jaro-Winkler, Levenshtein, etc), and cl-ppcre can come in handy, for example ppcre:replace-regexp-all. See the regexp section. Last but not least, when you’ll need to tackle the format construct, don’t miss the following resources: the official CLHS documentation a quick reference a CLHS summary on HexstreamSoft plus a Slime tip: type C-c C-d ~ plus a letter of a format directive to open up its documentation. Again more useful with ivy-mode or helm-mode. ","date":"2022-04-22","objectID":"/strings/:0:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"创建 字符串 最简单的，我们可以使用双引号创建string.但是其实我们还有别的方法: 使用format nil (defparameter person \"you\") (format nil \"hello ~a\" person) ;; =\u003e \"hello you\" make-string count 创建指定长度的字符串。 :initial-element 字符会被重复count次 (make-string 3 :initial-element #\\♥) ;; =\u003e \"♥♥♥\" ","date":"2022-04-22","objectID":"/strings/:1:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"访问子串 string 是一个sequence,你可以使用subseq 来访问它的子串 先给出一个比较易懂的签名 (subseq my-string start end) 这里是调用 * (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* * (subseq *my-string* 8) \"Marx\" * (subseq *my-string* 0 7) \"Groucho\" * (subseq *my-string* 1 5) \"rouc\" 也可以像序列那样用setf 和 subseq 配合来操作字符串 * (defparameter *my-string* (string \"Harpo Marx\")) *MY-STRING* * (subseq *my-string* 0 5) \"Harpo\" * (setf (subseq *my-string* 0 5) \"Chico\") \"Chico\" * *my-string* \"Chico Marx\" string isn`t stretchable 字符串的长度是不可变的，如果新的子串的长度和原始子串的长度不同，短的那一个将决定多少个字符将被替换， * (defparameter *my-string* (string \"Karl Marx\")) *MY-STRING* * (subseq *my-string* 0 4) \"Karl\" * (setf (subseq *my-string* 0 4) \"Harpo\") \"Harpo\" * *my-string* \"Harp Marx\" * (subseq *my-string* 4) \" Marx\" * (setf (subseq *my-string* 4) \"o Marx\") \"o Marx\" * *my-string* \"Harpo Mar\" ","date":"2022-04-22","objectID":"/strings/:2:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"访问单个字符 char函数专门用来访问字符串中的单个字符，char也可以和setf配合使用 (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (char *my-string* 11) #\\x (char *my-string* 7) #\\Space (char *my-string* 6) #\\o (setf (char *my-string* 6) #\\y) #\\y *my-string* \"Grouchy Marx\" 还有一个schar也可以做到同样的事情，但是在特定情况下，schar会更快一些 因为strings 既是 arrays 也是 sequence. 你也可以用更加通用的aref 和 elt (但是char的效率会更高) (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (aref *my-string* 3) #\\u (elt *my-string* 8) #\\M ","date":"2022-04-22","objectID":"/strings/:3:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"从string中删除和替换 可以使用 sequence的函数来对string中的子串进行删除和替换操作 从string中删除一个字符 (remove #\\o \"Harpo Marx\") \"Harp Marx\" (remove #\\a \"Harpo Marx\") \"Hrpo Mrx\" (remove #\\a \"Harpo Marx\" :start 2) \"Harpo Mrx\" (remove-if #'upper-case-p \"Harpo Marx\") \"arpo arx\" 使用substitute(non destructive) 或者 replace (destructive) 来替换一个字符 (substitute #\\u #\\o \"Groucho Marx\") \"Gruuchu Marx\" (substitute-if #\\_ #'upper-case-p \"Groucho Marx\") \"_roucho _arx\" (defparameter *my-string* (string \"Zeppo Marx\")) *MY-STRING* (replace *my-string* \"Harpo\" :end1 5) \"Harpo Marx\" *my-string* \"Harpo Marx\" ","date":"2022-04-22","objectID":"/strings/:4:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"拼接字符串 (Concatenating string) concatenate 是sequence的通用函数，在对string进行操作时，应该指定返回值的类型 (concatenate 'string \"karl\" \" \" \"Marx\") ;; =\u003e \"Karl Marx\" (concatenate 'list \"Karl\" \" \" \"Marx\") ;; =\u003e (#\\K #\\a #\\r #\\l #\\Space #\\M #\\a #\\r #\\x) 使用UIOP库的话，可以用strcat: (uiop:strcat \"karl\" \" \" marx\") 或者是str library 使用concat: (str:concat \"foo\" \"bar\") ","date":"2022-04-22","objectID":"/strings/:5:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"一次操作一个字符 使用Map函数一次操作一个字符 (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (map 'string #'(lambda (c) (print c)) *my-string*) #\\G #\\r #\\o #\\u #\\c #\\h #\\o #\\Space #\\M #\\a #\\r #\\x \"Groucho Marx\" 或者使用loop 函数 (loop for char across \"Zeppo\" collect char) (#\\Z #\\e #\\p #\\p #\\o) ","date":"2022-04-22","objectID":"/strings/:6:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"根据word 或 character翻转string 使用reverse (或者destructive 版的 nreverse) 来根据character反转字符串 (defparameter *my-string* (string \"DSL\")) *MY-STRING* (reverse *my-string*) \"LSD\" 在CL中 没有直接根据word反转字符串的函数，你可以使用第三方库 比如SPLIT-SEQUENCE 或者你自己实现一套解决方案 我们可以使用str库 (defparameter *singing* \"singing in the rain\") *SINGING* (str:words *SINGING*) ;; =\u003e (\"singing\" \"in\" \"the\" \"rain\") (str:unwords (reverse (str:words *singing*))) ;; =\u003e \"rain the in singing\" ","date":"2022-04-22","objectID":"/strings/:7:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"Breaking strings into graphenes,sentences,lines and words These functions use SBCL’s sb-unicode: they are SBCL specific. sb-unicode:sentences 将string 以段落切割，根据他默认的段落分割规则 sb-unicode:lines 将string 分割成行（长度不会超过:margin 指定的参数 默认80） (sb-unicode:lines \"A first sentence. A second somewhat long one.\" :margin 10) ;; =\u003e (\"A first\" ;; \"sentence.\" ;; \"A second\" ;; \"somewhat\" ;; \"long one.\") sb-unicode:words 和 sb-unicode:graphenes 可以自己去查看 确保运行在sbcl中 #+sbcl (runs on sbcl) #-sbcl (runs on other implementations) ","date":"2022-04-22","objectID":"/strings/:8:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"Controlling Case 控制大小写 Common lisp 提供了大量的函数来控制字符串的大小写 (string-upcase \"cool\") ;; =\u003e \"COOL\" (string-upcase \"Cool\") ;; =\u003e \"COOL\" (string-downcase \"COOL\") ;; =\u003e \"cool\" (string-downcase \"Cool\") ;; =\u003e \"cool\" (string-capitalize \"cool\") ;; =\u003e \"Cool\" (string-capitalize \"cool example\") ;; =\u003e \"Cool Example\" 这些函数可以接受:start 和 :key 所以你可以只对字符串的指定部分进行操作。 这些函数也有destructive的版本都以n开头 (string-capitalize \"cool example\" :start 5) ;; =\u003e \"cool Example\" (string-capitalize \"cool example\" :end 5) ;; =\u003e \"Cool example\" (defparameter *my-string* (string \"BIG\")) ;; =\u003e *MY-STRING* (defparameter *my-downcase-string* (nstring-downcase *my-string*)) ;; =\u003e *MY-DOWNCASE-STRING* *my-downcase-string* ;; =\u003e \"big\" *my-string* ;; =\u003e \"big\" warning 对于 string-upcase,string-downcase 和 string-capitalize,string 是没有被修改的。但是如果在string中没有任何字符需要转换，那么返回值有可能是源string 或者 源string的副本 tips 在CL中 n开头的函数一般是destructive的 ","date":"2022-04-22","objectID":"/strings/:9:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"使用format函数控制 To lower case: (format t \"~(~a~)\" \"HELLO WORLD\") ;; =\u003e hello world Capitalize every word: (format t \"~:(~a~)\" \"HELLO WORLD\") ;; =\u003e Hello World Capitalize the first word: (format t \"~@(~a~)\" \"hello world\") ;; =\u003e Hello world To upper case (format t \"~@:(~a~)\" \"hello world\") ;; =\u003e HELLO WORLD ","date":"2022-04-22","objectID":"/strings/:9:1","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"将字符串左右的空格截掉 其实不单单可以截掉空格，还可以丢弃一些不需要的字符。string-trim,string-left-trim,string-right-trim 返回一个子串，子串不包含第一个参数中的字符。 (string-trim \" \" \" trim me \") ;; =\u003e \"trim me\" (string-trim \" et\" \" trim me \") ;; =\u003e \"rim m\" (string-left-trim \" et\" \" trim me \") ;; =\u003e \"rim me \" (string-right-trim \" et\" \" trim me \") ;; =\u003e \" trim m\" (string-right-trim '(#\\Space #\\e #\\t) \" trim me \") ;; = \u003e\" trim m\" (string-right-trim '(#\\Space #\\e #\\t #\\m) \" trim me \") ","date":"2022-04-22","objectID":"/strings/:10:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在symbol 和 字符串之间转换 intern 将string转化成symbol (in-package \"COMMON-LISP-USER\") ;; =\u003e #\u003cThe COMMON-LISP-USER package, 35/44 internal, 0/9 external\u003e (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL ;; =\u003e:INTERNAL (export 'MY-SYMBOL) ;; =\u003e T (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL ;; =\u003e :EXTERNAL (intern \"My-Symbol\") ;; =\u003e |My-Symbol| ;; =\u003e NIL (intern \"MY-SYMBOL\" \"KEYWORD\") ;; =\u003e :MY-SYMBOL ;; =\u003e NIL (intern \"MY-SYMBOL\" \"KEYWORD\") ;; =\u003e :MY-SYMBOL ;; =\u003e :EXTERNAL symbol-name 和 string 将symbol 转换成 string (symbol-name 'MY-SYMBOL) ;; =\u003e \"MY-SYMBOL\" (symbol-name 'my-symbol) ;; =\u003e \"MY-SYMBOL\" (symbol-name '|my-symbol|) ;; =\u003e \"my-symbol\" (string 'howdy) ;; =\u003e \"HOWDY\" ","date":"2022-04-22","objectID":"/strings/:11:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在string 和 character之间转换 coerce 将string(长度为1)转换成character. (coerce \"a\" 'character) ;; =\u003e #\\a (coerce (subseq \"cool\" 2 3) 'character) ;; =\u003e #\\o coerce 将字符串转换中字符list (coerce \"cool\" 'list) ;; =\u003e (#\\c #\\o #\\o #\\l) coerce 将字符list转换成string (coerce '(#\\h #\\e #\\y) 'string) ;; =\u003e \"hey\" coerce 将array 转换成string (defparameter *my-array* (make-array 5 :initial-element #\\x)) ;; =\u003e *MY-ARRAY* *my-array* ;; =\u003e #(#\\x #\\x #\\x #\\x #\\x) (coerce *my-array* 'string) ;; =\u003e \"xxxxx\" ","date":"2022-04-22","objectID":"/strings/:12:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在string中寻找一个元素 使用find,position 和他们的-if后缀的函数 查找string中的character (find #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e #\\t (find #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e #\\T (find #\\z \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e NIL (find-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;;=\u003e #\\1 (find-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :from-end t) ;; =\u003e #\\0 (position #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e 17 (position #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e 0 (position-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;; =\u003e 37 (position-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :from-end t) ;; =\u003e 43 使用count族函数计算字符在字符串中出现的次数 (count #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e 2 (count #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e 3 (count-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;; =\u003e 6 (count-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :start 38) ;; =\u003e 5 ","date":"2022-04-22","objectID":"/strings/:13:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在字符串中查找一个子串 (search \"we\" \"If we can't be free we can at least be cheap\") ;; =\u003e 3 (search \"we\" \"If we can't be free we can at least be cheap\" :from-end t) ;; =\u003e 20 (search \"we\" \"If we can't be free we can at least be cheap\" :start2 4) ;; =\u003e 20 (search \"we\" \"If we can't be free we can at least be cheap\" :end2 5 :from-end t) ;; =\u003e 3 (search \"FREE\" \"If we can't be free we can at least be cheap\") ;; =\u003e NIL (search \"FREE\" \"If we can't be free we can at least be cheap\" :test #'char-equal) ;; =\u003e 15 ","date":"2022-04-22","objectID":"/strings/:14:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"将string 转换成number to integer 会返回两个值，一个是被转换后的值，另一个是转换停止的位置 (parse-integer \"42\") ;; =\u003e 42 ;; =\u003e 2 (parse-integer \"42\" :start 1) ;; =\u003e 2 ;; =\u003e 2 (parse-integer \"42\" :end 1) ;; =\u003e 4 ;; =\u003e 1 (parse-integer \"42\" :radix 8) ;; =\u003e 34 ;; =\u003e2 (parse-integer \" 42 \") ;; =\u003e 42 ;; =\u003e 3 (parse-integer \" 42 is forty-two\" :junk-allowed t) ;; =\u003e 42 ;; =\u003e 3 (parse-integer \" 42 is forty-two\") Error in function PARSE-INTEGER: There's junk in this string: \" 42 is forty-two\". 转换成任意number: read-from-string (read-from-string \"#X23\") ;; =\u003e 35,4 (read-from-string \"4.5\") ;; =\u003e 4.5,3 (read-from-string \"6/8\") ;; =\u003e 3/4,3 (read-from-string \"#C(6/8 1)\") ;; =\u003e #C(3/4 1),9 (read-from-string \"1.2e2\") ;; =\u003e 120.00001,5 (read-from-string \"symbol\") ;; SYMBOL.6 (defparameter *foo* 42) ;; =\u003e *FOO* (read-from-string \"#.(setq *foo* \\\"gotcha\\\")\") ;; =\u003e \"gotcha\",23 *foo* ;; =\u003e \"gotcha\" ","date":"2022-04-22","objectID":"/strings/:15:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"转换成float parse-float 库提供转换成float的函数 (ql:quickload \"parse-float\") (parse-float:parse-float \"1.2e2\") ;; =\u003e 120.00001,5 ","date":"2022-04-22","objectID":"/strings/:16:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"number 转 string (write-to-string 250) ;; =\u003e \"250\" (write-to-string 250.02) ;; =\u003e \"250.02\" (write-to-string 250 :base 5) ;; =\u003e \"2000\" (write-to-string (/ 1 3)) ;; =\u003e \"1/3\" ","date":"2022-04-22","objectID":"/strings/:17:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"字符串比较 equal 和 equalp 都可以比较两个字符串是否相同，但是equal是大小写敏感的，而equalp不是。还有一些string专用的函数。 (string= \"Marx\" \"Marx\") ;; =\u003e T (string= \"Marx\" \"marx\") ;; =\u003e NIL (string-equal \"Marx\" \"marx\") ;; =\u003e T (string\u003c \"Groucho\" \"Zeppo\") ;; =\u003e 0 (string\u003c \"groucho\" \"Zeppo\") ;; =\u003e NIL (string-lessp \"groucho\" \"Zeppo\") ;; =\u003e 0 (mismatch \"Harpo Marx\" \"Zeppo Marx\" :from-end t :test #'char=) ;; =\u003e 3 ","date":"2022-04-22","objectID":"/strings/:18:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"String formatting see https://lispcookbook.github.io/cl-cookbook/strings.html#string-formatting ","date":"2022-04-22","objectID":"/strings/:19:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"捕获哪些东西被打印进了stream 在(with-output-to-string (mystream) …) 中任何打印进stream中的内容都会被捕获 (defun greet (name \u0026key (stream t)) ;; by default, print to standard output. (format stream \"hello ~a\" name)) (let ((output (with-output-to-string (stream) (greet \"you\" :stream stream)))) (format t \"Output is: '~a'. It is indeed a ~a, aka a string.~\u0026\" output (type-of output))) ;; Output is: 'hello you'. It is indeed a (SIMPLE-ARRAY CHARACTER (9)), aka a string. ;; NIL ","date":"2022-04-22","objectID":"/strings/:20:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"删除标点符号 使用(str:remove-punctuation s) 或者 (str:no-case s) (str:remove-punctuation \"HEY! What's up ??\") ;; \"HEY What s up\" (str:no-case \"HEY! What's up ??\") ;; \"hey what s up\" ","date":"2022-04-22","objectID":"/strings/:21:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"关于common lisp的一些常用数据结构 list sequences hash-table Alist structures Tree Set 介绍及其基本操作","date":"2022-04-19","objectID":"/data_structures/","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Lists ","date":"2022-04-19","objectID":"/data_structures/:1:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Building lists. Cons cells,list list(列表) 也是一个 sequence(序列). list 由cons组成。 cons 有两个cell 一个叫 “car” 一个 叫 “cdr” 我们可以像这样构建一个简单的list (cons 1 2) ;;=\u003e (1 . 2) ;; 这是一个dotted pair 表示一个cons 它的底层结构可以抽象成这样 [o|o]--- 2 | 1 如果第一个cons的cdr 是另一个cons 并且最后一个cons 的cdr 是nil ,那么我们就得到了一个list (cons 1 (cons 2 nil)) ;; =\u003e (1 2) 底层结构是这样的 [o|o]---[o|/] ^ ^ 1 2 为什么不是dotted pair lisp printer 遇到这种结构的时候会自动将逗号省略。但是list还是由一个个dotted pair组成的。 更简单的 可以用list 函数来构建list (list 1 2) ;; =\u003e (1 2) 或者使用一个引用符号' '(1 2) ;; =\u003e (1 2) ","date":"2022-04-19","objectID":"/data_structures/:1:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Circular lists 循环列表 cons 的两个cell 可以 c存放任何值，所以也可以存放自己，或者列表的最后一个元素的cdr存储列表的第一个元素.这个时候就构成了循环列表。 引文最后一个元素的cdr 存的是列表的开始。 在开始之前，我们要将*print-circle* 设为t告诉printer 不要无限答应循环列表。 (setf *print-circle* t) 首先定义一个能构造循环列表的函数 (defun circular! (items) \"Modifies the last cdr of list ITEMS, returning a circular list\" (setf (cdr (last items)) items)) (circular! (list 1 2 3)) (fifth (circular! (list 1 2 3))) ;; =\u003e 2 对于循环列表list-length将会返回nil reader 也可以构建一个循环列表，使用sharpsign equal-sign notation. 一个object(对象) 可以以#n=作为前缀，n是一个无符号十进制整数。可以用#n#去引用已经定义的对象 '#42=(1 2 3 . #42#) ;; =\u003e #1=(1 2 3 . #1#) ","date":"2022-04-19","objectID":"/data_structures/:1:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"car/cdr or first/rest (and second… to tenth) (car (cons 1 2)) ;; return the car cell of a cons. here return 1 (cdr (cons 1 2)) ;; return the cdr cell of a cons.here return 2 (first '(1 2 3 4 5)) ;; return the car of first. here return 1 (second '(1 2 3 4 5)) ;; return the car of second. here return 2 (third '(1 2 3 4 5)) ;; return the car of third. here return 3 . . . (tenth '(1 2 3 4 5 6 7 8 9 10)) ;; return the car of tenth. here return 10 (rest '(rest)) ;; return (2 3) rest return cdr of the first cons setf 可以用来给列表中的元素赋值 (defparameter ll '(1 2 3 4)) (setf (first ll) 2) ll ;; now ll is (2 2 3 4) ","date":"2022-04-19","objectID":"/data_structures/:1:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"last,butlast,nbutlast(\u0026optional n) (last '(1 2 3)) ;; return last of cons of (1 2 3). here return (3) ;; =\u003e (3) (car (last '(1 2 3))) ;; or (first (last ...)) ;; =\u003e 3 (butlast '(1 2 3));; return the list except the last ;; =\u003e (1 2) ","date":"2022-04-19","objectID":"/data_structures/:1:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"reverse,nreverse 倒序 reverse 和 nreverse 都返回一个新的序列(sequence) nreverse 是毁灭性的(destructive)。前缀 n 代表 non-consing,代表他是直接在原有List上进行修改。 (defparameter mylist '(1 2 3)) ;; =\u003e (1 2 3) (reverse mylist) ;; =\u003e (3 2 1) mylist ;; =\u003e (1 2 3) (nreverse mylist) ;; =\u003e (3 2 1) mylist ;; =\u003e (1) in SBCL but implementation dependent. destructive 如果一个函数会修改他的他的操作元素 我们就说他是destructive的 ","date":"2022-04-19","objectID":"/data_structures/:1:5","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"append append 会将两个list合并成一个list (append (list 1 2) (list 3 4)) ;; =\u003e (1 2 3 4) append 的坑 append 返回的List会共享原有的list的cons 所以在其返回的list进行修改，也会影响原有的list ","date":"2022-04-19","objectID":"/data_structures/:1:6","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"push (item,place) push 是destructive的 他会将新的元素插入list的最前面 (defparameter mylist '(1 2 3)) (push 0 mylist) ;;=\u003e (0 1 2 3) mylist ;;=\u003e (0 1 2 3) (defparameter x ’(a (b c) d)) ;; =\u003e (A (B C) D) (push 5 (cadr x)) ;; =\u003e (5 B C) x ;; =\u003e (A (5 B C) D) CL 没有默认的尾插函数，如果想要尾插你可以先将list 进行 reverse 或者使用别的数据结构 ","date":"2022-04-19","objectID":"/data_structures/:1:7","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"pop pop 是 desctructive 和 push 相对 push 会往里面插入 而pop会将最前面的元素返回并删除 ","date":"2022-04-19","objectID":"/data_structures/:1:8","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"nthcdr (index ,list) 返回第n个cons 的 cdr。 (defparameter mylist '(1 2 3)) (nthcdr 1 mylist) ;; =\u003e (2) ","date":"2022-04-19","objectID":"/data_structures/:1:9","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"复合的car 和 cdr 我们可以复合 a 和 d 来做一些方便的操作。比如cadr 就是 返回 the car of cdr caar 就是返回 the car of car 这些操作通常在嵌套list中有些意义 (caar (list 1 2 3));; ==\u003e error (caar (list (list 1 2) 3)) ;; ==\u003e 1 (cadr (list (list 1 2) (list 3 4))) ;; ==\u003e (3 4) (caadr (list (list 1 2) (list 3 4))) ;; == \u003e 3 ","date":"2022-04-19","objectID":"/data_structures/:1:10","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"destructuring-bind (parameter*,list) 这个函数将List中的元素与参数绑定，我们可以析构tree,plists (destructuring-bind (x y z) (list 1 2 3) (list :x x :y y :z z)) ;; =\u003e (:X 1 :Y 2 :Z 3) 内部的sublist也可以绑定 (destructuring-bind (x (y1 y2) z) (list 1 (list 2 20) 3) (list :x x :y1 y1 :y2 y2 :z z)) ;; =\u003e (:X 1 :Y1 2 :Y2 20 :Z 3) parameter list 还可以用\u0026optional,\u0026rest 和 \u0026key (destructuring-bind (x (y1 \u0026optional y2) z) (list 1 (list 2) 3) (list :x x :y1 y1 :y2 y2 :z z)) ;; =\u003e (:X 1 :Y1 2 :Y2 NIL :Z 3) (destructuring-bind (\u0026key x y z) (list :z 1 :y 2 :x 3) (list :x x :y y :z z)) ;; =\u003e (:X 3 :Y 2 :Z 1) \u0026whole parameter 会被绑定到整个list. 他必须再第一个 其余的参数必须在它后面 (destructuring-bind (\u0026whole whole-list \u0026key x y z) (list :z 1 :y 2 :x 3) (list :x x :y y :z z :whole whole-list)) ;; =\u003e (:X 3 :Y 2 :Z 1 :WHOLE (:Z 1 :Y 2 :X 3)) ","date":"2022-04-19","objectID":"/data_structures/:1:11","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"null,listp 断言 null 和 not 相同，但是看起来更好 用来判断一个列表是否为空 listp 判断一个对象是否是一个cons cell ","date":"2022-04-19","objectID":"/data_structures/:1:12","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"ldiff,tailp,list*,make-list,fill,revappend,nreconc,consp,atom 只介绍几个常用的，其余的可以去查文档（太多了，不想写（小声bb） 很多其实不常用，就不写了） make-list 构造一个list (make-list 3 :initial-element \"ta\") ;; =\u003e (\"ta\" \"ta\" \"ta\") fill 用指定对象填充list (make-list 3) ;; =\u003e (NIL NIL NIL) (fill * \"hello\") ;; =\u003e (\"hello\" \"hello\" \"hello\") tailp 用来判断是否有共享的列表结构，也就是是否有相同的cons cell(use EQL for predicate),而不仅仅是cons cell的内容 (tailp t '(1 2 3 4 . t)) ;; =\u003e T (tailp nil '(1 2 3 4 . nil)) ;; =\u003e T (tailp nil '(1 2 3 4)) ;; =\u003e T (tailp #1=\"e\" '(1 2 3 4 . #1#)) ;; =\u003e T (defparameter *tail* (list 3 4 5)) (defparameter *larger* (list* 1 2 *tail*)) (defparameter *replica* (copy-list *larger*)) (tailp *tail* *replica*) ;; ==\u003e nil (tailp *tail* *larger*) ;; ==\u003e t ","date":"2022-04-19","objectID":"/data_structures/:1:13","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"member (elt,list) 返回以elt开始的剩下的元素 默认使用eql作为比较函数 接受:test :test-not :key(functions or symbols) (member 2 '(1 2 3)) ","date":"2022-04-19","objectID":"/data_structures/:1:14","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"替换tree中的对象:subst,sublis subst 和 subst-if 在tree中查找所有和element相同的元素 并 用另一个element 替换 (可以用:test 指定判断相同的函数) (subst 'one 1 '(1 2 3)) ;; =\u003e (one 2 3) (subst '(1 . one) '(1 . 1) '((1 . 1) (2 . 2) (3 . 3)) :test #'equal) ;; ((1 . ONE) (2 . 2) (3 . 3)) sublis 第一个参数是一个list(每个元素都是一个 dot list),每个dot list 有2个元素(x . y) 表示将 x 替换 为 y sublis 接受:test 和 :key 参数 :test 是一个接受key 和 subtree为参数的函数 (sublis '((t . \"foo\")) (\"one\" 2 (\"three\" (4 5))) :key #'stringp) ;; (\"foo\" 2 (\"foo\" (4 5))) ","date":"2022-04-19","objectID":"/data_structures/:1:15","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Sequences 序列 lists vectors strings 都是序列 大多数和序列有关的函数都接受keyword 参数。所有keyword 参数都是可选的，并且可以以任意顺序出现 :test参数默认使用eql (对于strings 来说 用:equal) :key 参数可以接受nil 和 单参数的函数（这个函数声明了我们具体要怎么看待序列中的每个元素） (defparameter my-alist (list (cons 'foo \"foo\") (cons 'bar \"bar\"))) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) (find 'bar my-alist) ;; =\u003e NIL (find 'bar my-alist :key 'car) ","date":"2022-04-19","objectID":"/data_structures/:2:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"断言: every , some…. every 的作用是判断列表中的元素是否都满足某个条件 (都满足就返回真) (defparameter foo '(1 2 3)) (every #'evenp foo) ;; =\u003e NIL some 则只需要一些元素满足条件即可 (一些满足就返回真) (defparameter foo '(1 2 3)) (every #'evenp foo) ;; =\u003e NIL notany 只要不是所有都满足就返回真 ","date":"2022-04-19","objectID":"/data_structures/:2:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"常用函数 alexandria库 《common lisp cookbook》中一直提到有一个\"alexandria\"的库里面有很多非常实用的函数，是对common lisp 的一种扩充，可以去看一看 length(sequence) 返回序列的长度 elt(sequence,index) find by index count (foo sequence) 返回 sequence中 出现foo的次数 可接受:from-end,:start,:end 相关的还有count-if,count-not(test-function sequence) subseq (sequence start,[end]) 返回子序列左闭右开[start,end): (subseq (list 1 2 3) 0) ;; (1 2 3) (subseq (list 1 2 3) 1 2) ;; (2) end不能大于( + (length sequence) 1) 因为这样会越界: (defparameter my-list '(1 2 3 4)) (subseq my-list 0 (+ length(my-list) 1)) ;; =\u003e Error: the bounding indices 0 and 5 are bad for a sequence of length 3. 如果果可能越界，用alexandria-2:subseq*: (alexandria-2:subseq* (list 1 2 3) 0 99) subseq 是\"setf\" able 的 但是只有当新的序列的长度和要被替换的序列长度一致的时候才会生效 (defparameter my-list '(1 2 3 4)) ;; =\u003e(1 2 3 4) (setf (subseq my-list 0 2) '(2 3)) my-list ;; =\u003e (2 2 3 4) sort,stable-sort(sequence,test[,key function]) 这两个函数时destructive的，所以在排序前，可能会优先使用copy-seq 拷贝一份出来 (sort (copy-seq seq) :test #'string\u003c) 就像名字中说的一样 sort是不稳定的而stable-sort是稳定的 find,position(foo,sequence) - get index also find-if,find-if-not,position-if,position-if-not(test sequence) (find 20 '(10 20 30)) ;; 20 (position 20 '(10 20 30)) ;; 1 search and mismatch (sequence-a, sequence-b) search 会在sequence-b 中寻找和sequence-a 一样的subsequence。他会返回sequence-a 在 sequence-b 中的位置，如果没找到就是nil. 参数有 from-end,end1,end2 以及上面提到的test 和 key (search '(20 30) '(10 20 30 40)) ;; 1 (search '(\"b\" \"c\") '(\"a\" \"b\" \"c\")) ;; nil (search '(\"b\" \"c\") '(\"a\" \"b\" \"c\") :test #'equal) ;;1 (search \"bc\" \"abc\") ;;1 mismatch 返回两个序列开始不一样的地方 (mismatch '(10 20 99) '(10 20 30)) ;; 2 (mismatch \"hellolisper\" \"helloworld\") ;; 5 (mismatch \"same\" \"same\") ;; NIL (mismatch \"foo\" \"bar\") ;; 0 substitute,nsubstitute[if,if-not] 返回一个同类型的序列，这个序列将会用新的元素替代就的元素 (substitute #\\o #\\x \"hellx\") ;; =\u003e \"hello\" (substitute :a :x '(:a :x :x)) ;; =\u003e (:A :A :A) (substitute \"a\" \"x\" '(\"a\" \"x\" \"x\") :test #'string=) ;; =\u003e (\"a\" \"a\" \"a\") replace (sequence-a,sequence-b,\u0026key start1,end1) 破坏性的用sequence-b 中的元素替换sequence-a中的元素 完整的函数签名: (replace sequence1 sequence2 \u0026rest args \u0026key (start1 0) (end1 nil) (start2 0)(end2 nil)) (replace \"xxx\" \"foo\") \"foo\" (replace \"xxx\" \"foo\" :start1 1) \"xfo\" (replace \"xxx\" \"foo\" :start1 1 :start2 1) \"xoo\" (replace \"xxx\" \"foo\" :start1 1 :start2 1 :end2 2) \"xox\" remove,delete(foo sequence) 返回一个不包含foo的新sequence 接受:start/end 和 :count参数 (remove \"foo\" '(\"foo\" \"bar\" \"foo\") :test 'equal) ;; =\u003e (\"bar\") remove-duplicates,delete-duplicates(sequence) 去重操作 delete与remove 不同的地方在于 delete会直接操作原始的sequence 接受 from-end test test-not start end key (remove-duplicates '(:foo :foo :bar)) (:FOO :BAR) (remove-duplicates '(\"foo\" \"foo\" \"bar\")) (\"foo\" \"foo\" \"bar\") (remove-duplicates '(\"foo\" \"foo\" \"bar\") :test #'string-equal) (\"foo\" \"bar\") mapping (map,mapcar,remove-if[-not],…) mapcar 只能用于list 而map 适用于vector list 但是由于map 可以用于多种结构 所以要指定返回值类型实参。(map ’list function vector) mapcar 可以接受多个list 映射操作会在最短的list被操作完是中断 (defparameter foo '(1 2 3)) (map 'list (lambda (it) (* 10 it)) foo) reduce (function,sequence). 首先会将function作用于列表第一个和第二个元素，然后将function作用于这个结果与下一个元素直到处理完所有元素 如果指定了特殊参数:initial-value. 首先就不会将function作用于列表的第一个和第二个元素，而是首先将function作用于:initial-value 和第一个值 (reduce '- '(1 2 3 4)) ;; =\u003e -8 (reduce '- '(1 2 3 4) :initial-value 100) ;; =\u003e 90 Creating lists with variables 由于quote ’ 会保护表达式不被求值，所以我们得用list来新建列表，但是list 函数所有的参数都会先被求值然后再构造成列表. 如果只是想特定的变量被求职，我们可以使用backquote ` 来构造List 先来个正常的quote (defparameter *var* \"bar\") ;; First try: '(\"foo\" *var* \"baz\") ;; no backquote ;; =\u003e (\"foo\" *VAR* \"baz\") ;; nope 再来个backquote `(\"foo\" ,*var* \"baz\") ;; backquote, comma ;; =\u003e (\"foo\" \"bar\" \"baz\") ;; good 在backquote 后面 以comma , 开头的变量会被正常求值 如果变量是一个list的话 (defparameter *var* '(\"bar\" \"baz\")) ;;First try: `(\"foo\" ,*var*) ;; =\u003e (\"foo\" (\"bar\" \"baz\")) ;; nested list `(\"foo\" ,@*var*) ;; =\u003e (\"foo\" \"bar\" \"baz\") ","date":"2022-04-19","objectID":"/data_structures/:2:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"集合操作Set 首先，一个集合不会包含两个同样的元素，并且集合内部是无需的. 大多数函数都有循环利用已经有的变量的函数版本(破坏性的) 区别于正常的 他们以\"n\"开头. 他们都可以接受:key 和 :test 参数 intersection list的交集 (defparameter list-a '(0 1 2 3)) (defparameter list-b '(0 2 4)) (intersection list-a list-b) ;; =\u003e (2 0) set-difference 作差 (set-difference list-a list-b) ;; =\u003e (3 1) (set-difference list-b list-a) ;; =\u003e (4) union 并集 (union list-a list-b) ;; =\u003e (3 1 0 2 4) ;; order can be different in your lisp 补集 set-exclusive-or (set-exclusive-or list-a list-b) ;; =\u003e (4 3 1) adjoin 添加 会返回新的集合，原有集合不会被修改 (adjoin 3 list-a) ;; =\u003e (0 1 2 3) (adjoin 5 list-a) ;; =\u003e (5 0 1 2 3) ;; \u003c-- element added in front. list-a ;; =\u003e (0 1 2 3) ;; \u003c-- original list unmodified. subsetp 是否为子集 (subsetp '(1 2 3) list-a) ;; =\u003e T (subsetp '(1 1 1) list-a) ;; =\u003e T (subsetp '(3 2 1) list-a) ;; =\u003e T (subsetp '(0 3) list-a) ;; =\u003e T ","date":"2022-04-19","objectID":"/data_structures/:2:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Fset-immutable data structure 也可以去quicklisp 看看FSet库 ","date":"2022-04-19","objectID":"/data_structures/:2:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"array 和 vector Arrays 的访问时间复杂度是常数时间的 他们可以是fixed 或者 adjustable的。 一个simple array 既不能被displaced(置换) 也不能被adjust(调整) 更不会有fill-pointer 除非我们用:displaced-to, :adjust-array,:fill-pointer 指定, Vector 不同于 array的地方在于 他的维度只能固定再1维 vector 也是一个序列(sequence) ","date":"2022-04-19","objectID":"/data_structures/:3:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"创建和调整array make-array(sizes-list :adjustable :initial-element ) common lisp 至少可以指定7个维度，买个维度可以至少容纳1023个元素，如果提供了:initial-element 那么这个值会作为初始值 (make-array '(2 3) :initial-element nil) adjust-array(array,sizes-list :element-type : initial-element) adjust-array 用于调整函数的维度 ","date":"2022-04-19","objectID":"/data_structures/:3:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"访问 : aref (array i [j…]) aref (array i j k …) 取指定索引上的元素 row-major-aref(array i) 和 (aref i i i ….) 相同 用来去主轴上的元素 返回的结果都可以被setf 赋值 (defparameter myarray (make-array '(2 2 2) :initial-element 1)) myarray ;; =\u003e #3A(((1 1) (1 1)) ((1 1) (1 1))) (aref myarray 0 0 0) ;; =\u003e 1 (setf (aref myarray 0 0 0) 9) ;; =\u003e 9 (row-major-aref myarray 0) ;; =\u003e 9 ","date":"2022-04-19","objectID":"/data_structures/:3:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"sizes array-total-size(array): 返回array 中一共有多少个元素 array-dimensions(array): 返回array每一维的长度 array-dimension(array i): 返回第i维的长度 array-rank: 返回函数一共有多少维 (defparameter myarray (make-array '(2 2 2))) ;; =\u003e MYARRAY myarray ;; =\u003e #3A(((0 0) (0 0)) ((0 0) (0 0))) (array-rank myarray) ;; =\u003e 3 (array-dimensions myarray) ;; =\u003e (2 2 2) (array-dimension myarray 0) ;; =\u003e 2 (array-total-size myarray) ;; =\u003e 8 ","date":"2022-04-19","objectID":"/data_structures/:3:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Vector 创建vector 可以使用vector 或者读取宏 #(). 他会返回一个simple vector (vector 1 2 3) ;; =\u003e #(1 2 3) #(1 2 3) ;; =\u003e #(1 2 3) vector-push (foo vector): 将fill-pointer 指向的元素替换成foo vector-push-extend (foo vector [extension-num])t: 与vector-push相似，但是如果fill-pointer比较大，他会拓展数组 vector-pop (vector): 返回fill-pointer 指向的元素 并删除 fill-pointer (vector). setfable.: 返回array的fill-pointer and see also the sequence functions. fill-pointer fill-pointer 就是vector-push要push的index位置（或者vector-push-extend）.也叫填充句柄。如果一个元素他的index大于这个fill-pointer 那么他就是active的 如果小于fill-pointer 就是inactive的 ","date":"2022-04-19","objectID":"/data_structures/:3:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Hash Table ","date":"2022-04-19","objectID":"/data_structures/:4:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"创建一个hash table make-hash-table 创建一个hash table。make-hash-table 没有必要参数。:test 参数指定用来判断key是否相同的函数 Note see shorter notations in the Serapeum or Rutils libraries. For example, Serapeum has dict, and Rutils a #h reader macro. ","date":"2022-04-19","objectID":"/data_structures/:4:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"获取hash table 中的元素 gethash 接受两个必要参数 一个要获取的元素的key 一个hash table. 它返回key绑定的value 和 一个bool 值表示是否在hash table中找到这个值. 它还有一个可选参数default 表示找不到时的默认值 (defparameter my-table (make-hash-table)) (gethash 'bar my-table 'default-value) ;; =\u003e default-value,NIL 获取 hashtable中所有的value or key (ql:quickload \"alexandria\") (alexandria:hash-table-keys my-table) ","date":"2022-04-19","objectID":"/data_structures/:4:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"向hash table 添加一个元素 可以使用gethash+setf 向hash table 中添加元素 CL-USER\u003e (defparameter *my-hash* (make-hash-table)) *MY-HASH* CL-USER\u003e (setf (gethash 'one-entry *my-hash*) \"one\") \"one\" CL-USER\u003e (setf (gethash 'another-entry *my-hash*) 2/4) 1/2 CL-USER\u003e (gethash 'one-entry *my-hash*) \"one\" T CL-USER\u003e (gethash 'another-entry *my-hash*) 1/2 T ","date":"2022-04-19","objectID":"/data_structures/:4:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"判断hash table 中某个key是否存在 gethash 的第一个返回值会返回对应key绑定的value 但是有的时候我们可能会刻意让这个value 为 nil。 所以使用第一个返回值是不可靠的。第二个返回值会明确告诉我们这个键值对是否存在，所以判断是否存在可以这样。 (if (nth-value 1 (gethash 'bar my-table)) \"Key exists\" \"Key does not exist\") ","date":"2022-04-19","objectID":"/data_structures/:4:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"从hash table 中删除 remhash (remove-hash的缩写) 专门用来删除一个哈希表条目。当hash table中有这个条目的时候 返回T 否则就返回 NIL (defparameter *my-hash* (make-hash-table)) ;; ==\u003e ,*MY-HASH* (setf (gethash 'first-key *my-hash*) 'one) ;; =\u003e ONE (gethash 'first-key *my-hash*) ;; =\u003e ONE,T (remhash 'first-key *my-hash*) ;; =\u003eT (gethash 'first-key *my-hash*) ;; =\u003e NIL,NIL CL-USER\u003e (gethash 'no-entry *my-hash*) ;; =\u003e NIL,NIL CL-USER\u003e (remhash 'no-entry *my-hash*) ;; =\u003e NIL CL-USER\u003e (gethash 'no-entry *my-hash*) ;; =\u003e NIL,NIL ","date":"2022-04-19","objectID":"/data_structures/:4:5","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"clear a hash table 使用clrhash 清空一个hash table (defparameter my-hash (make-hash-table)) (setf (gethash 'first-key my-hash) 'one) (setf (gethash 'second-key my-hash) 'two) my-hash ;; =\u003e #\u003chash-table :TEST eql :COUNT 2 {10097BF4E3}\u003e (clrhash my-hash) ;; =\u003e #\u003chash-table :TEST eql :COUNT 0 {10097BF4E3}\u003e (gethash 'first-key myhash) ;; =\u003e NIL,NIL (gethash 'second-key myhash) ;; =\u003e NIL,NIL ","date":"2022-04-19","objectID":"/data_structures/:4:6","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"遍历hash table 使用maphash 遍历 (defparameter my-hash (make-hash-table)) (setf (gethash 'first-key *my-hash*) 'one) (setf (gethash 'second-key *my-hash*) 'two) (setf (gethash 'third-key *my-hash*) nil) (setf (gethash nil *my-hash*) 'nil-value) (defun print-hash-entry (key value) (format t \"The value associated with the key ~S is ~S~%\" key value)) (maphash #'print-hash-entry *my-hash*) ;; =\u003e The value associated with the key FIRST-KEY is ONE ;; =\u003e The value associated with the key SECOND-KEY is TWO ;; =\u003e The value associated with the key THIRD-KEY is NIL ;; =\u003e The value associated with the key NIL is NIL-VALUE 使用with-hash-table-iterator with-hash-table-iterator 是一个宏 他会为hash-table 创建迭代器，每次迭代会返回三个返回值 第一个返回值返回是否有这个entry 第二个返回值返回key 第三个返回值返回value 如果遍历到了最后，只会返回一个nil (with-hash-table-iterator (my-iterator my-hash) (loop (multiple-value-bind (entry-p key value) (my-iterator) (if entry-p (print-hash-entry key value) (return))))) ;; =\u003e The value associated with the key FIRST-KEY is ONE ;; =\u003e The value associated with the key SECOND-KEY is TWO ;; =\u003e The value associated with the key THIRD-KEY is NIL ;; =\u003e The value associated with the key NIL is NIL-VALUE ;; =\u003e NIL 遍历keys 或者 values 如果只想遍历keys 或者 values 可以使用Alexandria的maphash-keys 和 maphash-values ","date":"2022-04-19","objectID":"/data_structures/:4:7","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"计算hash table 中的entry 数量 可以使用hash-table-count (defparameter *my-hash* (make-hash-table)) (hash-table-count *my-hash*) ;; =\u003e 0 (setf (gethash 'first *my-hash*) 1) (setf (gethash 'second *my-hash*) 2) (setf (gethash 'third *my-hash*) 3) (hash-table-count *my-hash*) (setf (gethash 'second *my-hash*) 'two) (hash-table-count *my-hash*) ;; =\u003e 3 (clrhash *my-hash*) (hash-table-count *my-hash*) ","date":"2022-04-19","objectID":"/data_structures/:4:8","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"线程安全的hash table common lisp 的标准中，hash-table不是线程安全的，但是在SBCL中，我们可以给make-hash-table传一个 :synchronized 参数来构造一个线程安全的hash table (defparameter *my-hash* (make-hash-table :synchronized t)) 但是在修改时，需要使用sb-ext:with-locked-hash-table将操作保护起来 (sb-ext:with-locked-hash-table (my-hash) (setf (gethash :a my-hash) :new-value)) cl-gserver library cl-gserver 实现了一套actors/agent system 可以简化多线程变成的困难 ","date":"2022-04-19","objectID":"/data_structures/:4:9","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Alist (associated list) 一个association list 就是一个存放cons cells 的list (defparameter *my-alist* (list (cons 'foo \"foo\") (cons 'bar \"bar\"))) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) 内部构造就像这样 [o|o]---[o|/] | | | [o|o]---\"bar\" | | | BAR | [o|o]---\"foo\" | FOO ","date":"2022-04-19","objectID":"/data_structures/:5:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"构造 Construct 第一种方法 (setf *my-alist* '((:foo . \"foo\") (:bar . \"bar\"))) 第二种方法是使用pairlis (pairlis '(:foo :bar) '(\"foo\" \"bar\")) ;; =\u003e ((:BAR . \"bar\") (:FOO . \"foo\")) Alist 就是一个list 所以一个key可以绑定多个值 (setf *alist-with-duplicate-keys* '((:a . 1) (:a . 2) (:b . 3) (:a . 4) (:c . 5))) ","date":"2022-04-19","objectID":"/data_structures/:5:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"访问 Access 要获取一个key 我们使用assoc (可以指定 :test 如果key的类型为strings默认用 equal) 它会返回整个cons cell, 所以可以配合cdr 或者second 获取对应的值。Alexandria 还提供了assoc-value list key 这个函数更加的方便 (alexandria:assoc-value my-alist :foo) ;; =\u003e :foo , (:foo . \"foo\") assoc-if(predicate alist) 找到第一个满足predicate的cons cell (setf alist '((1 . :a) (2 . :b) (3 . :c))) (assoc-if #'evenp alist) rassoc 按值查找 (setf alist '((1 . :a) (2 . :b) (4 . :d) )) (rassoc :a alist) ;; =\u003e (1 . :a) 去重 使用remove-if-not 这个函数的作用是返回一个只包含不满足predicate的列表 (remove-if-not #'(lambda (entry) (eq :a entry)) alist-with-duplicate-keys :key #'car) ","date":"2022-04-19","objectID":"/data_structures/:5:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"插入和删除 push 插入一个entry (push (cons 'team \"team\") my-alist) ;; =\u003e ((TEAM . \"team\") (FOO . \"foo\") (BAR . \"bar\")) 删除remove pop 等 remove 需要指定key 关键字 告诉remove 怎么读取entry (remove 'team my-alist) ;; =\u003e ((TEAM . \"team\") (FOO . \"foo\") (BAR . \"bar\")) ;; didn't remove anything (remove 'team my-alist :key 'car) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) ;; returns a copy ","date":"2022-04-19","objectID":"/data_structures/:5:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"更新entries replace a value *my-alist* ;; =\u003e '((:FOO . \"foo\") (:BAR . \"bar\")) (assoc :foo *my-alist*) ;; =\u003e (:FOO . \"foo\") (setf (cdr (assoc :foo *my-alist*)) \"new-value\") ;; =\u003e \"new-value\" *my-alist* ;; =\u003e '((:foo . \"new-value\") (:BAR . \"bar\")) replace a key *my-alist* ;; =\u003e '((:FOO . \"foo\") (:BAR . \"bar\"))) (setf (car (assoc :bar *my-alist*)) :new-key) ;; =\u003e :NEW-KEY *my-alist* ;; =\u003e '((:FOO . \"foo\") (:NEW-KEY . \"bar\"))) ","date":"2022-04-19","objectID":"/data_structures/:5:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Plist (property list) plist 是一个简单地list 内部又 key ,value 交错组成。他的key是一个symbol (defparameter my-plist (list 'foo \"foo\" 'bar \"bar\")) 底层结构就像这样 [o|o]---[o|o]---[o|o]---[o|/] | | | | FOO \"foo\" BAR \"bar\" 我们可以使用getf (list elt)来获取一个元素（返回value） (defparameter my-plist (list 'foo \"foo\" 'bar \"bar\")) ;; =\u003e (FOO \"foo\" BAR \"bar\") (setf (getf my-plist 'foo) \"foo!!!\") ;; =\u003e \"foo!!!\" remf 用来删除一个元素 (remf my-plist 'foo) ;; =\u003e (BAR \"bar\") ","date":"2022-04-19","objectID":"/data_structures/:6:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Structures 结构体 structures 可以将数据存储在具名的slots中，并且支持单继承。 CLOS (Common Lisp Object System)提供一个更灵活的Classes. 但是structures 可以提供更好的性能 ","date":"2022-04-19","objectID":"/data_structures/:7:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"定义 使用defstruct (defstruct person id name age) 在创建时 slots 默认值为nil 要想自定义默认值 (defstruct person id (name \"john doe\") age) 也可以指定默认类型 (defstruct person id (name \"john doe\" :type string) age) ","date":"2022-04-19","objectID":"/data_structures/:7:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"创建 使用make-\u003cstructure-name\u003e, 对于上面的person 使用make-person (defparameter me (make-person)) ;; =\u003e ME me ;;=\u003e #S(PERSON :ID NIL :NAME \"john doe\" :AGE NIL) 也可以使用关键字指定参数值 (defparameter me (make-person :name 123)) 还可以自定义构造函数，但是一旦自定义了构造函数，那么默认构造函数就将不发再被使用 (defstruct (person (:constructor create-person (id name age))) id name age) ","date":"2022-04-19","objectID":"/data_structures/:7:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"访问slot的值 structure被定义后，会自动定义 \u003cname-of-the-struct\u003e-+slot-name这样的函数 (person-name me) ","date":"2022-04-19","objectID":"/data_structures/:7:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"设置slot的值 使用setf来设置值 (setf (person-name me) \"Cookbook author\") ","date":"2022-04-19","objectID":"/data_structures/:7:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"判断类型 就像默认构造，默认也会生成断言函数来判断类型 (person-p me) ","date":"2022-04-19","objectID":"/data_structures/:7:5","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"限制 在定义改变后，实例并不会更新 (defstruct person id (name \"john doe\" :type string) email) attempt to redefine the STRUCTURE-OBJECT class PERSON incompatibly with the current definition [Condition of type SIMPLE-ERROR] Restarts: 0: [CONTINUE] Use the new definition of PERSON, invalidating already-loaded code and instances. 1: [RECKLESSLY-CONTINUE] Use the new definition of PERSON as if it were compatible, allowing old accessors to use new instances and allowing new accessors to use old instances. 2: [CLOBBER-IT] (deprecated synonym for RECKLESSLY-CONTINUE) 3: [RETRY] Retry SLIME REPL evaluation request. 4: [*ABORT] Return to SLIME's top level. 5: [ABORT] abort thread (#\u003cTHREAD \"repl-thread\" RUNNING {1002A0FFA3}\u003e) CLOS CLOS是没有这种限制的 后面会介绍到 ","date":"2022-04-19","objectID":"/data_structures/:7:6","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Tree tree-equal,copy-tree. 会自顶向下递归进入cons cell 的car 和 cdr ","date":"2022-04-19","objectID":"/data_structures/:8:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Sycamore purely functional weight-balanced binary trees https://github.com/ndantam/sycamore Features: Fast, purely functional weight-balanced binary trees. Leaf nodes are simple-vectors, greatly reducing tree height. Interfaces for tree Sets and Maps (dictionaries). Ropes Purely functional pairing heaps Purely functional amortized queue. ","date":"2022-04-19","objectID":"/data_structures/:8:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"控制打印多少数据 \\*print-length\\*, \\*print-level\\*) print-length 和 print-level默认都为nil 默认，如果你有一个非常长的list, 那么在REPL中打印就会非常的长。使用print-length 控制打印元素的最大数量 (setf *print-length* 2) (list :A :B :C :D :E) ;; (:A :B ...) print-level用来控制打印的深度 (let ((*print-level* 2)) (print '(:a (:b (:c (:d :e)))))) ;; (:A (:B #)) \u003c= *print-level* in action ;; (:A (:B (:C (:D :E)))) \u003c= the list is returned, the let binding is not in effect anymore. ","date":"2022-04-19","objectID":"/data_structures/:9:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"定义一个函数 可以使用defunc 关键字定义一个有名字的函数: (defun \u003cname\u003e (list of arguments) \"docstring\" (function body)) 用学语言必学的打印hello world! 来举例 (defun hello-world () ;; define a function named hello-world (format t \"hello world!\")) ;; print hello world! and return nil 调用 (hello-world) ;; \"hello world!\" \u003c-- output printed by `foramt' function ;; nil \u003c-- return value return by format why docstring common lisp 可以再函数体开始之前 改写 docstring 为函数添加文档 lisp习惯使用这种方式来给函数写一些帮助文档，类似readme这种自述文件 docstring 是对函数的描述 about the return value common lisp 的函数默认会return 最后一个表达式的值 再这里就是 (format t \"hello world!\") 的返回值也就是nil ","date":"2022-04-17","objectID":"/function/:1:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"函数返回值 ","date":"2022-04-17","objectID":"/function/:2:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"required arguments 函数的必要参数 先看这个函数定义 (defun hello (name) ;;name 就是必要参数 \"say hello to `name'.\" (format t \"hello ~a !~\u0026\" name) ;; 这里直接使用name参数 ) 直接调用 (hello \"me\") ;; hello me! \u003c-- printed by `format' ;; Nil \u003c-- return value format 的格式控制符 common lisp format 类似c语言的printf。但是common lisp的格式控制符是以 ~ 为开头的 而且字符的意义也不同 比如C语言中 \\n 代表换行 而format中 ~\u0026就代表换行符。 ","date":"2022-04-17","objectID":"/function/:2:1","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"Optional arguments 函数的可选参数: \u0026optional 可选参数是定义再 \u0026optional 关键字后面。并且要保持有序，必须一个跟着一个出现。这里有点懵逼吧。废话不多说，直接上例子。 (defun hello (name \u0026optional age gender) (format t \"name: ~a age ~a gender ~a ~\u0026\" name age gender) ) 这条函数定义中 name 是必要函数，age 和 gender是可选参数。name是必填的，就是你在调用这个函数的时候，name是必须的。而 age 和 gender 你可以选择提供或者省略。但是当你想提供 gender 这个参数的时候，你必须也要提供 age 这个参数。不严谨的说，一个可选参数要想出现，就必须建立在他前面的一个可变参数已经提供的情况下。 (hello \"me\") ;; supply required argument name. avoid optional arguments age and gender (hello \"me\" 7) ;; supply required argument name, optional argument age and void gender (hello \"me\" 7 \"female\") ;; supply name age and gender (hello \"me\" \"female\") ;; wrong for practice。 You may use hello in this way grammaly but female won`t supplied to the gender arguments 如果可选参数再调用的时候没有绑定值 那值就为 nil (hello \"me\") ;; name: me age NIL gender NIL ","date":"2022-04-17","objectID":"/function/:2:2","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"Named paramenters 具名参数: \u0026key 有时候记住参数的顺序非常不方便，lisp 提供了使用参数名来提供参数的方式. 在\u0026key 后面跟上参数名即可定义具名参数 (defun hello (name \u0026key happy) \"if `happy' is `t,print a smiley\" (format t \"hello ~a\" name) (when happy (format t \":) ~\u0026\"))) 调用的时候用 :name value 这样的形式指定参数,定义了具名参数但是调用的时候不指定value 那具名参数的value 会为nil (hello \"me\") ;; ignore the happy paramenter,happy will be set to nil defaultly (hello \"me\" :happy t) ;; bind happy to t (hello \"me\" :happy nil) ;; bind happy to nil (hello \"me\" :happy) ;; wrong! this form is definitely wrong lisp中的 t and nil lisp 中用 t 代表true nil 代表false 和 空 有关函数参数数量的想法 具名参数是为了解决记住参数的顺序不方便而诞生的，但是如果函数的参数过多的话，会导致函数的行为会变得复杂多样。clean code 中并不鼓励函数参数的数量超过3个 你也可以定义多个具名参数 (defun hello (name \u0026key happy lisper cookbook-contributor-p) ...) 使用示例 (hello \"me\" :lisper t) (hello \"me\" :lisper t :happy t) (hello \"me\" :cookbook-contributor-p t :happy t) keys can be variable 类似 :happy 这样的符号其实可以作为一个变量的值就像这样。 (let ((key :happy) ;; bind :happy to key (val t)) ;; bind t to val (hello \"me\" key val)) ;; quote key and val let 可以声明一些只能在let代码快中使用的变量这个后面会细说 ","date":"2022-04-17","objectID":"/function/:2:3","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"混合可选和具名参数 先看一个例子 (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) 如果你直接这么定义函数，lisp的解释器会报warning ; in: DEFUN HELLO ; (SB-INT:NAMED-LAMBDA HELLO ; (\u0026OPTIONAL NAME \u0026KEY HAPPY) ; (BLOCK HELLO (FORMAT T \"hello ~a \" NAME) (WHEN HAPPY (FORMAT T \":)~\u0026\")))) ; ; caught STYLE-WARNING: ; \u0026OPTIONAL and \u0026KEY found in the same lambda list: (\u0026OPTIONAL (NAME \"John\") \u0026KEY ; HAPPY) ; ; compilation unit finished ; caught 1 STYLE-WARNING condition 虽然也能调用 (hello \"me\" :happy t) ;; hello me :) ;;nil 这种情况不能直接跳过optional的参数 直接指定key 参数 还是上面这个函数 (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) 如果你尝试省略name 直接指定 :happy 就会报错 (hello :happy t) ;; odd number of \u0026KEY arguments 因为optional 的参数必须是有序出现的，如果前面的参数未出现，就不能直接指定后面的参数。但是当指定完所有的optional参数后，你就可以按照key参数的规则去指定key参数 看这个函数定义(一个不恰当的例子) (defun hello (\u0026optional name \u0026key happy age) (format t \"hello ~a \" name) (when happy (format t \":)~\u0026\"))) (hello \"me\" :age 1) 这里直接忽略happy 关键字 指定age ","date":"2022-04-17","objectID":"/function/:2:4","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"key parameters 的默认值 可以使用一对包含键值的括号来指定默认值 (happy t) (defun hello (name \u0026key (happy t))) 这样happy 的默认值就被设成了t ","date":"2022-04-17","objectID":"/function/:2:5","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"如何确定具名参数(key parameter) 是否被指定 前面有提到过，具名参数如果不指定，就会默认为NIL。那问题就是，如何知道具名参数的调用者是否故意指定这个参数为NIL呢。因为参数为NIL可能会有自己特殊的意义，所以需要判断是否是调用者故意设为NIL. 我们使用二元组 tuple 设置默认值 \u0026key (:happy t) 我们可以使用三元组 triple来解决参数知否被故意指定为NIL \u0026key (:happy t happy-p) (defun hello (name \u0026key (happy nil happy-p)) (format t \"Key supplied? ~a~\u0026\" happy-p) (format t \"hello ~a \" name) (when happy-p (if happy (format t \":)\") (format t \":(\")))) (hello \"me\" :happy t) ;; Ky supplied? T ;; hllo me :) 从返回的结果可以看到 如果指定了:happy 那么happy-p 会被自动设置为 t 即被指定状态 lisp 中有关断言命名的convenstion(传统) lisp 中习惯对用来做判断的函数或变量后面加一个p 比如 stringp :用来判断是否为字符串的函数 listp : 用来判断是否为列表类型的函数 p是predicate的缩写 意为断言 ","date":"2022-04-17","objectID":"/function/:2:6","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"可变数量参数: \u0026rest 的时候，你会想要定义一些函数，可以接受很多个参数，但是具体多少个，你也不清楚。比如你想定义个函数把所有的参数都相加进行求和。 (defun sum (arg1 arg2 arg3 ... to arg100....)) 这样太累了，你不可能一个一个的敲。我们可以这样 (defun hello (\u0026rest numbers) (apply #'+ numbers)) 调用 (hello 1 2 3 4) ;; 10 \u003c-- returned by hello apply 函数 apply 的第一个参数接收一个拥有两个参数的回调函数 第二个参数接受一个列表（这里为了方便理解代码这么说，其实这是不严谨的） 就像这样 (apply #'func '(arg1 arg2 arg3)) arg1 arg2 arg3 将会作为func 的参数传递给func 并进行运算. 也就是说 apply的操作是将 list 展开成一个个参数并传给func。 比如(apply #+ ‘(1 2 3 4)) 和 (+ 1 2 3 4) 是等价的。 列表 ‘(1 2 3 4) 被展开成 1 2 3 4 传递给了func ","date":"2022-04-17","objectID":"/function/:2:7","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"允许额外的key: \u0026allow-other-keys 先看下下面的例子 (defun hello (name \u0026key happy) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; Error: unknown keyword argument 再看看这个 (defun hello (name \u0026key happy \u0026allow-other-keys) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; hello me 这里我们并没有给出 :lisper 这个关键字的定义 但是函数仍然允许我们这么调用而不是直接报错 《common lisp cook book》 中给出过一个实用的案例 (defun open-supersede (f \u0026rest other-keys \u0026key \u0026allow-other-keys) (print other-keys) (apply #'open f :if-exists :supersede other-keys)) 这个函数的定义要求必须有一个f参数，以及任意数量的other-keys 其实 \u0026key 以及\u0026allow-other-keys 被忽略了只做提示用（告诉调用者可以接受其他具名参数）。因为有\u0026rest 这个标志符在 除了f外 参数都会传到other-keys里面。所以\u0026key \u0026allow-other-keys就失去了语法上的意义。起码在编译器看来，他是无意义的。 但是如果你不按照函数签名指示的方式调用，内层的函数就很有可能报错，所以即使\u0026key \u0026allow-other-keys被编译器忽略(这种函数在定义时，甚至可以忽略\u0026key \u0026allow-other-keys关键字，功能并不会因为没有他们而受影响)，你也应该按照签名去调用函数。因为内层的函数需要依赖这个签名规则。 来看这个函数调用 (open-supersede \"test.log\" :if-does-not-exist :create) ;;(:IF-DOES-NOT-EXIST :CREATE) \u003c\u003c-- 由(print other-keys)打印 可以看到具名参数都被传给了\u0026rest 必要的函数文档 在写这种函数的时候，应该写上docstring 因为函数签名已经不能很好的描述函数了，我们应该加上docstring来描述函数，不要让调用者疑惑。 ","date":"2022-04-17","objectID":"/function/:2:8","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"函数返回值 common lisp 的返回值默认是函数的最后一个执行语句 你也可以使用(return-from \u003cfunction name\u003e \u003cname\u003e \u003cvalue\u003e) 显示的从具体函数内返回。注意这里是直接从\u003cfunction name\u003e 指定的函数中返回,不仅仅是从当前运行的函数中返回，也有可能直接从外层函数返回。 多数时候我们并不使用return-from ","date":"2022-04-17","objectID":"/function/:3:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"多返回值：values,multiple-value-bind and nth-value 我们使用values来构造一个多返回值 (defun foo (a b c) (values a b c)) 因为函数的最后一条语句的结果会被返回，所以values构造的多返回值会被直接返回给上层 (setf res (foo :a :b :c)) ;; :A \u003c\u003c-- res 为:A 这里res为:A而不是 :A :B :C 是因为这里的返回值接受者只有res 所以只有第一个:A 被接受 :B :C 都被自动忽略掉了. 接受多返回值得方法为multiple-value-bind。 multiple-value-bind 使用multiple-value-bind来解构多返回值。 (multiple-value-bind (res1 res2 res3) (foo :a :b :c) (format t \"res1 is ~a, res2 is ~a, res3 is ~a ~\u0026\" res1 res2 res3)) ;res1 is A, res2 is B res3 is C ;nil 通用格式 (multiple-value-bind (var-1 .. var-n) expr body) multiple-value-bind绑定的变量是局部的 使用multiple-value-bind的变量再它外面是访问不到的, 也就是说上面的例子中 res1 只能再(multipe-value-bind)的内部使用。而无法再外部使用 nth-value nth-value 是可以直接拿到指定索引的返回值 (nth-value 0 (values :a :b :c)) ;; =\u003e :A (nth-value 2 (values :a :b :c)) ;; =\u003e :C (nth-value 9 (values :a :b :c)) ;; =\u003e NIL 但是如果将 nth-value 用在List上，结果就不一样了 (nth-value 0 '(:a :b :c)) ;; =\u003e (:A :B :C) (nth-value 1 '(:a :b :c)) ;; =\u003e NIL Note (values) 将不会返回任何值 multiple-value-list multiple-value-list 将返回值构造成list (multiple-value-list (values 1 2 3)) ;; (1 2 3) 相反的操作有将list 构造成多返回值 (value-list '(1 2 3)) ","date":"2022-04-17","objectID":"/function/:3:1","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"匿名函数 lambda 使用lambda函数创建匿名函数 (lambda (x) (print x)) 我们可以用funcall 或者 apply 来调用匿名函数 如果一个未被引用的括号表达式内部第一个元素是一个匿名函数，那么这个匿名函数就会被调用 ((lambda (x) (print x)) \"hello\") 引用 lisp中 引用是指以’为开头的表达式或符号。‘将保护表达式或符号维持其本身。 比如(func arg) 这种形式的表达式将会自动被当做函数执行,有些情况我们并不想让他执行（比如传一个list 给函数做参数的时候的时候） (defun hello (arg)) (hello (1 2 3)) ;; illegal function call 这里(1 2 3) 将会被求值 并不会真的传一个(1 2 3) 给arg且会报 illegal function call 这样的错误。因为没有被’ 保护的函数会被自动当成函数并且运算。 所以正确的形式应该是 (defun hello (arg)) (hello '(1 2 3)) ‘就是保护表达式或变量维持其本身 ","date":"2022-04-17","objectID":"/function/:4:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"使用funcall 和 apply 调用函数 funcall 和 apply 类似，都是将参数规整成正确的形式然后传给回调函数 (funcall #'func arg1 arg2 .. argn) ;; ^^ 回调 要传给func的参数 不同点在于， funcall 不会自动展开list 列表 而apply 可以将列表展开成一个个参数传给回调func (funcall #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) 会原封不动的传给func (apply #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) 会被展开成 arg3 arg4 最后的形式就是 (apply #'func arg1 arg2 arg3 arg4) ","date":"2022-04-17","objectID":"/function/:4:1","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"使用 single quote ’ 还是 sharpsign-quote #’ 来引用函数? single quote ’ 和 sharpsign-quote #‘的不同在于 #’ 使用的是词法作用域(lexical scope) 会更安全点 (defun foo (x) (* x 100)) (flet ((foo (x) (1+ x))) (funcall #'foo 1)) ;; =\u003e 2, as expected ;; ;; But: (flet ((foo (x) (1+ x))) (funcall 'foo 1)) ;; =\u003e 100 lexical scope 词法作用域的意思是，当找一个变量或函数的时候（函数此时作为值进行传递）会默认去定义的地方去找而不是再函数运行的环境中去找。 上面的foo 一个是在外面声明的 一个是使用flet 保护起来的foo 对于funcall 来说 #’会去找flet 出来的foo 因为词法作用域要求在定义的地方去找需要的函数。 single quote ’ 使用的是动态作用域 会默认去运行环境中找所以 即使第二个flet 也声明了 foo 但是funcall 的时候还是去到外层寻找foo #’ 其实就是(function … )的语法糖 (function +) ;; #\u003cFUNCTION +\u003e (flet ((foo (x) (1+ x))) (print (function foo)) (funcall (function foo) 1)) ;; #\u003cFUNCTION (FLET FOO) {1001C0ACFB}\u003e ;; 2 ","date":"2022-04-17","objectID":"/function/:4:2","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"高级函数 能够返回函数的函数 (functions that return functions) (defun adder (n) (lambda (x) (+ x n))) 这样就定义了一个能够返回一个函数对象的adder函数 要想调用这个函数对象我们需要funcall 或者 apply (adder 5) ;; #\u003cCLOSURE (LAMBDA (X) :IN ADDER) {100994ACDB}\u003e (funcall (adder 5) 3) ;; 8 如果你想以正常的思维去调用这个函数对象，会报错 ((adder 3) 5) ;;In: (ADDER 3) 5 ;;((ADDER 3) 5) ;;Error: Illegal function call. 在common lisp 中 对于变量和方法 他们有不同的命名空间。 比如一个变量和一个函数可以有同一个名字, 这取决于他被运算的环境 ;; The symbol foo is bound to nothing: CL-USER\u003e (boundp 'foo) NIL CL-USER\u003e (fboundp 'foo) NIL ;; We create a variable: CL-USER\u003e (defparameter foo 42) FOO * foo 42 ;; Now foo is \"bound\": CL-USER\u003e (boundp 'foo) T ;; but still not as a function: CL-USER\u003e (fboundp 'foo) NIL ;; So let's define a function: CL-USER\u003e (defun foo (x) (* x x)) FOO ;; Now the symbol foo is bound as a function too: CL-USER\u003e (fboundp 'foo) T ;; Get the function: CL-USER\u003e (function foo) #\u003cFUNCTION FOO\u003e ;; and the shorthand notation: * #'foo #\u003cFUNCTION FOO\u003e ;; We call it: (funcall (function adder) 5) #\u003cCLOSURE (lambda (X) :IN ADDER) {100991761B}\u003e ;; and call the lambda: (funcall (funcall (function adder) 5) 3) 8 可以认为，每个symbol 在CL(common lisp)中多有多个cell(空间)存储不同的信息，比如有的表示一个value-cell 你可以用boundp 来测试是否绑定了一个value. 你可以使用symbol-value访问value-cell. 还有其他cell 比如function-cell 可以保存symbol 的function. 你可以用fboundp来测试，使用symbol-function 来访问这个function. 如果symbol 被运算，那它就被当做是一个variable 并且他的value-cell将被返回。如果是符合形式，即cons,被求值并且他的car是一个symbol，那么使用这个symbol的function-cell. 所以上面的((addr 3) 5)的调用会报错。因为(addr 3) 既不是符号 也不是lambda表达式. ;;; continued from above CL-USER\u003e (fboundp '*my-fun*) NIL CL-USER\u003e (setf (symbol-function '*my-fun*) (adder 3)) #\u003cCLOSURE (lambda (X) :IN ADDER) {10099A5EFB}\u003e CL-USER\u003e (fboundp '*my-fun*) T CL-USER\u003e (*my-fun* 5) 8 ","date":"2022-04-17","objectID":"/function/:5:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"Closures 闭包 Closures 允许捕获词法绑定的值 (let ((limit 3) (counter -1)) (defun my-counter() (if (\u003c counter limit) (incf counter) (setf counter 0)))) (my-counter) 0 (my-counter) 1 (my-counter) 2 (my-counter) 3 (my-counter) 0 lexical 这里可以看见，counter 和 limit 是在let后就已经存在的值。my-counter 会去找被let的limit 和 counter. let就是将let定义的值与下面的函数体(body)做绑定。 还可以这样 (defun repeater (n) (let ((counter -1)) (lambda () (if (\u003c counter n) (incf counter) (setf counter 0))))) (defparameter *my-repeater* (repeater 3)) (defparameter *my-repeater2* (repeater 2)) (funcall *my-repeater*) 0 (funcall *my-repeater*) 1 (funcall *my-repeater*) 2 (funcall *my-repeater2*) 0 (funcall *my-repeater*) 3 (funcall *my-repeater*) 0 这里可以看到my-repeater 和my-repeater之间是相互隔离的 各自拥有自己的counter. 这是因为repeater 被执行了两次而 lambda 表达式被定义了两次，而被let包裹的函数会去其定义的环境中寻找值，所以两者的counter是隔离的。 ","date":"2022-04-17","objectID":"/function/:6:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"TODO setf functions ","date":"2022-04-17","objectID":"/function/:7:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"柯里化 currying 维基百科上的解释是，把接受多个参数的函数转换成接受一个单一参数的函数 (defun curry (function \u0026rest args) (lambda (\u0026rest more-args) (apply function (append args more-args)))) 这个函数再第一次调用的时候会返回lambda函数 (funcall (curry #'+ 3) 5) ;;8 ","date":"2022-04-17","objectID":"/function/:8:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["leetcode"],"content":"leetcode-三数之和的解法","date":"2022-04-04","objectID":"/3sumcloset/","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"description ","date":"2022-04-04","objectID":"/3sumcloset/:1:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"analyze 这道题先排序，防止重复枚举，并且利用有序性，来使双指针的逼近产生可能。双指针的逼近其实和那题最大容量是类似的。 假设每轮枚举到的数分别为a,b,c，第二轮第三轮枚举的指针分别为i,pb,pc,令pb指向i+1,pc指向len(nums)-1 若a+b+c \u003e target 则应该让pc左移，因为排完序后，pb不动的情况下 只有pc左移才会使a+b+c的值减小 才有可能更加靠近target 若a+b+c \u003c target 则应该让pb右移，因为pc不动的情况下，只有pb右移，a+b+c的值才会增大，才有可能更加靠近target ","date":"2022-04-04","objectID":"/3sumcloset/:2:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"implementation package main import ( \"fmt\" \"math\" \"sort\" ) func threeSumClosest(nums []int, target int) int { result := math.MaxInt64 distance := math.MaxFloat64 sort.Ints(nums) for i := 0; i \u003c len(nums); i++ { if i \u003e 0 \u0026\u0026 nums[i] == nums[i-1] { continue } third := len(nums) - 1 for j := i + 1; j \u003c len(nums); j++ { if j \u003e i+1 \u0026\u0026 nums[j] == nums[j-1] { continue } for nums[i]+nums[j]+nums[third] \u003e target \u0026\u0026 third \u003e j { if third \u003c len(nums)-1 \u0026\u0026 nums[third] == nums[third+1] { third-- continue } sum := nums[i] + nums[j] + nums[third] tmpDistance := math.Abs(float64(sum - target)) if tmpDistance \u003c= distance { distance = tmpDistance result = sum } third-- } if third == j { break } if nums[i]+nums[j]+nums[third] \u003c= target { sum := nums[i] + nums[j] + nums[third] tmpDistance := math.Abs(float64(sum - target)) if tmpDistance \u003c= distance { distance = tmpDistance result = sum } } } } return result } ","date":"2022-04-04","objectID":"/3sumcloset/:3:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"summery 这道题，乍一看，我就往dp上面去想了。看看这题，跟那题三数只和很相似，就想着能不能在第二轮和第三轮的时候来一次优化。但是我看了半天也没看出来，优先排序这个思路是有的，想着第二轮第三轮进行优化的思路也是对的。但是具体如何优化我却想不到。想着应该跟那个target有关系，但是我方向错了，根本就不是我想的那样。后来一看题解，恍然大悟，这些数组题，双指针的，尤其要三轮演绎的，一般都是想让你进行二三轮的优化，利用双指针逼近不断找到最优解。至于如何逼近，就是问题的关键点了，只要找到能够让指针逼近的关系，这道题自然就解开了。 ","date":"2022-04-04","objectID":"/3sumcloset/:4:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最优解优于全局最优解，则刷新全局最优解。","date":"2022-04-04","objectID":"/container_with_most_water/","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"1 Description https://leetcode-cn.com/problems/container-with-most-water/ ","date":"2022-04-04","objectID":"/container_with_most_water/:1:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"2.analyze problem 这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最优解优于全局最优解，则刷新全局最优解。 ","date":"2022-04-04","objectID":"/container_with_most_water/:2:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"2.1 slove step 分配两个指针，分别指向数组的头尾 [1,8,6,2,5,4,8,3,7] l r 计算面积并与全局最优解做比较，如果大于全局最优解，刷新全局最优解。并且移动对应数字较小的那个指针(向对应数字较大的方向移动) [1,8,6,2,5,4,8,3,7] l r 重复上述操作直到指针相遇 ","date":"2022-04-04","objectID":"/container_with_most_water/:2:1","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"2.2 certify 需要该解法需要证明的是，为什么每次移动对应值较小的指针是正确的。 双指针代表的是 可以作为容器边界的所有位置的范围 移动指针就代表这个指针不可能再作为容器的边界了。 为什么指向较小值的指针不可能再作为容器的边界了 。 假设当前左指针和右指针指向的数分别为\\(x\\) 和\\(y\\), 不失一般性，我们假设 \\(x \\leq y\\) 两个指针之间的距离为t。那么，他们组成的容器的容量为： \\[\\begin{equation} min(x,y)*t = x*t \\end{equation}\\] 如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 \\(x*t\\) 。为什么呢，这里我们只考虑当指针还指向左右边界的时候。 我们任意向左移动右指针，指向的数为 \\(y_{1}\\) ，两个指针之间的距离为 \\(t_{1}\\) ，\\(t_{1} \u003c t\\) ，并且 \\(min(x,y_{1}) \\le min(x,y)\\) 如果 \\(y_{1} \\le y\\), then \\(min(x,y_{1}) \\le min(x,y)\\) ; 如果 \\(y_{1} \\ge y\\), then \\(min(x,y_{1}) =x= min(x,y)\\) ; 所以有 \\[\\begin{equation} min(x,y_{t})*t_{1} \u003c min(x,y)*t \\end{equation}\\] 这表明指向较小值的指针不可以再作为容器的边界，因为无论如何移动较大的指针，容器的容量都不会再变大。这个边界应该被舍弃。 ","date":"2022-04-04","objectID":"/container_with_most_water/:2:2","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"3 implementation //c++ version #include \u003calgrothim\u003e#include \u003ciostream\u003e#include \u003cmath\u003e using namespace std; class Solution { public: int maxArea(vector\u003cint\u003e \u0026height) { int left = 0; int right = height.size()-1; int compacity = 0; while (left \u003c right) { int min = fmin(height[left], height[right]); int length = right - left; int tmpCompacity = min * length; if (tmpCompacity \u003e= compacity) compacity = tmpCompacity; if (height[left] \u003e= height[right]) right--; else left++; } return compacity; } }; int main(int argc, char *argv[]) { return 0; } //go version import \"math\" func maxArea(height []int) int { front := 0 end := len(height)-1 var maxCompacity float64 = 0 for front \u003c end { longSide := math.Min(float64(height[front]),float64(height[end])) shotSide := float64(end-front) tmpCompacity := longSide*shotSide maxCompacity = math.Max(tmpCompacity,maxCompacity) if height[front] \u003e= height[end] { end-- }else{ front++ } } return int(maxCompacity) } ","date":"2022-04-04","objectID":"/container_with_most_water/:3:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"4 summery 这道题用到了双指针+贪心算法。以后都可以用双指针对撞的思想去求解这类问题，重点在于如何找到应该移动的指针。当因子分布再数组的两边的时候，可以考虑使用双指针的方法求解。这题的贪心并不明显，只在更新最大的容量的时候进行了贪心。贪心的思想是每一步只选择当前认为的最优解。 ","date":"2022-04-04","objectID":"/container_with_most_water/:4:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"Description Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. Example 3: Input: nums1 = [0,0], nums2 = [0,0] Output: 0.00000 Example 4: Input: nums1 = [], nums2 = [1] Output: 1.00000 Example 5: Input: nums1 = [2], nums2 = [] Output: 2.00000 Constraints: nums1.length == m nums2.length == n 0 \u003c= m \u003c= 1000 0 \u003c= n \u003c= 1000 1 \u003c= m + n \u003c= 2000 -106 \u003c= nums1[i], nums2[i] \u003c= 106 ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:1:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode"],"content":"Analyse 这道题最简单的想法就是先归并到一个数组，然后再把中位数找到，但是此时的时间复杂度为\\(o(m+n)\\) 不符合题意。题目要求的是 \\(o(\\log(m+n))\\) 。 此时我们能想到的应该就只有二分法了，对于有序数组，二分法总能非常有效的降低算法的复杂度。但是如何二分成为一个问题。 中位数指的是一个数列中间的数。设 len = len(array) 这里的/为整除 \\begin{equation} \\label{中位数公式} medium = \\begin{cases} \\frac{array[len/2-1] + array[len/2]}{2} \u0026len\\mod 2=0 \\\\ \\frac{array[len/2-1]}{2}\u0026 len\\mod 2\\neq 0 \\end{cases} \\end{equation} 这道题是寻找两个有序数组的中位数，我们可以姑且假设他们已经合并后的数组为 nums3 我们要在nums3中寻找中位数。此时 nums3 的长度我们 是知道的(m+n) 那么其中位数的应该为第 k= \\(\\frac{m+n}{2}\\) 个数（这里我们先只看奇数情况。这时我们可以对k进行二分处理，分别找到两个s数组中第 \\(\\frac{k}{2}\\) 个数进行比较，然后排除较小的以及它所在数组中在它前面的数。因为他们是不可能成为中位数的。 对于 nums1[k/2-1] 和 nums2[k/2-1] 在它们之前的只有 k/2-1 + k/2-1 = k -2 个数。即使算上较小的那个数，也只能到第k-1个数。 所以他们是不可能成为第k个数的。这时我们让 k = k-A(A为已经排除的数的个数) 然后继续对剩下的数组进行同样的操作。 这里会出现两种情况 如果 nums1[k/2-1] \u003e= nums2[k/2-1] 则直接排除nums1[k/2-1] 及其前面的数 如果 nums1[k/2-1] \u003c nums2[k/2-1] 则直接排除nums2[k/2-1] 及其前面的数 在排除过程中我们还会遇到几种情况 k/2-1 越界，这种情况取最后一个元素 k=1 直接返回较小的元素 数组为空，直接去非空数组中寻找即可 ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:2:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode"],"content":"Implement //c++ version #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e int main(int argc, char *argv[]) { Solution s; vector\u003cint\u003e nums1 = new vector\u003cint\u003e(); vector\u003cint\u003e nums2 = new vector\u003cint\u003e(); for(int i = 1;i\u003c10;i++){ nums1.push_back(i); } for(int i= 1;i\u003c10;i=i+2){ nums2.push_back(i); } s.findMedianSortedArrays(nums1,nums2); return 0; } class Solution { public: double findMedianSortedArrays(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { int k = nums1.size() + nums2.size(); if(k%2 == 0){ return min(getKthElement(nums1, nums2, k/2+1),getKthElement(nums1, nums2,k/2))/2.0; }else{ return getKthElement(nums1,nums2,k/2); } } double getKthElement(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2,int k){ int index1 = 0; int index2 = 0; int m = nums1.size(); int n = nums2.size(); while (true){ if (index1 == m){ return nums2[index2+k-1]; } if(index2 == n){ return nums1[index1 +k -1]; } if(k == 1){ return min(nums1[index1],nums2[index2]); } int newIndex1 = min(index1+k/2-1,m-1); int newIndex2 = min(index2+k/2-1,n-1); if(nums1[newIndex1] \u003e= nums2[newIndex2]){ k -= newIndex2 - index2 +1; index2 = newIndex2+1; }else{ k -= newIndex1 - index1 +1; index1 = newIndex1+1; } } } }; //GO version package main import ( \"fmt\" \"math\" ) func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { k := int(math.Ceil((float64(len(nums1)) + float64(len(nums2))) / 2)) if (len(nums1)+len(nums2))%2 == 0 { foo1 := getKthElement(nums1, nums2, k) foo2 := getKthElement(nums1, nums2, k+1) return float64(foo1+foo2) / 2 } else { return float64(getKthElement(nums1, nums2, k)) } } func getKthElement(nums1 []int, nums2 []int, k int) int { if len(nums1) == 0 { return nums2[k-1] } if len(nums2) == 0 { return nums1[k-1] } compareIdx := k / 2 if compareIdx == 0 { return min(nums1[0], nums2[0]) } nums1Idx := min(len(nums1)-1, compareIdx-1) nums2Idx := min(len(nums2)-1, compareIdx-1) if nums1[nums1Idx] \u003e= nums2[nums2Idx] { if len(nums2) \u003c= compareIdx { return getKthElement(nums1, []int{}, k-(nums2Idx+1)) } return getKthElement(nums1, nums2[compareIdx:], k-(nums2Idx+1)) } else { if len(nums1) \u003c= compareIdx { return getKthElement([]int{}, nums2, k-(nums1Idx+1)) } return getKthElement(nums1[compareIdx:], nums2, k-(nums1Idx+1)) } } func min(x, y int) int { if x \u003c y { return x } return y } ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:3:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode"],"content":"summery 这道题对二分的运用比较灵活，主要是二分的对象变了，但是思想还在。正常的二分是对数组的长度进行二分，而此题的二分却是先确定中位数的位置，再利用二分的思想去到两个数组中分别寻找排除，非常巧妙，受益匪浅。 ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:4:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"}]