[{"categories":["gamedev"],"content":"enemy sync flow ","date":"2022-10-05","objectID":"/frame_sync/:1:0","tags":["gamedev","frame_sync"],"title":"frame-sync","uri":"/frame_sync/"},{"categories":["leetcode"],"content":"Longest-Palindromic-Substring ","date":"2022-10-04","objectID":"/longest_palindromic_substring/:1:0","tags":["dynamic-programming"],"title":"longest palindromic substring","uri":"/longest_palindromic_substring/"},{"categories":["leetcode"],"content":"é¢˜ç›®æè¿° Given a string s,return the longest palindromic substring in sã€‚ ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²s, è¿”å›æœ€é•¿çš„å›æ–‡å­å­—ç¬¦ä¸²ã€‚ example 1 Input: s = \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. example 2 Input: s = \"cbbd\" Output: \"bb\" example 3 Input: s = \"a\" Output: \"a\" example 4 Input: s = \"ac\" Output: \"a\" é™åˆ¶ 1\u003c=s.length \u003c=1000 s consist of only digits and english letters https://leetcode-cn.com/problems/longest-palindromic-substring/ ","date":"2022-10-04","objectID":"/longest_palindromic_substring/:1:1","tags":["dynamic-programming"],"title":"longest palindromic substring","uri":"/longest_palindromic_substring/"},{"categories":["leetcode"],"content":"é¢˜ç›®åˆ†æ è¿™é¢˜åº”è¯¥ç”¨åŠ¨æ€è§„åˆ’æ¥åšã€‚ä¸ºä»€ä¹ˆ,é¦–å…ˆè¦æƒ³ä½¿ç”¨åŠ¨æ€è§„åˆ’æ˜¯éœ€è¦æ»¡è¶³å‡ ä¸ªæ¡ä»¶çš„ã€‚ é—®é¢˜è¦æœ‰æœ€ä¼˜å­ç»“æ„ :: æœ€ä¼˜å­ç»“æ„å°±æ˜¯é€’å½’åˆ†è§£åï¼Œç»“æ„æœ€å°çš„é—®é¢˜ é—®é¢˜è¦èƒ½å¤Ÿé€’å½’åˆ†è§£ :: é€’å½’åˆ†è§£ï¼Œåˆå«è½¬ç§»æ–¹ç¨‹ï¼Œé—®é¢˜è¢«ä¸æ–­é€’å½’æ‹†è§£æˆä¸€ä¸ªä¸ªå°çš„é—®é¢˜ å­é—®é¢˜çš„æœ€ä¼˜è§£å†³å®šäº†çˆ¶é—®é¢˜çš„æœ€ä¼˜è§£ æœ‰å¾ˆå¤šçš„é‡å é—®é¢˜ :: å½“é—®é¢˜æœ‰é‡å é—®é¢˜æ—¶ï¼Œé‡å çš„é—®é¢˜ä¼šè¢«ä¸æ–­çš„è®¡ç®—ï¼Œè¿™æ—¶å€™å¯ä»¥å°†é‡å  é—®é¢˜çš„ç»“æœå­˜å‚¨èµ·æ¥ï¼Œä¸‹æ¬¡åœ¨æ¬¡è®¡ç®—è¿™ä¸ªé—®é¢˜çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥å»å–ç»“æœï¼Œç”¨ç‰ºç‰²å°‘é‡å†…å­˜ çš„æ–¹æ³•æ¥åŠ é€Ÿè®¡ç®— å…·ä½“åˆ†æ é¦–å…ˆæˆ‘ä»¬çœ‹çœ‹èƒ½ä¸èƒ½é€’å½’æ‹†è§£è¿™ä¸ªé—®é¢˜ æœ€é•¿çš„å›æ–‡å­—ä¸²ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªæ€§è´¨: æœ€é•¿çš„å›æ–‡å­—ç¬¦ä¸²ï¼Œä»–çš„å­ä¸²ä¸€å®šä¹Ÿæ˜¯ä¸€ä¸ªå›æ–‡å­—ç¬¦ä¸²ã€‚ å¦‚æœä»–æœ‰ä»»æ„ä¸€ä¸ªå­—ä¸²ï¼Œä»–ä¸æ˜¯å›æ–‡å­—ç¬¦ä¸²ï¼Œé‚£ä»–å°±ä¸æ„æˆå›æ–‡äº†ã€‚å› ä¸ºå›æ–‡ä¸€å®šæ˜¯\"a\",â€œaaâ€ â€œaba\"è¿™ä¸‰ç§å½¢å¼ã€‚æ‰€ä»¥åˆ°è¿™é‡Œæœ€ä¼˜å­ç»“æ„ä¹Ÿå°±å‡ºæ¥äº†ã€‚ æœ€ä¼˜å­ç»“æ„ â€œaâ€ â€œaaâ€ ä»»æ„çš„å›æ–‡å­—ç¬¦ä¸²ï¼Œä¸€å®šæ˜¯åœ¨è¿™ä¸¤ä¸ªç»“æ„çš„åŸºç¡€ä¸Šï¼Œé€šè¿‡åœ¨ä»–ä»¬ä¸¤ç«¯åŠ ä¸Šç›¸åŒçš„å­—ç¬¦å¤åˆè€Œæˆ è½¬ç§»æ–¹ç¨‹ æˆ‘ä»¬è®¾ pol(i,j)è¡¨ç¤ºä»iåˆ°jçš„å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›æ–‡å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆä»–å¯ä»¥è½¬åŒ–æˆä¸‹é¢çš„å½¢å¼ \\[pol(i,j) = pol(i+1,j-1)\\wedge(s[i]==s[j])\\] pol(i,j) è¦æƒ³ä¸ºçœŸ é‚£ä¹ˆä»–ä»i+1 åˆ° j-1 çš„å­å­—ç¬¦ä¸²å¿…é¡»æ˜¯å›æ–‡å­—ç¬¦ä¸²ï¼Œs[i]==s[j] ä¹Ÿå°±æ˜¯ä¸¤ç«¯å¿…é¡»å­—ç¬¦ç›¸åŒçš„æ—¶å€™ã€‚ \\[pol(i,j) = pol(i+1,j-1)\\wedge(s[i]==s[j])\\]æ‰€ä»¥è¿™å°±æ˜¯æˆ‘ä»¬çš„è½¬ç§»æ–¹ç¨‹å¼ è¿™é‡Œï¼Œæˆ‘ä»¬è¿˜è¦è€ƒè™‘è¾¹ç•Œæƒ…å†µ å½“å­—ç¬¦ä¸²é•¿åº¦ä¸º1çš„æ—¶å€™ï¼Œå› ä¸ºåªæœ‰ä¸€ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥ä»–æœ¬èº«å°±æ˜¯å›æ–‡ å½“å­—ç¬¦ä¸²é•¿åº¦ä¸º2çš„æ—¶å€™ï¼Œåªæœ‰ä¸¤ä¸ªå­—ç¬¦éƒ½ç›¸ç­‰ï¼Œæ‰è¡¨ç¤ºå®ƒæ˜¯å›æ–‡ \\begin{equation} \\begin{cases} pol(i,i)=true\\\\ p(i,i+1)=(s_{i}==s_{i+1}) \\end{cases} \\end{equation} æ•´ä¸ªé€’æ¨è¡¨è¾¾å¼å°±æ˜¯ \\begin{equation} pol(i,j)=\\begin{cases} true \u0026\\text{i=j}\\\\ s_{i}==s_{i+1} \u0026\\text{j-i=1}\\\\ pol(i+1,j-i)\\wedge(s[i]==s[j]) \u0026j-i\u003e=2 \\end{cases} \\end{equation} ","date":"2022-10-04","objectID":"/longest_palindromic_substring/:1:2","tags":["dynamic-programming"],"title":"longest palindromic substring","uri":"/longest_palindromic_substring/"},{"categories":["leetcode"],"content":"ä»£ç å®ç° #include \u003cvector\u003e #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; class Solution { public: string longestPalindrome(string s) { vector \u003cvector\u003cbool\u003e\u003e dp(s.length(),vector\u003cbool\u003e(s.length(),0)); for (int i = 1; i \u003c s.length(); ++i) { dp[i][i]=true; } int longest = 1; int start=0; for (int i=2; i \u003c= s.length(); ++i) { for (int j=0 ; j+i\u003c=s.length(); ++j) { if(i==2){ dp[j][j+1]=(s[j]==s[j+1]); if(longest \u003c=2 \u0026\u0026 dp[j][j+1]){ longest = i; start=j; } continue; } dp[j][j+i-1]=dp[j+1][j+i-2] \u0026\u0026 (s[j]==s[j+i-1]); if(dp[j][j+i-1] \u0026\u0026 i\u003e=longest){ longest = i; start=j; } } } cout \u003c\u003c longest\u003c\u003c endl; return s.substr(start, longest); } }; int main() { Solution *s = new Solution(); cout \u003c\u003c s-\u003elongestPalindrome(\"bb\") \u003c\u003cendl; } ","date":"2022-10-04","objectID":"/longest_palindromic_substring/:1:3","tags":["dynamic-programming"],"title":"longest palindromic substring","uri":"/longest_palindromic_substring/"},{"categories":["leetcode"],"content":"Problem description ","date":"2022-10-04","objectID":"/3sum/:1:0","tags":["leetcode"],"title":"3sum","uri":"/3sum/"},{"categories":["leetcode"],"content":"Analyse è¿™é“é¢˜éš¾ç‚¹åœ¨äºä¸é‡å¤çš„ä¸‰å…ƒç»„ï¼Œä½†æ˜¯ä¸‰é‡æšä¸¾åä¸æ–­é€šè¿‡å“ˆå¸Œå»å»é‡çš„æ¶ˆè€—å¤ªé«˜ä¸åˆé€‚ã€‚è§£å†³è¿™ä¸ªéš¾ç‚¹çš„å¯ä»¥å…ˆå°†æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åæŒ‰ç…§é¡ºåºå»æšä¸¾å½“é‡åˆ°ç›¸åŒçš„å…ƒç´ æ—¶ï¼Œç›´æ¥è·³è¿‡ï¼Œè¿™æ ·å°±é¿å…äº†ä¹‹åéœ€è¦å“ˆå¸Œå»é‡çš„éº»çƒ¦äº‹ã€‚ è¿™é“é¢˜çš„ä¸‰é‡æšä¸¾å¯ä»¥ä¼˜åŒ–æˆä¸¤é‡ã€‚å½“ a+b+c = 0(a\u003c=b\u003c=c)ï¼Œåœ¨è¿›è¡Œä¸‹ä¸€æ¬¡äºŒé‡æšä¸¾çš„è‹¥æœ‰æ»¡è¶³æ¡ä»¶çš„ç»„åˆ,ä¼šæœ‰ a+b`+c`=0(b`\u003eb \u0026\u0026 c`\u003cc) è¿™æ„å‘³ç€ï¼Œæˆ‘ä»¬ä¸å¿…åœ¨ç¬¬ä¸‰é‡æšä¸¾æ—¶æšä¸¾æ‰€æœ‰å‰©ä¸‹çš„å…ƒç´ ï¼Œåªéœ€è¦æšä¸¾æ¯”ä¸Šä¸€æ¬¡æ»¡è¶³è¦æ±‚ç»„åˆä¸­æ¯”cå°çš„å…ƒç´ å³å¯ã€‚ æˆ‘ä»¬å¯ä»¥é‡‡ç”¨åŒæŒ‡é’ˆçš„æ€æƒ³ï¼Œè®©ç¬¬äºŒè½®çš„second å›ºå®šï¼Œä¸æ–­å‘å·¦å¹³ç§»thridä¸‹æ ‡ ","date":"2022-10-04","objectID":"/3sum/:2:0","tags":["leetcode"],"title":"3sum","uri":"/3sum/"},{"categories":["leetcode"],"content":"Implement package main import ( \"fmt\" \"sort\" ) func threeSum(nums []int) [][]int { if len(nums) \u003c 3 { return [][]int{} } result := [][]int{} sort.Ints(nums) for i := 0; i \u003c= len(nums)-3; i++ { if i \u003e 0 \u0026\u0026 nums[i] == nums[i-1] { continue } k := len(nums) - 1 target := -1 * nums[i] for j := i + 1; j \u003c= len(nums)-2; j++ { if j \u003e i+1 \u0026\u0026 nums[j] == nums[j-1] { continue } for j \u003c k \u0026\u0026 nums[j]+nums[k] \u003e target { k-- } if j == k { break } if nums[j]+nums[k] == target { result = append(result, []int{nums[i], nums[j], nums[k]}) } } } return result } #include \u003calgorithm\u003e #include \u003cvector\u003e using namespace std; class Solution { public: vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) { vector\u003cvector\u003cint\u003e\u003e result; if (nums.size() \u003c 3) { return result; } sort(nums.begin(),nums.end()); for (int i=0; i\u003cnums.size(); ++i) { if (i\u003e0 \u0026\u0026 nums[i]==nums[i-1]) { continue; } int third = nums.size()-1; int target = -nums[i]; for (int j=i+1; j\u003cnums.size(); j++) { if (j\u003ei+1 \u0026\u0026 nums[j] == nums[j-1]) { continue; } while(j\u003cthird \u0026\u0026 nums[j]+nums[third] \u003e target){ third--; } if (third == j) { break; } if(nums[j]+nums[third] == target){ result.push_back({nums[i],nums[j],nums[third]}); } } } return result; } }; ","date":"2022-10-04","objectID":"/3sum/:3:0","tags":["leetcode"],"title":"3sum","uri":"/3sum/"},{"categories":["leetcode"],"content":"Summery è§£é¢˜çš„æ—¶å€™è¿˜æ˜¯åº”è¯¥å¤šå¤šæ€è€ƒé¢˜ç›®å·²çŸ¥æ¡ä»¶æ‰€å¸¦æ¥çš„ä¸€äº›æ€§è´¨ï¼Œè¿™é¢˜å°±ç”¨åˆ°äº†æ•°å­—å¯ä»¥æ’åºçš„æ€§è´¨æ¥è§£å†³é‡å¤æšä¸¾çš„é—®é¢˜ã€‚æ–°çš„ç¬¬ä¸‰è½®çš„æšä¸¾å€¼å¿…å®šå°äºä¸Šä¸€æ¬¡æˆåŠŸçš„ç¬¬ä¸‰è½®æšä¸¾å€¼ï¼Œå¯ä»¥ç”¨æ¥ä¼˜åŒ–ä»£ç ã€‚ ","date":"2022-10-04","objectID":"/3sum/:4:0","tags":["leetcode"],"title":"3sum","uri":"/3sum/"},{"categories":["leetcode","divide-and-conquer"],"content":"Description Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/median-of-two-sorted-arrays è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. Example 3: Input: nums1 = [0,0], nums2 = [0,0] Output: 0.00000 Example 4: Input: nums1 = [], nums2 = [1] Output: 1.00000 Example 5: Input: nums1 = [2], nums2 = [] Output: 2.00000 Constraints: nums1.length == m nums2.length == n 0 \u003c= m \u003c= 1000 0 \u003c= n \u003c= 1000 1 \u003c= m + n \u003c= 2000 -106 \u003c= nums1[i], nums2[i] \u003c= 106 ","date":"2022-10-04","objectID":"/median_of_two_sorted_arrays/:1:0","tags":["leetcode","divide-and-conquer"],"title":"Median of Two Sorted Arrays","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode","divide-and-conquer"],"content":"Analyse è¿™é“é¢˜æœ€ç®€å•çš„æƒ³æ³•å°±æ˜¯å…ˆå½’å¹¶åˆ°ä¸€ä¸ªæ•°ç»„ï¼Œç„¶åå†æŠŠä¸­ä½æ•°æ‰¾åˆ°ï¼Œä½†æ˜¯æ­¤æ—¶çš„æ—¶é—´å¤æ‚åº¦ ä¸º\\(o(m+n)\\) ä¸ç¬¦åˆé¢˜æ„ã€‚é¢˜ç›®è¦æ±‚çš„æ˜¯ \\(o(\\log(m+n))\\) ã€‚æ­¤æ—¶æˆ‘ä»¬èƒ½æƒ³åˆ°çš„åº”è¯¥å°±åªæœ‰ äºŒåˆ†æ³•äº†ï¼Œå¯¹äºæœ‰åºæ•°ç»„ï¼ŒäºŒåˆ†æ³•æ€»èƒ½éå¸¸æœ‰æ•ˆçš„é™ä½ç®—æ³•çš„å¤æ‚åº¦ã€‚ä½†æ˜¯å¦‚ä½•äºŒåˆ†æˆä¸ºä¸€ ä¸ªé—®é¢˜ã€‚ä¸­ä½æ•°æŒ‡çš„æ˜¯ä¸€ä¸ªæ•°åˆ—ä¸­é—´çš„æ•°ã€‚è®¾ len = len(array) è¿™é‡Œçš„/ä¸ºæ•´é™¤ \\begin{equation} \\label{ä¸­ä½æ•°å…¬å¼} medium = \\begin{cases} \\frac{array[len/2-1] + array[len/2]}{2} \u0026len\\mod 2=0 \\\\ \\frac{array[len/2-1]}{2}\u0026 len\\mod 2\\neq 0 \\end{cases} \\end{equation} è¿™é“é¢˜æ˜¯å¯»æ‰¾ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­ä½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å§‘ä¸”å‡è®¾ä»–ä»¬å·²ç»åˆå¹¶åçš„æ•°ç»„ä¸º nums3 æˆ‘ä»¬è¦åœ¨nums3ä¸­å¯»æ‰¾ä¸­ä½æ•°ã€‚æ­¤æ—¶ nums3 çš„é•¿åº¦æˆ‘ä»¬æ˜¯çŸ¥é“çš„(m+n) é‚£ä¹ˆå…¶ä¸­ä½æ•°çš„åº”è¯¥ ä¸ºç¬¬ k= \\(\\frac{m+n}{2}\\) ä¸ªæ•°ï¼ˆè¿™é‡Œæˆ‘ä»¬å…ˆåªçœ‹å¥‡æ•°æƒ…å†µã€‚è¿™æ—¶æˆ‘ä»¬å¯ä»¥å¯¹kè¿›è¡ŒäºŒåˆ†å¤„ ç†ï¼Œåˆ†åˆ«æ‰¾åˆ°ä¸¤ä¸ªsæ•°ç»„ä¸­ç¬¬\\(\\frac{k}{2}\\) ä¸ªæ•°è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åæ’é™¤è¾ƒå°çš„ä»¥åŠå®ƒæ‰€åœ¨æ•° ç»„ä¸­åœ¨å®ƒå‰é¢çš„æ•°ã€‚å› ä¸ºä»–ä»¬æ˜¯ä¸å¯èƒ½æˆä¸ºä¸­ä½æ•°çš„ã€‚å¯¹äº nums1[k/2-1] å’Œ nums2[k/2-1] åœ¨å®ƒä»¬ä¹‹å‰çš„åªæœ‰ k/2-1 + k/2-1 = k -2 ä¸ªæ•°ã€‚å³ä½¿ç®—ä¸Šè¾ƒå°çš„é‚£ä¸ªæ•°ï¼Œ ä¹Ÿåªèƒ½åˆ°ç¬¬k-1ä¸ªæ•°ã€‚æ‰€ä»¥ä»–ä»¬æ˜¯ä¸å¯èƒ½æˆä¸ºç¬¬kä¸ªæ•°çš„ã€‚è¿™æ—¶æˆ‘ä»¬è®© k = k-A(Aä¸ºå·²ç»æ’é™¤ çš„æ•°çš„ä¸ªæ•°) ç„¶åç»§ç»­å¯¹å‰©ä¸‹çš„æ•°ç»„è¿›è¡ŒåŒæ ·çš„æ“ä½œã€‚ è¿™é‡Œä¼šå‡ºç°ä¸¤ç§æƒ…å†µ å¦‚æœ nums1[k/2-1] \u003e= nums2[k/2-1] åˆ™ç›´æ¥æ’é™¤nums1[k/2-1] åŠå…¶å‰é¢çš„æ•° å¦‚æœ nums1[k/2-1] \u003c nums2[k/2-1] åˆ™ç›´æ¥æ’é™¤nums2[k/2-1] åŠå…¶å‰é¢çš„æ•° åœ¨æ’é™¤è¿‡ç¨‹ä¸­æˆ‘ä»¬è¿˜ä¼šé‡åˆ°å‡ ç§æƒ…å†µ k/2-1 è¶Šç•Œï¼Œè¿™ç§æƒ…å†µå–æœ€åä¸€ä¸ªå…ƒç´  k=1 ç›´æ¥è¿”å›è¾ƒå°çš„å…ƒç´  æ•°ç»„ä¸ºç©ºï¼Œç›´æ¥å»éç©ºæ•°ç»„ä¸­å¯»æ‰¾å³å¯ ","date":"2022-10-04","objectID":"/median_of_two_sorted_arrays/:2:0","tags":["leetcode","divide-and-conquer"],"title":"Median of Two Sorted Arrays","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode","divide-and-conquer"],"content":"Implement //c++ version #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e int main(int argc, char *argv[]) { Solution s; vector\u003cint\u003e nums1 = new vector\u003cint\u003e(); vector\u003cint\u003e nums2 = new vector\u003cint\u003e(); for(int i = 1;i\u003c10;i++){ nums1.push_back(i); } for(int i= 1;i\u003c10;i=i+2){ nums2.push_back(i); } s.findMedianSortedArrays(nums1,nums2); return 0; } class Solution { public: double findMedianSortedArrays(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { int k = nums1.size() + nums2.size(); if(k%2 == 0){ return min(getKthElement(nums1, nums2, k/2+1),getKthElement(nums1, nums2,k/2))/2.0; }else{ return getKthElement(nums1,nums2,k/2); } } double getKthElement(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2,int k){ int index1 = 0; int index2 = 0; int m = nums1.size(); int n = nums2.size(); while (true){ if (index1 == m){ return nums2[index2+k-1]; } if(index2 == n){ return nums1[index1 +k -1]; } if(k == 1){ return min(nums1[index1],nums2[index2]); } int newIndex1 = min(index1+k/2-1,m-1); int newIndex2 = min(index2+k/2-1,n-1); if(nums1[newIndex1] \u003e= nums2[newIndex2]){ k -= newIndex2 - index2 +1; index2 = newIndex2+1; }else{ k -= newIndex1 - index1 +1; index1 = newIndex1+1; } } } }; //GO version package main import ( \"fmt\" \"math\" ) func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { k := int(math.Ceil((float64(len(nums1)) + float64(len(nums2))) / 2)) if (len(nums1)+len(nums2))%2 == 0 { foo1 := getKthElement(nums1, nums2, k) foo2 := getKthElement(nums1, nums2, k+1) return float64(foo1+foo2) / 2 } else { return float64(getKthElement(nums1, nums2, k)) } } func getKthElement(nums1 []int, nums2 []int, k int) int { if len(nums1) == 0 { return nums2[k-1] } if len(nums2) == 0 { return nums1[k-1] } compareIdx := k / 2 if compareIdx == 0 { return min(nums1[0], nums2[0]) } nums1Idx := min(len(nums1)-1, compareIdx-1) nums2Idx := min(len(nums2)-1, compareIdx-1) if nums1[nums1Idx] \u003e= nums2[nums2Idx] { if len(nums2) \u003c= compareIdx { return getKthElement(nums1, []int{}, k-(nums2Idx+1)) } return getKthElement(nums1, nums2[compareIdx:], k-(nums2Idx+1)) } else { if len(nums1) \u003c= compareIdx { return getKthElement([]int{}, nums2, k-(nums1Idx+1)) } return getKthElement(nums1[compareIdx:], nums2, k-(nums1Idx+1)) } } func min(x, y int) int { if x \u003c y { return x } return y } ","date":"2022-10-04","objectID":"/median_of_two_sorted_arrays/:3:0","tags":["leetcode","divide-and-conquer"],"title":"Median of Two Sorted Arrays","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode","divide-and-conquer"],"content":"summery è¿™é“é¢˜å¯¹äºŒåˆ†çš„è¿ç”¨æ¯”è¾ƒçµæ´»ï¼Œä¸»è¦æ˜¯äºŒåˆ†çš„å¯¹è±¡å˜äº†ï¼Œä½†æ˜¯æ€æƒ³è¿˜åœ¨ã€‚æ­£å¸¸çš„äºŒåˆ†æ˜¯å¯¹æ•° ç»„çš„é•¿åº¦è¿›è¡ŒäºŒåˆ†ï¼Œè€Œæ­¤é¢˜çš„äºŒåˆ†å´æ˜¯å…ˆç¡®å®šä¸­ä½æ•°çš„ä½ç½®ï¼Œå†åˆ©ç”¨äºŒåˆ†çš„æ€æƒ³å»åˆ°ä¸¤ä¸ªæ•° ç»„ä¸­åˆ†åˆ«å¯»æ‰¾æ’é™¤ï¼Œéå¸¸å·§å¦™ï¼Œå—ç›ŠåŒªæµ…ã€‚ ","date":"2022-10-04","objectID":"/median_of_two_sorted_arrays/:4:0","tags":["leetcode","divide-and-conquer"],"title":"Median of Two Sorted Arrays","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode","interval-scheduling"],"content":"è¿™é“é¢˜çš„æ ¸å¿ƒæ˜¯åŒæŒ‡é’ˆå’Œè´ªå¿ƒç®—æ³•ï¼Œé€šè¿‡ä¸æ–­ç§»åŠ¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œæ‰¾åˆ°å±€éƒ¨æœ€ä¼˜è§£ï¼Œå¦‚æœå±€éƒ¨æœ€ä¼˜è§£ä¼˜äºå…¨å±€æœ€ä¼˜è§£ï¼Œåˆ™åˆ·æ–°å…¨å±€æœ€ä¼˜è§£ã€‚","date":"2022-10-04","objectID":"/container_with_most_water/","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"1 Description https://leetcode-cn.com/problems/container-with-most-water/ ","date":"2022-10-04","objectID":"/container_with_most_water/:1:0","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"2.analyze problem è¿™é“é¢˜çš„æ ¸å¿ƒæ˜¯åŒæŒ‡é’ˆå’Œè´ªå¿ƒç®—æ³•ï¼Œé€šè¿‡ä¸æ–­ç§»åŠ¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œæ‰¾åˆ°å±€éƒ¨æœ€ä¼˜è§£ï¼Œå¦‚æœå±€éƒ¨æœ€ ä¼˜è§£ä¼˜äºå…¨å±€æœ€ä¼˜è§£ï¼Œåˆ™åˆ·æ–°å…¨å±€æœ€ä¼˜è§£ã€‚ ","date":"2022-10-04","objectID":"/container_with_most_water/:2:0","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"2.1 slove step åˆ†é…ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘æ•°ç»„çš„å¤´å°¾ [1,8,6,2,5,4,8,3,7] l r è®¡ç®—é¢ç§¯å¹¶ä¸å…¨å±€æœ€ä¼˜è§£åšæ¯”è¾ƒï¼Œå¦‚æœå¤§äºå…¨å±€æœ€ä¼˜è§£ï¼Œåˆ·æ–°å…¨å±€æœ€ä¼˜è§£ã€‚å¹¶ä¸”ç§»åŠ¨å¯¹åº” æ•°å­—è¾ƒå°çš„é‚£ä¸ªæŒ‡é’ˆ(å‘å¯¹åº”æ•°å­—è¾ƒå¤§çš„æ–¹å‘ç§»åŠ¨) [1,8,6,2,5,4,8,3,7] l r é‡å¤ä¸Šè¿°æ“ä½œç›´åˆ°æŒ‡é’ˆç›¸é‡ ","date":"2022-10-04","objectID":"/container_with_most_water/:2:1","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"2.2 certify éœ€è¦è¯¥è§£æ³•éœ€è¦è¯æ˜çš„æ˜¯ï¼Œä¸ºä»€ä¹ˆæ¯æ¬¡ç§»åŠ¨å¯¹åº”å€¼è¾ƒå°çš„æŒ‡é’ˆæ˜¯æ­£ç¡®çš„ã€‚ åŒæŒ‡é’ˆä»£è¡¨çš„æ˜¯ å¯ä»¥ä½œä¸ºå®¹å™¨è¾¹ç•Œçš„æ‰€æœ‰ä½ç½®çš„èŒƒå›´ ç§»åŠ¨æŒ‡é’ˆå°±ä»£è¡¨è¿™ä¸ªæŒ‡é’ˆä¸å¯èƒ½å†ä½œ ä¸ºå®¹å™¨çš„è¾¹ç•Œäº†ã€‚ ä¸ºä»€ä¹ˆæŒ‡å‘è¾ƒå°å€¼çš„æŒ‡é’ˆä¸å¯èƒ½å†ä½œä¸ºå®¹å™¨çš„è¾¹ç•Œäº† ã€‚å‡è®¾å½“å‰å·¦æŒ‡é’ˆ å’Œå³æŒ‡é’ˆæŒ‡å‘çš„æ•°åˆ†åˆ«ä¸º\\(x\\) å’Œ\\(y\\), ä¸å¤±ä¸€èˆ¬æ€§ï¼Œæˆ‘ä»¬å‡è®¾ \\(x \\leq y\\) ä¸¤ä¸ªæŒ‡é’ˆä¹‹é—´çš„ è·ç¦»ä¸ºtã€‚é‚£ä¹ˆï¼Œä»–ä»¬ç»„æˆçš„å®¹å™¨çš„å®¹é‡ä¸ºï¼š \\begin{equation} \\min(x,y)*t = x*t \\end{equation} å¦‚æœæˆ‘ä»¬ä¿æŒå·¦æŒ‡é’ˆçš„ä½ç½®ä¸å˜ï¼Œé‚£ä¹ˆæ— è®ºå³æŒ‡é’ˆåœ¨å“ªé‡Œï¼Œè¿™ä¸ªå®¹å™¨çš„å®¹é‡éƒ½ä¸ä¼šè¶…è¿‡\\(x*t\\) ã€‚ ä¸ºä»€ä¹ˆå‘¢ï¼Œè¿™é‡Œæˆ‘ä»¬åªè€ƒè™‘å½“æŒ‡é’ˆè¿˜æŒ‡å‘å·¦å³è¾¹ç•Œçš„æ—¶å€™ã€‚æˆ‘ä»¬ä»»æ„å‘å·¦ç§»åŠ¨å³æŒ‡ é’ˆï¼ŒæŒ‡å‘çš„æ•°ä¸º \\(y_{1}\\) ï¼Œä¸¤ä¸ªæŒ‡é’ˆä¹‹é—´çš„è·ç¦»ä¸º \\(t_{1}\\) ï¼Œ\\(t_{1} \u003c t\\) ï¼Œå¹¶ä¸”\\(min(x,y_{1}) \\le min(x,y)\\) å¦‚æœ \\(y_{1} \\le y\\), then \\(min(x,y_{1}) \\le min(x,y)\\) ; å¦‚æœ \\(y_{1} \\ge y\\), then \\(min(x,y_{1}) =x= min(x,y)\\) ; æ‰€ä»¥æœ‰ \\begin{equation} \\min(x,y_{t})*t_{1} \u003c min(x,y)*t \\end{equation} è¿™è¡¨æ˜æŒ‡å‘è¾ƒå°å€¼çš„æŒ‡é’ˆä¸å¯ä»¥å†ä½œä¸ºå®¹å™¨çš„è¾¹ç•Œï¼Œå› ä¸ºæ— è®ºå¦‚ä½•ç§»åŠ¨è¾ƒå¤§çš„æŒ‡é’ˆï¼Œå®¹å™¨çš„ å®¹é‡éƒ½ä¸ä¼šå†å˜å¤§ã€‚è¿™ä¸ªè¾¹ç•Œåº”è¯¥è¢«èˆå¼ƒã€‚ ","date":"2022-10-04","objectID":"/container_with_most_water/:2:2","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"3 implementation //c++ version #include \u003calgrothim\u003e #include \u003ciostream\u003e #include \u003cmath\u003e using namespace std; class Solution { public: int maxArea(vector\u003cint\u003e \u0026height) { int left = 0; int right = height.size()-1; int compacity = 0; while (left \u003c right) { int min = fmin(height[left], height[right]); int length = right - left; int tmpCompacity = min * length; if (tmpCompacity \u003e= compacity) compacity = tmpCompacity; if (height[left] \u003e= height[right]) right--; else left++; } return compacity; } }; int main(int argc, char *argv[]) { return 0; } //go version import \"math\" func maxArea(height []int) int { front := 0 end := len(height)-1 var maxCompacity float64 = 0 for front \u003c end { longSide := math.Min(float64(height[front]),float64(height[end])) shotSide := float64(end-front) tmpCompacity := longSide*shotSide maxCompacity = math.Max(tmpCompacity,maxCompacity) if height[front] \u003e= height[end] { end-- }else{ front++ } } return int(maxCompacity) } ","date":"2022-10-04","objectID":"/container_with_most_water/:3:0","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["leetcode","interval-scheduling"],"content":"4 summery è¿™é“é¢˜ç”¨åˆ°äº†åŒæŒ‡é’ˆ+è´ªå¿ƒç®—æ³•ã€‚ä»¥åéƒ½å¯ä»¥ç”¨åŒæŒ‡é’ˆå¯¹æ’çš„æ€æƒ³å»æ±‚è§£è¿™ç±»é—®é¢˜ï¼Œé‡ç‚¹åœ¨ äºå¦‚ä½•æ‰¾åˆ°åº”è¯¥ç§»åŠ¨çš„æŒ‡é’ˆã€‚å½“å› å­åˆ†å¸ƒå†æ•°ç»„çš„ä¸¤è¾¹çš„æ—¶å€™ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨åŒæŒ‡é’ˆçš„æ–¹æ³• æ±‚è§£ã€‚è¿™é¢˜çš„è´ªå¿ƒå¹¶ä¸æ˜æ˜¾ï¼Œåªåœ¨æ›´æ–°æœ€å¤§çš„å®¹é‡çš„æ—¶å€™è¿›è¡Œäº†è´ªå¿ƒã€‚è´ªå¿ƒçš„æ€æƒ³æ˜¯æ¯ä¸€æ­¥ åªé€‰æ‹©å½“å‰è®¤ä¸ºçš„æœ€ä¼˜è§£ã€‚ ","date":"2022-10-04","objectID":"/container_with_most_water/:4:0","tags":["leetcode"],"title":"Container With Most Water","uri":"/container_with_most_water/"},{"categories":["tools"],"content":"å¦‚ä½•å°†æ—¶é—´è°ƒè¯•å·¥å…·libfaketiem , roswell, å’Œemacs ç»“åˆèµ·æ¥æ–¹ä¾¿çš„åšæ—¶é—´æµ‹è¯•","date":"2022-10-04","objectID":"/libfaketime/","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs æ—¶é—´æµ‹è¯•å°è¯•","uri":"/libfaketime/"},{"categories":["tools"],"content":"å¦‚æœä½ å†™çš„ç¨‹åºç»å¸¸ä¾èµ–æ—¶é—´å»åšä¸€äº›é€»è¾‘æ§åˆ¶ï¼Œé‚£ä¹ˆä½ å¯èƒ½å¯¹è°ƒæ—¶é—´è¿™ä»¶äº‹æ¯”è¾ƒæ•æ„Ÿï¼Œä½ å¯èƒ½è¯´ä¸ä¸Šè®¨åŒï¼Œä½†æ˜¯ä¸€å®šä¸å–œæ¬¢ã€‚ç”µè„‘é¢‘ç¹è°ƒæ—¶é—´ä¼šå¯¼è‡´ä¸€äº›æ„æƒ³ä¸åˆ°çš„é—®é¢˜ï¼Œæ¯”å¦‚åœ¨æˆ‘ä½¿ç”¨çš„mac m1 mini ä¸Šå°±ä¼šæœ‰äº¤æ¢å†…å­˜æš´æ¶¨40ä¸ªgçš„é—®é¢˜ã€‚è¿˜ä¼šå¯¼è‡´æ¢¯å­å¤±æ•ˆæ— æ³•è®¿é—®å¤–ç½‘ã€‚å†æ¯”å¦‚ä½ ä»¥ä¸ºæ‰ä¸Šåˆ12ç‚¹ï¼Œå®é™…ä¸Šå·²ç»æ™šä¸Šéƒ½å·²ç»ä¸‹ç­äº†,ä½ å¯¹æ—¶é—´æ²¡æœ‰æ¦‚å¿µäº†ã€‚å¦‚æœå¾€å›è°ƒæ—¶é—´æˆ‘çš„emacsè¿˜ä¼šå¡æ­»ğŸ˜®â€ğŸ’¨ã€‚ æ€»ä¹‹è°ƒæ—¶é—´å¥½åƒæ˜¯ä¸€ä»¶å°äº‹ï¼Œä½†æ˜¯å½±å“å´å¾ˆå¤§ã€‚ æ‰€ä»¥æˆ‘ä¸€ç›´åœ¨å°è¯•å¦‚ä½•åœ¨ä¸è°ƒæ—¶é—´çš„æƒ…å†µä¸‹ï¼Œç»™æŒ‡å®šç¨‹åºä¸€ä¸ªå‡çš„æ—¶é—´ã€‚æˆ‘æ›¾è¯•è¿‡ç”¨å®¹å™¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸è¿‡å®¹å™¨å†…çš„æ—¶é—´ä¼šå®šæ—¶å’Œå®¿ä¸»æœºåŒæ­¥ï¼Œå¹¶ä¸èƒ½è§£å†³æ—¶é—´é—®é¢˜ã€‚åæ¥æˆ‘å‘ç°äº†libfaketimeè¿™ä¸ªå·¥å…·ï¼Œä¸è¿‡å¼„äº†åŠå¤©ä¸€ç›´æ²¡èƒ½åœ¨æˆ‘çš„mac m1 ä¸Šæ­£å¸¸ä½¿ç”¨ã€‚æœ€è¿‘æˆ‘åˆé‡åˆ°äº†è¦é¢‘ç¹è°ƒæ—¶é—´çš„æƒ…å†µï¼Œæ‰€ä»¥ä¸‹å®šå†³å¿ƒè¦è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ é‚£ä¹ˆåœ¨è¿™ç¯‡blogä¸­ï¼Œä½ å°†çœ‹åˆ°å¦‚ä½•ä½¿ç”¨libfaketime,å¦‚ä½•ä½¿ç”¨roswellè„šæœ¬åˆ¶ä½œæŒ‡å®šç¨‹åºçš„libfaketime ç¯å¢ƒï¼ˆå…ˆåˆå§‹åŒ–æ—¶é—´ç¯å¢ƒï¼Œå†å¯åŠ¨æŒ‡å®šç¨‹åºï¼‰ï¼Œæœ€åæ˜¯å¦‚ä½•ä½¿ç”¨emacsä¸€é”®å¯åŠ¨ã€‚ ","date":"2022-10-04","objectID":"/libfaketime/:0:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs æ—¶é—´æµ‹è¯•å°è¯•","uri":"/libfaketime/"},{"categories":["tools"],"content":"libfaketime å®‰è£… å¯¹äºä¸åŒçš„ç¯å¢ƒï¼Œlibfaketimeçš„å®‰è£…æ–¹æ³•ä¹Ÿä¸ç›¸åŒã€‚ å¯¹äºmacå¦‚æœä½ ä½¿ç”¨homebrew(homebrewå¦‚ä½•å®‰è£…æˆ‘å°±ä¸èµ˜è¿°äº†) brew install libfaketime å¯¹äºlinux ä½ å¯ä»¥ç ”ç©¶ä¸‹è‡ªå·±å‘è¡Œç‰ˆçš„åŒ…ç®¡ç†å™¨ï¼Œæ¯”å¦‚ubuntu sudo apt-get install libfaketime windowså˜›ï¼Œæˆ‘è®¨åŒwindowsæŠµåˆ¶ç¨‹åºå‘˜ä½¿ç”¨windowsã€‚æ‰€ä»¥å°±ä¸ä»‹ç»äº†ï¼ˆä¸è¿‡æˆ‘å»ºè®®ä½ ç”¨wsl,æŠŠwindowså½“ä½œlinuxçš„å­ç³»ç»ŸğŸ˜ï¼‰ è¿˜æœ‰ä¸€ç§æºç ç¼–è¯‘çš„å®‰è£…æ–¹å¼ï¼Œä½ ä»¬å¯ä»¥çœ‹ä¸‹libfaketime çš„è‡ªè¿°æ–‡ä»¶libfaketime-readme ","date":"2022-10-04","objectID":"/libfaketime/:1:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs æ—¶é—´æµ‹è¯•å°è¯•","uri":"/libfaketime/"},{"categories":["tools"],"content":"å¦‚ä½•ä½¿ç”¨libfaketime å®‰è£…å®Œæˆåï¼Œä½ æœ‰ä¸¤ä»¶äº‹æƒ…è¦åšã€‚ ç¬¬ä¸€ä¸ªè¯»ä¸€élibfaketimeçš„readmeã€‚å¯¹äºmacæ¥è¯´ä½ åº”è¯¥è¯»ä¸€élibfaketime-mac-readme ç¬¬äºŒä¸ªï¼Œä½ éœ€è¦çŸ¥é“libfaketimeçš„åŠ¨æ€é“¾æ¥åº“è¢«å‘åˆ°äº†å“ªä¸ªç›®å½•ä¸‹é¢(brewå®‰è£…çš„æ˜¯ /opt/homebrew/lib/faketime/libfaketime.1.dylib) libfaketimeå¤§æ¦‚çš„åŸç†å°±æ˜¯ï¼Œè®©ç¨‹åºé“¾æ¥libfaketimeçš„åº“è¾¾åˆ°æ”¹æ—¶é—´çš„ç›®çš„ï¼ˆå…è®¸æˆ‘è¿™ä¹ˆæ½¦è‰ğŸ˜„ï¼Œæ¯•ç«Ÿè¿™ä¸ªåº“ä¸æ˜¯æˆ‘å†™çš„ï¼‰ã€‚æ‰€ä»¥æˆ‘ä»¬åº”è¯¥è®©ç¨‹åºè‡ªå·±é“¾æ¥libfaketimeã€‚ åœ¨unixç¯å¢ƒä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡çš„æ–¹å¼æ¥è¾¾åˆ°è¿™ä¸ªç›®çš„ macä¸‹ä½ éœ€è¦ export DYLD_FORCE_FLAT_NAMESPACE=1 export DYLD_INSERT_LIBRARIES=/path/to/libfaketime.1.dylib linuxä¸‹ä½ éœ€è¦ export LDPRELOAD=/path/to/libfaketime.1.so åœ¨ä½ æ­£ç¡®è®¾ç½®äº†ä¸Šé¢çš„ç¯å¢ƒå˜é‡åï¼ˆmac ä¸‹æœ€å¥½é€šè¿‡export è®¾ç½®ç¯å¢ƒå˜é‡ï¼Œæˆ‘è¯•è¿‡ç›´æ¥åœ¨ç¨‹åºå‰é¢è®¾ç½®ä½†æ˜¯æ²¡æˆåŠŸï¼‰,ä½ å¯ä»¥é€šè¿‡åœ¨ç¨‹åºå¯åŠ¨å‰è®¾ç½® â€œfaketimeâ€ è¿™ä¸ªç¯å¢ƒå˜é‡æ¥è¾¾åˆ°æ§åˆ¶ç¨‹åºæ—¶é—´çš„ç›®çš„ã€‚ faketimeæœ‰å¾ˆå¤šä¸­è®¾ç½®æ ¼å¼ï¼Œæˆ‘åªä»‹ç»å¦‚ä½•è®¾ç½®æŒ‡å®šæ—¶é—´ï¼Œå¹¶è®©æ—¶é—´è‡ªç„¶æµé€çš„æ–¹æ³•ã€‚libfaketimeè¿˜æœ‰å¾ˆå¤šç”¨æ³•ï¼Œéƒ½å¯ä»¥åœ¨å®˜æ–¹çš„è‡ªè¿°æ–‡ä»¶é‡Œé¢çœ‹åˆ°ã€‚ ç°åœ¨ç›´æ¥ä¸Šå‘½ä»¤ export faketime_dont_reset=1 export faketime=\"@2022-08-20 00:00:00\" â€œ@â€œå­—ç¬¦å¾ˆå…³é”®ï¼Œæ²¡æœ‰â€â€@â€œæ—¶é—´å°†ä¸ä¼šè‡ªåŠ¨æµé€,å¦å¤–faketime_dont_resetè¿™ä¸ªå˜é‡æœ‰æ—¶å€™ä¹Ÿä¸ç”¨è®¾ç½®ï¼Œä½†æ˜¯å¦‚æœä½ å‘ç°ç¨‹åºæ—¶é—´å’Œä½ é¢„æœŸçš„ä¸ä¸€æ ·ï¼Œä½ åº”è¯¥æŠŠfaketime_dont_resetè®¾ç½®ä¸º1(å…·ä½“åŸå› ä½ å¯ä»¥å»çœ‹è‡ªè¿°æ–‡ä»¶) æœ€åä¸€æ­¥å°±æ˜¯å¯åŠ¨ç¨‹åºï¼Œä¸éœ€è¦æˆ‘æ•™ä½ å§ğŸ˜Š ","date":"2022-10-04","objectID":"/libfaketime/:2:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs æ—¶é—´æµ‹è¯•å°è¯•","uri":"/libfaketime/"},{"categories":["tools"],"content":"å¦‚ä½•ä½¿ç”¨roswell åˆå§‹åŒ–ä¸€ä¸ªlibfaketimeç¯å¢ƒ å…ˆä»‹ç»ä¸€ä¸‹roswellã€‚roswell æ˜¯ä¸€ä¸ªcommon lisp çš„å®ç°ç®¡ç†å·¥å…·ï¼Œä½†æ˜¯ä»–è‡ªèº«æœ‰æŒºå¤šçš„é™„å¸¦åŠŸèƒ½ã€‚å…¶ä¸­ä¸€ä¸ªå°±æ˜¯å¯ä»¥ä½œä¸ºbash è„šæœ¬çš„æ›¿ä»£å“ï¼Œç”¨common lisp å»å†™è„šæœ¬ã€‚è¿™æ ·çš„å¥½å¤„æ˜¯ï¼Œcommon lispè¦æ¯”shellè„šæœ¬å¥½å†™ä¸€ç‚¹ï¼ˆä¸»è¦æ˜¯ä¸åƒshellé‚£ä¹ˆå®¹æ˜“å‡ºé”™shellè„šæœ¬ä¸€ä¸ªç©ºæ ¼ä¸å¯¹éƒ½ä¸è¡ŒğŸ˜’ï¼‰ã€‚å†è€…å°±æ˜¯ï¼Œåˆ©ç”¨repl,ä½ å¯ä»¥éå¸¸æ–¹ä¾¿çš„è°ƒè¯•roswellè„šæœ¬ï¼ˆåŠ¨æ€è¯­è¨€çš„replç®€ç›´ä¸è¦å¤ªé¦™ï¼Œå¼€å‘æ•ˆç‡çœŸçš„è¦æ¯”goé‚£ç§é™æ€è¯­è¨€é«˜ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä¸é€‰goçš„åŸå› ï¼‰ã€‚ å¦‚æœä½ ä¸å–œæ¬¢common lisp, ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨pythonè¿™æ ·çš„è„šæœ¬è¯­è¨€ï¼Œä¹Ÿèƒ½è¾¾åˆ°ä¸€æ ·ç”šè‡³æ›´å¥½çš„æ•ˆæœã€‚æˆ‘ç®€å•ä»‹ç»ä¸€ä¸‹æˆ‘çš„æ€è·¯ï¼Œå…¶å®å°±ä¸€å¥è¯ï¼Œä½¿ç”¨è„šæœ¬è¯­è¨€å»è®¾ç½®libfaketimeçš„ä¸€ç³»åˆ—ç¯å¢ƒå˜é‡ï¼Œç„¶åå¯åŠ¨ç¨‹åºã€‚ä½ å¯ä»¥ç»™è„šæœ¬è¯­è¨€åŠ ä¸Šå‡ ä¸ªå‚æ•° æ¯”å¦‚ç¨‹åºçš„è·¯å¾„ï¼Œä½ æƒ³è¦è®¾ç½®çš„æ—¶é—´ç­‰ç­‰å»æ§åˆ¶è„šæœ¬çš„è¡Œä¸ºè¿™éƒ½å–å†³äºä½ è‡ªå·±äº† ä½¿ç”¨roswellä½œä¸ºè„šæœ¬ï¼Œä½ å°±éœ€è¦çŸ¥é“å¦‚ä½•ä½¿ç”¨common lispçš„ä¸€äº›ä¸ç³»ç»Ÿäº¤äº’çš„åº“ï¼Œæ¯”å¦‚å¦‚ä½•è§£æå‘½ä»¤è¡Œçš„å‚æ•°å¯ä»¥ä½¿ç”¨ unix-optsè¿™ä¸ªåº“ã€‚çœ‹ä»£ç å–½(çœ‹ä¸æ‡‚ä¹Ÿæ²¡å…³ç³»ï¼Œä½ å¯ä»¥ç”¨ä½ å–œæ¬¢çš„è¯­è¨€ç”šè‡³shellè„šæœ¬è‡ªå·±ç ”ç©¶ä¸‹ï¼Œå¾ˆå¥½å†™çš„) è¿™æ®µè„šæœ¬çš„è¡Œä¸ºæ˜¯ï¼Œ æ¥å—ä¸€ä¸ª-eå‚æ•° ç”¨æ¥æŒ‡å®šç¨‹åºçš„è·¯å¾„,ä»¥åŠä¸€ä¸ª-tå‚æ•°ç”¨æ¥æŒ‡å®šæ—¶é—´ #!/bin/sh #|-*- mode:lisp -*-|# #| exec ros -Q -- $0 \"$@\" |# (progn ;;init forms (ros:ensure-asdf) #+quicklisp(ql:quickload '() :silent t) ) (defpackage :ros.script.luna_time_tast.3869869288 (:use :cl)) (in-package :ros.script.luna_time_tast.3869869288) (ql:quickload \"unix-opts\") (ql:quickload \"uiop\") ;; å®šä¹‰å‘½ä»¤è¡Œå‚æ•° (opts:define-opts (:name :bin-path :description \"binary path to be executed\" :short #\\e :long \"bin_path\" :arg-parser #'uiop:native-namestring) (:name :time :description \"time to be used\" :short #\\t :long \"time\" :arg-parser #'string) ) (defun main (\u0026rest argv) (declare (ignorable argv)) ;; è§£æå‘½ä»¤è¡Œå‚æ•° (multiple-value-bind (options) (opts:get-opts argv) (let* ((binary-path (getf options :bin-path)) ;;æ‰¾åˆ°ç¨‹åºçš„çˆ¶ç›®å½• (dir (uiop:pathname-directory-pathname binary-path)) (time (getf options :time))) ;; è®¾ç½®libfaketimeç¯å¢ƒå˜é‡ (sb-posix:setenv \"DYLD_FORCE_FLAT_NAMESPACE\" \"1\" 1) (sb-posix:setenv \"DYLD_INSERT_LIBRARIES\" \"/opt/homebrew/lib/faketime/libfaketime.1.dylib\" 1) (sb-posix:setenv \"FAKETIME_DONT_RESET\" \"1\" 1) (sb-posix:setenv \"FAKETIME\" time 1) ;; åˆ‡æ¢åˆ°ç¨‹åºç›®å½• (uiop:chdir dir) ;;æ‰§è¡Œç¨‹åº (uiop:run-program (list \"./game\")) ) ) ) ","date":"2022-10-04","objectID":"/libfaketime/:3:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs æ—¶é—´æµ‹è¯•å°è¯•","uri":"/libfaketime/"},{"categories":["tools"],"content":"emacsé›†æˆ å…¶å®æˆ‘ä¼šç”¨common lispå½“ä½œè„šæœ¬è¯­è¨€æ˜¯å› ä¸ºæˆ‘æ¯”è¾ƒå–œæ¬¢ç”¨emacs, hack emacséœ€è¦ç”¨åˆ°lisp è¿™æ ·çš„è¯­è¨€ã€‚emacs éœ€è¦åšçš„æ˜¯å°è£…interactiveå‡½æ•°å»å¼‚æ­¥è°ƒç”¨ä¸Šè¿°çš„è„šæœ¬ã€‚ ;; ä¸€ä¸ªæ—¶é—´å˜é‡ï¼Œåé¢ä¼šå¸¦å…¥è„šæœ¬ (setq luna_time \"@2022-08-23 23:59:20\") ;; è„šæœ¬çš„è·¯å¾„ (setq luna_run \"/Users/qibinyang/Data/luna_time_test/luna_time_tast.ros\") (defun cycle-rank-test() \"test luna game\" (interactive) ;; å¼‚æ­¥è°ƒç”¨è„šæœ¬æ‰§è¡Œæˆ‘æƒ³è¦è°ƒæ—¶é—´çš„ç¨‹åº æˆ‘çš„å·¥ä½œæ˜¯æ¸¸æˆå¼€å‘ï¼Œæœ€è¿‘åœ¨åšè·¨æœä¸šåŠ¡æ‰€ä»¥ä¼šå¼€ä¸‰ä¸ª (start-process \"run_game\" (get-buffer \"*Messages*\") luna_run \"-e\" \"/opt/cycle_test/game/game\" \"-t\" luna_time) (start-process \"run_game\" (get-buffer \"*Messages*\") luna_run \"-e\" \"/opt/cycle_test/game2/game\" \"-t\" luna_time) (start-process \"run_game\" (get-buffer \"*Messages*\") luna_run \"-e\" \"/opt/cycle_test/game_center/game\" \"-t\" luna_time) ) è¿™æ ·æˆ‘å°±å¯ä»¥åœ¨emacs ä¸­ M-x cycle-rank-test å°†\"20200-08-23 23:59:20â€ è¿™ä¸ªæ—¶é—´å¸¦å…¥åˆ°ç¨‹åºä¸­ã€‚å¦‚æœæˆ‘æƒ³æ¢ä¸€ä¸ªæ—¶é—´ï¼Œåªéœ€è¦ä¿®æ”¹luna_timeè¿™ä¸ªå˜é‡ï¼Œç„¶åé‡å¯ç¨‹åºå³å¯ã€‚ ","date":"2022-10-04","objectID":"/libfaketime/:4:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs æ—¶é—´æµ‹è¯•å°è¯•","uri":"/libfaketime/"},{"categories":["tools"],"content":"æ€»ç»“ æ¯•ä¸šåˆ°å·¥ä½œæœ‰ä¸€å¹´çš„æ—¶é—´äº†ï¼Œç»å†äº†æŒºå¤šçš„äº‹æƒ…çš„ã€‚å°è±¡æœ€æ·±çš„æ˜¯å¤±æ‹ä»¥åï¼Œåˆæ…¢æ…¢çš„é‡æ•´æ——é¼“ï¼Œå¥èº«æ”¹é€ è‡ªå·±ï¼Œå’Œè‡ªå·±å¯¹è¯æ…¢æ…¢çš„èµ°å‡ºä»¥å‰çš„æ¼©æ¶¡ã€‚ä¿æŒç§¯æçš„å¿ƒæ€ï¼Œæ…¢æ…¢çš„æ¥å—æ–°çš„æ€æƒ³ï¼Œæ–°çš„ç†å¿µã€‚é”»ç‚¼èº«ä½“ï¼Œä¹Ÿé”»ç‚¼è‡ªå·±çš„å†…å¿ƒã€‚æ…¢æ…¢æ¥å—å˜åŒ–ï¼Œå‘ç€ä¸æƒ§æ€•å˜åŒ–å‰è¿›ã€‚è¿™äº›æ”¹å˜ç¡®å®ç»™æˆ‘å¸¦æ¥äº†æˆ‘æ²¡æœ‰æƒ³åˆ°çš„å¥½å¤„ã€‚ æœ€è¿‘æœ‰æ–­æ—¶é—´æ²¡å†™åšå®¢äº†ï¼Œæ‰€ä»¥ä»Šå¤©è¡¥ä¸Šä¸€ç¯‡å·¥ä½œæ—¥è®°ã€‚ä»é«˜ä¸­çš„æ—¶å€™å°±æ¥è§¦åˆ°linuxï¼Œåœ¨linuxå’Œç¼–è¾‘å™¨ä¸Šæµªè´¹äº†å¤§é‡çš„æ—¶é—´ã€‚ç°åœ¨é€æ¸ç¨³å®šä¸‹æ¥ï¼Œæœªæ¥çš„åŠå¹´åº”è¯¥æŠŠé‡ç‚¹æ”¾åœ¨ç®—æ³•å’Œåç«¯æ¶æ„çš„ç†è§£ä¸Šï¼Œå…¼é¡¾å¼€å‘ä¸€äº›å°å·¥å…·ï¼Œæå‡è‡ªå·±çš„æ•ˆç‡ã€‚æœ€è¿‘å¯¹è‡ªå·±çš„ç¼–ç é£æ ¼ä¹Ÿä¸æ˜¯å¾ˆæ»¡æ„ï¼Œå†™çš„ç¨‹åºæœ‰ç‚¹ä¹±è¿˜å¾—æ³¨æ„ä¸€ä¸‹ã€‚ æœ€æ€•æ‡’åœ¨åºŠä¸Šï¼Œå›°åœ¨æ‰‹æœºé‡Œï¼Œè¢«ä½çº§è¶£å‘³æ¶ˆç£¨æ„å¿—ã€‚ ","date":"2022-10-04","objectID":"/libfaketime/:5:0","tags":["tools","common-lisp","emacs","lisp"],"title":"libfaketime + roswell + emacs æ—¶é—´æµ‹è¯•å°è¯•","uri":"/libfaketime/"},{"categories":["game-dev","GoGameActor"],"content":"æœ‰å…³æ¸¸æˆä¸­çƒ­æ›´ä»£ç çš„ä¸€äº›æ€è€ƒ","date":"2022-10-04","objectID":"/hotfix/","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"ä¸Šå‘¨åœ¨æ€è€ƒæ¡†æ¶è¯¥ä¸è¯¥ä¸Šçƒ­æ›´ï¼Œä»¥åŠå¦‚ä½•é€‚é…çƒ­æ›´çš„æ—¶å€™ï¼ˆå…¶å®ä¸€è¡Œä»£ç éƒ½è¿˜æ²¡å†™å‘¢ğŸ˜•ï¼‰ï¼Œè¿«ä½¿æˆ‘ä¸æ–­å»æ€è€ƒå¦‚ä½•å»çƒ­æ›´æ‰èƒ½åšåˆ°æ­£ç¡®ã€‚ä½†æ˜¯ï¼Œçƒ­æ›´è¿™ä¸ªäº‹æƒ…å³ä½¿æ˜¯lua,ä¹Ÿéœ€è¦åŠ ä¸Šå¾ˆå¤šçš„é™åˆ¶ã€‚è€Œä¸”ï¼Œçƒ­æ›´è¿™ä»¶äº‹æƒ…ä¸ä½†å’Œè¯­è¨€å±‚é¢ç›¸å…³è”ï¼Œå’Œæ¡†æ¶çš„è®¾è®¡ä¹Ÿæœ‰å¾ˆå¯†åˆ‡çš„å…³ç³»ã€‚æœ€è¿‘åœ¨ç½‘ä¸Šçœ‹äº†å¾ˆå¤šåšå®¢ï¼Œæ‰€ä»¥è¿™é‡Œåšä¸ªæ€è€ƒè®°å½•ã€‚ ","date":"2022-10-04","objectID":"/hotfix/:0:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"ä»€ä¹ˆæ˜¯çƒ­æ›´ çƒ­æ›´å°±æ˜¯åœ¨ä¸ä¸­æ–­æœåŠ¡çš„æƒ…å†µä¸‹ï¼ˆæ³¨æ„æ˜¯ä¸ä¸­æ–­æœåŠ¡è€Œä¸æ˜¯ä¸é‡å¯è¿›ç¨‹æˆ–æœåŠ¡å™¨ï¼‰ï¼Œå¯¹ç¨‹åºçš„è¡Œä¸ºè¿›è¡Œä¿®æ”¹ã€‚ç®€å•æ¥è¯´ï¼Œå¦‚æœå·²ç»éƒ¨ç½²çš„ä»£ç æ‰§è¡Œçš„é€»è¾‘æ˜¯1+1=2, é‚£ä¹ˆçƒ­æ›´å°±å¯ä»¥æ”¹å˜1+1=2è¿™ä¸ªè¡Œä¸ºï¼Œæ¯”å¦‚è¯¥æ›´1+1=3ï¼Œå¹¶ä¸”å¯¹å¤–çš„æœåŠ¡æ˜¯ä¸èƒ½ä¸­æ–­çš„ï¼ˆå› ä¸ºç”¨æˆ·ä¼šæ— æ³•è®¿é—®ä¸šåŠ¡ï¼‰ã€‚åœ¨ç”¨æˆ·æ— æ„ŸçŸ¥çš„æƒ…å†µä¸‹ï¼Œæ”¹å˜åŸæœ‰çš„ä»£ç é€»è¾‘ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™ä¹ˆè¯´ã€‚ ","date":"2022-10-04","objectID":"/hotfix/:1:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"ä¸ºä»€ä¹ˆè¦æœ‰çƒ­æ›´ å¯¹äºäº’è”ç½‘è¡Œä¸šæ¥è¯´ï¼Œæœ‰æµé‡æ‰æœ‰å¯èƒ½å˜ç°ã€‚æµé‡æ„å‘³ç€æœ‰äººåœ¨ä½¿ç”¨äº§å“ï¼Œæœ‰äººä½¿ç”¨äº§å“æˆ‘ä»¬æ‰èƒ½ç€æ‰‹è¯±å¯¼ç”¨æˆ·è¿›è¡Œæ¶ˆè´¹ã€‚è¯•æƒ³ï¼Œä¸€ä¸ªé…’æ¥¼æ²¡æœ‰ä¸€ä¸ªé¡¾å®¢ï¼ˆæµé‡ï¼‰ï¼Œä»–çš„é…’ï¼ŒæœåŠ¡ï¼Œé¥­èœè¦å¦‚ä½•é”€å”®å˜ç°ï¼Ÿè€Œå¯¹äºäº’è”ç½‘äº§å“æ¥è¯´ï¼Œä¸€ç§’é’Ÿçš„æµé‡å°±å¯èƒ½é«˜è¾¾åƒä¸‡ï¼Œè€Œè¿™ä¸€ç§’çš„æµé‡è½¬åŒ–ï¼Œå³ä¾¿åªæœ‰1%ï¼Œä¹Ÿæ˜¯å¾ˆå¤šçš„ã€‚ è¯•æƒ³ä¸€ä¸‹ï¼Œç°åœ¨è¿™ä¸€ç§’æœ‰1åƒä¸‡çš„æµé‡ï¼Œè½¬åŒ–ç‡æ˜¯1%,é‚£å°±æ„å‘³ç€è¿™ä¸€ç§’ä¸­æœ‰100ä¸ªäººåœ¨ä¸‹å•ï¼Œå‡è®¾æ­¤æ—¶ä¸€å•çš„æµæ°´æ˜¯1å—ï¼Œé‚£è¿™ä¸€ç§’é’Ÿçš„æµæ°´å°±æ˜¯100å—ã€‚ æ³¨æ„è¿™é‡Œåªæ˜¯è¿™1ç§’é’Ÿï¼Œå¦‚æœæ—¶é—´æ‹‰é•¿åˆ°1å°æ—¶ï¼Œ12å°æ—¶ï¼Œ24å°æ—¶ã€‚ä¹ä¸éƒ½ä¼šçŸ¥é“è¦æ˜¯æ¯ç§’æœ‰äººç»™è‡ªå·±æ‰”100å—ï¼Œä¸€å¤©è‡ªå·±å°±å¯ä»¥ğŸ é æµ·äº†ã€‚ å¦‚æœè¿™æ—¶åœæœºç»´æŠ¤1å°æ—¶ï¼Œè¦æŸå¤±å¤šå°‘é’±ï¼Ÿè¿™å¤§æ¦‚å°±æ˜¯ä¸ºä»€ä¹ˆäº’è”ç½‘è¡Œä¸šéƒ½éå¸¸å¿Œè®³åœæœºç»´æŠ¤ï¼Œå› ä¸º\"æ—¶é—´\"çº¦ç­‰äº\"æµé‡\"çº¦ç­‰äº\"é’±\"ã€‚è€Œå¯¹äºæ¸¸æˆè¿™ç§çº¯é æµé‡æ¥èµšé’±çš„è¡Œä¸šæ›´æ˜¯å¦‚æ­¤äº†ï¼Œä¸åœæœºç»´æŠ¤å·²ç»æ˜¯æ¸¸æˆè¡Œä¸šçš„æ ‡é…äº†ã€‚ ","date":"2022-10-04","objectID":"/hotfix/:2:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"çƒ­æ›´çš„æ–¹æ¡ˆ æœåŠ¡å™¨æ— çŠ¶æ€ï¼Œå¿«é€Ÿé‡å¯ã€‚è¿™ç§æ–¹æ¡ˆçš„ç—›ç‚¹æ˜¯ï¼ŒæœåŠ¡å™¨çš„é‡å¯å¿…é¡»å°½å¯èƒ½çš„å¿«ã€‚æ…¢äº†ï¼Œå®¢æˆ·ç«¯å°±è¦è€ƒè™‘é‡ç™»å’Œé‡å‘åè®®ã€‚è€Œä¸”ç”±äºæ— çŠ¶æ€ï¼Œä¸šåŠ¡çš„ç¼–å†™æ›´å€¾å‘äºwebé‚£ä¸€å¥—ã€‚ æœåŠ¡å™¨ä¸å¥½ç»´æŠ¤ç”¨æˆ·çŠ¶æ€ï¼Œä¸šåŠ¡çš„æ€§èƒ½å’Œç¼–ç çš„éš¾æ˜“ç¨‹åº¦ä¸€å¾—çœ‹é¡¹ç›®æ˜¯å¦‚ä½•æ¶æ„çš„ï¼ŒäºŒå¾—çœ‹æœ‰æ²¡æœ‰æœ‰æ„è¯†çš„è¿­ä»£ä»£ç ã€‚å¦‚æœä¸¤è€…éƒ½åšä¸åˆ°ï¼Œæ€§èƒ½å°±ç”±æ•°æ®åº“å†³å®šï¼ˆä¸åšcacheçš„è¯ï¼‰ï¼Œç¼–ç å°±æœ‰å¯èƒ½è¦ä¸æ–­å¤„ç†æ“ä½œæ•°æ®åº“æ‰€æœ‰å¯èƒ½å¸¦æ¥çš„å¼‚å¸¸ã€‚å› ä¸ºæ— çŠ¶æ€æ˜¯ä¸å¯èƒ½å°†ä¸šåŠ¡çš„çŠ¶æ€å­˜å‚¨åœ¨å†…å­˜çš„ï¼Œå¤šæ•°æ˜¯ç›´æ¥å…¥åº“æˆ–è€…å…¥cacheã€‚ å¯¹äºgoæ¥è¯´ï¼Œä½ å¾—æ—¶åˆ»æ³¨æ„æ“ä½œæ•°æ®åº“æ—¶æŠ›å‡ºæ¥çš„error,å¦‚æœä¸èƒ½ä»æ¡†æ¶ä¸Šå…ˆè¡Œå¯¹è¿™ç§errorè¿›è¡Œè¿‡æ»¤ï¼Œä¼šå› ä¸ºé¢‘ç¹çš„å†™é‡å¤ä»£ç è€Œæ§åˆ¶ä¸ä½çš„è§‰å¾—çƒ¦ã€‚æ¯”å¦‚ï¼Œå¾ˆå¤šrpcçš„æ¥å£éƒ½éœ€è¦ç”¨åˆ°usrè¿™å¼ è¡¨çš„ä¿¡æ¯ï¼Œå¦‚æœä¸èƒ½åœ¨rpcæ¥çš„æ—¶å€™ï¼Œè‡ªåŠ¨å»è·å–usrï¼Œé‚£å°±éœ€è¦ç¨‹åºå‘˜è‡ªå·±å»ç¼–å†™ã€‚ç¨‹åºå‘˜çš„æ—¶é—´å°±æµªè´¹åœ¨äº†è¿™ç§äº‹æƒ…ä¸Šé¢ï¼Œæœªå…æœ‰äº›äºã€‚ä½†æ˜¯ï¼Œåˆä¸æ˜¯æ¯ä¸ªrpcéƒ½è¦ç”¨åˆ°usrè¡¨çš„ä¿¡æ¯ï¼Œå¦‚æœæ¯ä¸ªéƒ½å»æŸ¥ä¸€éusrè¡¨ï¼Œåˆä¼šæµªè´¹æ•°æ®åº“é‚£æœ‰é™çš„ååã€‚æ‰€ä»¥åšæ— çŠ¶æ€ï¼Œæ¶æ„ä»£ç çš„äººå¿…é¡»è¶³å¤Ÿç‰›ğŸºï¼Œé¡¹ç›®æˆå‘˜è¦æ—¶åˆ»æœ‰è¿­ä»£ä»£ç çš„æ„è¯†ã€‚æœ‰çš„æ—¶å€™é¡¹ç›®è€å¤§è¿˜è¦åœ¨ç¼–ç å’Œæ€§èƒ½ä¹‹é—´åšæƒè¡¡ã€‚ æœåŠ¡å™¨æ— çŠ¶æ€ï¼Œå°†æ–°çš„æµé‡å¯¼å…¥æ–°çš„è¿›ç¨‹æˆ–è€…æ–°çš„æœåŠ¡å™¨ã€‚è¿™ç§æ–¹æ¡ˆå¾—åœ¨routerå±‚åšå¥½æµé‡çš„è½¬å‘ï¼Œè€Œä¸”å¦‚æœæœ‰äº›é€»è¾‘æ˜¯æœ‰çŠ¶æ€çš„è¯ï¼Œè¿˜å¾—åšå¥½çŠ¶æ€çš„ç§»äº¤ï¼ˆè™½æ˜¯æ— çŠ¶æ€æœåŠ¡å™¨ï¼Œä½†æ˜¯æœ‰çš„é€»è¾‘æœ‰çŠ¶æ€æ˜¯éš¾å…çš„ï¼‰ã€‚ æœåŠ¡å™¨æ— çŠ¶æ€ï¼Œç›´æ¥å°†ä»£ç æ‰“è¿›æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ä¸­ï¼Œè¿™ç§å°±æ¯”è¾ƒéš¾äº†ã€‚éœ€è¦å·¥ç¨‹å¸ˆè¶³å¤Ÿäº†è§£è¯­è¨€ç‰¹æ€§,å’Œæ¡†æ¶ï¼ŒçŸ¥é“å¦‚ä½•å»æ›¿æ¢è¿è¡Œæ—¶çš„å‡½æ•°ã€‚ æœåŠ¡å™¨æœ‰çŠ¶æ€ï¼Œç›´æ¥å°†ä»£ç æ‰“è¿›æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ï¼Œè¿™ä¸ªéš¾åº¦æ¯”ä¸‰è¦å¤§ã€‚è€Œä¸”ç”±äºæœ‰çŠ¶æ€ï¼Œä¸ä½†å¾—åšåˆ°3æåˆ°çš„å…¨éƒ¨ï¼Œè€Œä¸”å¾—åšåˆ°è¿è¡Œæ—¶çŠ¶æ€çš„è½¬åŒ–ï¼Œçƒ­æ›´ä»£ç çš„ç¼–å†™ä¼šå¼‚å¸¸çš„å¤æ‚ã€‚ä¸€èˆ¬æ¥è¯´è¿™ç§æ–¹æ¡ˆéƒ½ä¼šåœ¨æ¶æ„ä¸ŠåŠ ä¸Šå„ç§é™åˆ¶æ¥ä¿è¯çƒ­æ›´çš„æ­£ç¡®æ€§ï¼Œæ‰€ä»¥ç¼ºç‚¹å°±æ˜¯æœ‰å„ç§é™åˆ¶ã€‚æ¯”å¦‚é€»è¾‘å’Œæ•°æ®å¿…é¡»ä¸¥æ ¼åˆ†ç¦»ï¼Œæœ€å¥½åªçƒ­æ›´çº¯å‡½æ•°, å¯¹äºå¼±ç±»å‹è¯­è¨€ä¼šå¥½åšä¸€äº›æ¯”å¦‚(lua,js)è¿™ç§ï¼Œå…è®¸æ•°æ®ç»“æ„ä¿®æ”¹çš„åŒæ—¶å»æ›´æ”¹é€»è¾‘å‡½æ•°åšåˆ°çƒ­æ›´æ­£ç¡®ï¼Œä½†æ˜¯å¯¹äºå¼ºç±»å‹è¯­è¨€(go,c++)å½“éœ€è¦ä¿®æ”¹æ•°æ®ç±»å‹çš„æ—¶å€™å¯èƒ½ä¸å¾—ä¸é‡å¯æœåŠ¡å™¨ï¼Œè€Œä¸”å¯èƒ½ä¼šå¸¦æ¥åŠ¨æ€é“¾æ¥æ¨¡å—ç‰ˆæœ¬æ§åˆ¶ç­‰ä¸€ç³»åˆ—é—®é¢˜(æˆ‘çš„æ¡†æ¶å¯èƒ½ä¼šé€‰æ‹©è¿™ç§æ–¹å¼)ã€‚ åªçƒ­æ›´ç­–åˆ’è¡¨ï¼Œè¿™ç§å°±æ¯”è¾ƒå®¹æ˜“äº†ï¼Œåšå¥½æ‰€æœ‰ä¸šåŠ¡é€»è¾‘ä»ç»Ÿä¸€çš„åœ°æ–¹æ‹¿é…ç½®å°±è¡Œã€‚å¯¹äºé™æ€è¯­è¨€æ¥è¯´ï¼Œé…è¡¨ç»“æ„æ›´æ”¹è¿˜æ˜¯å…ä¸äº†éœ€è¦é‡å¯æœåŠ¡å™¨ã€‚ç¼–ç çš„æ—¶å€™é¢„ç•™æ§åˆ¶å°æ¥å£ï¼Œéœ€è¦æ›´æ–°æ—¶ç”±æ§åˆ¶å°å‘é€reloadé…ç½®çš„å‘½ä»¤ï¼Œç¨‹åºå…ˆé”ä½é…è¡¨æœåŠ¡ç„¶åç›´æ¥reloadæ‰€æœ‰çš„é…è¡¨å†è§£é”å°±å¯ä»¥äº†ã€‚ ","date":"2022-10-04","objectID":"/hotfix/:3:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["game-dev","GoGameActor"],"content":"æ€»ç»“ é™æ€è¯­è¨€è™½ç„¶æ€§èƒ½ä¸Šè¦å¥½è¿‡åŠ¨æ€è¯­è¨€ï¼Œä½†æ˜¯çµæ´»æ€§ä¸Šå¤§å¤§å¼±äºåŠ¨æ€è¯­è¨€ã€‚æ— çŠ¶æ€è™½ç„¶èƒ½åšåˆ°æ— æ„ŸçŸ¥ï¼Œä½†æ˜¯åƒé‡å¯é€Ÿåº¦ï¼Œè¿˜å¾—å®¢æˆ·ç«¯é…åˆï¼Œæƒ³è¦æ€§èƒ½å’Œæ„‰å¿«çš„ç¼–ç ï¼Œä½ å¾—æ‰¾å¥½ç‚¹çš„æ­æ¡£ï¼Œæ¶æ„å¾—å¥½å¥½è®¾è®¡åˆ«å·æ‡’ã€‚ çƒ­æ›´ä¼šå¸¦æ¥å¾ˆå¤šçš„é™åˆ¶ï¼Œå¼•å…¥æ–°çš„ç‰¹æ€§ï¼Œæ–°çš„æŠ€æœ¯éƒ½ä¼šå¸¦æ¥æ–°çš„å‰¯ä½œç”¨å’Œé—®é¢˜ã€‚å¼•å…¥ä¹‹å‰å¿…é¡»åšå¥½æƒè¡¡ï¼Œæƒ³å¥½äº†å†åšã€‚æ¡†æ¶ç¼–å†™éå¸¸åƒæ¶æ„å¸ˆçš„èƒ½åŠ›ï¼Œä½ å¾—ç»™ä»–è¶³å¤Ÿçš„æ—¶é—´å»æ€è€ƒæ¶æ„ä¸Šçš„é—®é¢˜ã€‚ æˆ‘å°±é‡åˆ°æ— çŠ¶æ€æœåŠ¡å™¨é¢‘ç¹æ“ä½œæ•°æ®åº“ï¼ˆå› ä¸ºå½“æ—¶åç«¯ç¯å¢ƒéå¸¸æ¶åŠ£ï¼Œåªæœ‰ä»–ä¸€ä¸ªäººï¼Œä»–æ¥çš„æ—¶å€™æ²¡æœ‰æ¡†æ¶ï¼Œè¿˜å¾—å°½å¿«å¯¹æ¥ä¸šåŠ¡,åç«¯1v8éå¸¸æƒ¨çƒˆï¼Œè€Œä¸”è¯´å¥½ä¸€ä¸ªæœåªæœ‰4000çš„å¯¼é‡ï¼Œæ‰€ä»¥æ²¡æœ‰ä¸Šcacheï¼‰ï¼Œè€å¤§æ‹…å¿ƒæ€§èƒ½ä¸Šä¼šé‡åˆ°ç“¶é¢ˆ, æ‰€ä»¥è®©æˆ‘å»åšä¸€äº›çƒ­è¡¨ï¼ˆæ•°æ®åº“ä¸­éœ€è¦é¢‘ç¹è®¿é—®çš„è¡¨ï¼‰çš„cacheã€‚ä½†æ˜¯æˆ‘åšå®Œäº†çƒ­è¡¨çš„cacheåï¼Œå‘ç°çƒ­è¡¨çš„cacheä¼šå½±å“ä¸€äº›è·¨æœçš„ä¸šåŠ¡ã€‚è¿™ä¸ªæ—¶å€™ä¿®æ”¹è·¨æœçš„ä»£ç ä»£ä»·ä¼šæ¯”è¾ƒå¤§ï¼Œè€Œä¸”ä¹Ÿæ²¡åˆ°éä¸Šä¸å¯çš„æ—¶å€™ï¼ˆå¯¼é‡è¿˜æ˜¯ä¸ä¼šçªç ´4000çš„ï¼‰æ‰€ä»¥è¿™ä¸ªäº‹æƒ…åªèƒ½æš‚æ—¶æç½®, æˆ‘è¿˜å¾—å»å†™åˆ«çš„ä¸šåŠ¡ã€‚ä½†æ˜¯å°±æ€•æœ‰ä¸€å¤©æ€§èƒ½ä¼šé‡åˆ°ç“¶é¢ˆï¼Œé‡åˆ°äº†æˆ‘é‚£å†™äº†æŒºå¤šè·¨æœä¸šåŠ¡çš„åŒäº‹å°±å¾—å¿™ä¸€ä¼šäº†ï¼Œæˆ‘æœ€è¿‘ä¹Ÿå†™äº†ä¸€äº›ï¼Œæˆ‘ä¹Ÿå¾—å¿™ä¸€ä¸‹äº†ğŸ˜‚ã€‚ ","date":"2022-10-04","objectID":"/hotfix/:4:0","tags":["hotfix"],"title":"GoGameActor-102 hotfix introduction","uri":"/hotfix/"},{"categories":["gamedev"],"content":"actor ä»‹ç»å’Œæ„Ÿæ‚Ÿ","date":"2022-10-04","objectID":"/introduction/","tags":["actor","gamedev"],"title":"actor æ¨¡å‹ä»‹ç»å’Œæ„Ÿæ‚Ÿ","uri":"/introduction/"},{"categories":["gamedev"],"content":"ä¸ºä»€ä¹ˆæœ‰è¿™ç¯‡åšå®¢ ä¸€åˆ‡æºè‡ªäºæˆ‘å»å¹´çš„æ¯•ä¸šè®¾è®¡ï¼Œæˆ‘æ¯•ä¸šè®¾è®¡çš„è¯¾é¢˜æ˜¯ã€ŠåŸºäºunityæ‰“é€ çš„ç¬¬ä¸‰äººç§°è®¾è®¡æ¸¸æˆã€‹ã€‚åˆšä¸€çœ‹åˆ°è¿™ä¸ªé¢˜ç›®çš„æ—¶å€™ä½ ä¸€å®šæƒ³åˆ°ï¼Œè¿™å’Œactor å’Œ ç½‘ç»œæœ‰ä»€ä¹ˆå…³ç³»å—ï¼Ÿç¡®å®ï¼ŒæŒ‰ç…§æ¯•è®¾çš„è¦æ±‚ï¼Œæ˜¯ä¸éœ€è¦è¿™ä¸ªæ¸¸æˆæœ‰ç½‘ç»œæ¨¡å—çš„è®¾è®¡çš„ã€‚ä½†æ˜¯å˜›ï¼Œå› ä¸ºæˆ‘å¿«æ¯•ä¸šé‚£ä¼šéå¸¸æƒ³æ‰¾ä¸€å®¶æ¸¸æˆå…¬å¸çš„åç«¯è¿›è¡Œå®ä¹ ï¼Œæœªæ¥çš„èŒä¸šè§„åˆ’ä¹Ÿæ˜¯å¾€æ¸¸æˆåç«¯çš„æ–¹å‘å‘å±•çš„ã€‚æ‰€ä»¥æˆ‘è‡ªå‘Šå¥‹å‹‡çš„è·Ÿå¯¼å¸ˆè¯´è¿™ä¸ªæ¸¸æˆæˆ‘è¦åŠ ä¸Šç½‘ç»œæ¨¡å—ï¼ˆå…¶å®ä¹‹å‰æœ‰è¿‡ç±»ä¼¼çš„æ¸¸æˆåè®®åºåˆ—åŒ–å’Œç½‘ç»œåŒæ­¥çš„ç»éªŒï¼‰ã€‚ é€‰å®šè¯¾é¢˜æ²¡å¤šä¹…ï¼Œæˆ‘å°±åœ¨å¹¿å·æ‰¾åˆ°äº†æˆ‘çš„ç¬¬ä¸€å®¶å®ä¹ å…¬å¸ï¼Œæ˜¯ä¸€å®¶åšå¤§å‹mmoçš„æ¸¸æˆå…¬å¸ï¼ˆåˆšå»ä»–å®¶çš„æ—¶å€™è¿˜å¾®å¾®é„™è§†ä»–å®¶çš„æ¡†æ¶ï¼Œç°åœ¨çœ‹æ¥ç®€ç›´æ˜¯æˆ‘æ— æ³•ä¼åŠçš„ç¥ï¼‰ã€‚ ä¸œå®¶ç”¨çš„libevent å†™çš„ç½‘ç»œåº“ï¼ˆå…¶å®ä»è¿™å°±å¯ä»¥çœ‹å‡ºæ˜¯ä¸€å®¶æˆç«‹å¾ˆæ—©çš„å…¬å¸äº†ï¼‰,ç„¶åæš´éœ²ç»™luaè°ƒç”¨ï¼Œé€»è¾‘å…¨æ˜¯ç”¨luaå†™çš„ï¼Œç”±äºluaä¸æ”¯æŒçœŸæ­£çš„å¤šçº¿ç¨‹æ‰€ä»¥ä¸œå®¶ç”¨çš„å¤šè¿›ç¨‹ï¼Œåˆ©ç”¨rpcè§£å†³è¿›ç¨‹åŒæ­¥çš„é—®é¢˜ï¼ˆå½“æ—¶åˆå‡ºèŒ…åºï¼Œè¿™ä¸ªåœ°æ–¹ç‹ ç‹ çš„å‘äº†æˆ‘ä¸€æŠŠï¼Œä¹Ÿå¯¼è‡´æˆ‘ç»™ä¸œå®¶ç•™ä¸‹äº†ç¬¬ä¸€ä¸ªä¸å¥½çš„å°è±¡ï¼‰ã€‚æ‰€ä»¥æˆ‘å¾ˆè‡ªç„¶çš„å­¦åˆ°äº†protobuf å’Œ luaè¿™æ ·çš„æŠ€æœ¯ã€‚ æœ‰äº†è¿™ä¸¤ä¸ªæŠ€æœ¯ä¹‹åï¼Œæˆ‘ä¾¿å¼€å§‹ç€æ‰‹è‡ªå·±æ¯•è®¾çš„åç«¯æ¡†æ¶äº†ã€‚å»ç½‘ä¸Šæ‰¾äº†ä¸€é€šèµ„æ–™ï¼Œå‘ç°skynetï¼ˆä¸€æ¬¾åŸºäºactoræ¨¡å‹å¼€å‘çš„æ¡†æ¶ï¼‰è¿™ä¸ªæ¡†æ¶,æˆ‘ç«‹åˆ»è¢«skynetçš„actoræ¨¡å‹ç»™å¸å¼•äº†ï¼Œå¹¶ä¸”ç«‹å¿—æˆ‘ä¹Ÿè¦åŸºäºactoræ¨¡å‹å†™å‡ºä¸€ä¸ªè‡ªå·±çš„æ¡†æ¶ã€‚ å››ä¸ªæœˆåï¼Œç”±äºæˆ‘æ€»æ˜¯åœ¨å¿™è‡ªå·±çš„æ¯•è®¾ï¼Œç»™ä¸œå®¶ç•™ä¸‹äº†ç¬¬äºŒä¸ªä¸å¥½çš„å°è±¡ï¼Œæˆ‘è¢«å¼€äº†ã€‚è¢«å¼€çš„æ—¶å€™ï¼Œæˆ‘çš„è€å¤§æŠŠæˆ‘æ‹‰åˆ°åŠå…¬å®¤è·Ÿæˆ‘è¯´äº†å¾ˆå¤šè®©æˆ‘å—ç”¨çš„è¯ã€‚åœ¨åå¤çš„æ€è€ƒä»–è¯´çš„è¯ä¹‹åï¼Œæˆ‘å¼€å§‹å­¦ä¹ goè¯­è¨€ã€‚å¹¶ä¸”åœ¨ç¦»èŒçš„é‚£æ®µæ—¶é—´é‡Œï¼Œæˆ‘å†™äº†è‡ªå·±çš„golang åç¨‹æ± ,å†™çš„æ—¶å€™çŸ¥é“golangå·²ç»æœ‰ä¸€ä¸ªéå¸¸å‰å®³çš„åç¨‹æ± å«ants,æ‰€ä»¥å†™å®Œä¹‹åå’Œants battleäº†ä¸€ä¸‹,ä½†æ˜¯å‘ç°æˆ‘åªåœ¨ç™¾ä¸‡ä»¥ä¸Šçº§åˆ«çš„æ€§èƒ½ä¸Šèƒ½å¤Ÿé¢†å…ˆants, ä½†æ˜¯å†…å­˜å ç”¨å´å®Œå®Œå…¨å…¨çš„è¾“ç»™äº†antsï¼Œè€Œä¸”antsè¿˜æœ‰åŠ¨æ€ä¼¸ç¼©ç­‰ç­‰ä¸€äº›æˆ‘æ²¡æœ‰çš„ç‰¹æ€§ã€‚æˆ‘è¿˜æ˜¯èœäº†ç‚¹ğŸ˜‚ã€‚ä½†æ˜¯è¿™ä¸ªç»å†å´è®©æˆ‘å°åˆ°äº†ç»å°½è„‘æ±è§£å†³é—®é¢˜çš„ç”œå¤´, ä¹Ÿè®©æˆ‘åœ¨å®è·µä¸­å­¦åˆ°äº†å¾ˆå¤šçš„ä¸œè¥¿ã€‚ ä¸ªäººè®¤ä¸ºå®è·µå’Œçœ‹ä¹¦å¿…é¡»ç›¸äº’ç»“åˆï¼Œå…ˆçœ‹ä¹¦ï¼Œå†å®è·µï¼Œå®è·µå®Œäº†å†çœ‹ä¹¦åˆä¼šæ”¶è·æ–°çš„ä¸œè¥¿ï¼Œåªæœ‰å®è·µåçš„åªæ˜¯æ‰èƒ½çœŸæ­£çš„å†…åŒ–ã€‚ ä»‹ç»è‡ªå·±å†™åç¨‹æ± çš„ç»å†æ˜¯å› ä¸ºï¼Œåœ¨å†™åç¨‹æ± çš„æ—¶å€™ï¼Œæˆ‘äº†è§£åˆ°äº†golangçš„åç¨‹è°ƒåº¦å™¨GMPã€‚è¿™ä¸ªè°ƒåº¦å™¨å’Œskynetå†…éƒ¨çš„çº¿ç¨‹æ± éå¸¸çš„ç±»ä¼¼ï¼Œæˆ‘å¯ä»¥åŸºäºè¿™ä¸ªGMPå»å†™æˆ‘çš„åç«¯æ¡†æ¶ã€‚ ","date":"2022-10-04","objectID":"/introduction/:1:0","tags":["actor","gamedev"],"title":"actor æ¨¡å‹ä»‹ç»å’Œæ„Ÿæ‚Ÿ","uri":"/introduction/"},{"categories":["gamedev"],"content":"Actoræ¨¡å‹ Actoræ¨¡å‹(Actor model)é¦–å…ˆæ˜¯ç”±Carl Hewittåœ¨1973å®šä¹‰ï¼Œ ç”±Erlang OTP æ¨å¹¿ï¼Œå…¶ æ¶ˆæ¯ä¼ é€’æ›´åŠ ç¬¦åˆé¢å‘å¯¹è±¡çš„åŸå§‹æ„å›¾ã€‚Actorå±äºå¹¶å‘ç»„ä»¶æ¨¡å‹ï¼Œé€šè¿‡ç»„ä»¶æ–¹å¼å®šä¹‰å¹¶å‘ç¼–ç¨‹èŒƒå¼çš„é«˜çº§é˜¶æ®µï¼Œé¿å…ä½¿ç”¨è€…ç›´æ¥æ¥è§¦å¤šçº¿ç¨‹å¹¶å‘æˆ–çº¿ç¨‹æ± ç­‰åŸºç¡€æ¦‚å¿µã€‚ Actoræ¨¡å‹=æ•°æ®+è¡Œä¸º+æ¶ˆæ¯ã€‚ actoræ¨¡å‹æ˜¯ä¸€ç§å¤©ç„¶çš„åˆ†å¸ƒå¼æ¨¡å‹ï¼Œactorå¯ä»¥åˆ†å¸ƒåœ¨ä¸åŒçš„åœ°æ–¹ï¼Œå¯ä»¥æ˜¯æœ¬åœ°ï¼Œä¹Ÿå¯ä»¥åˆ†å¸ƒåœ¨ä¸åŒçš„ç½‘ç»œä¸»æœºä¸Šã€‚ å¼ºéš”ç¦»æ€§,actorä¹‹é—´åªèƒ½é€šè¿‡æ¯ä¸ªactorçš„mailboxæ¥åä½œï¼Œä¸€ä¸ªactorä¸å¯ä»¥ç›´æ¥æ“çºµå¦ä¸€ä¸ªactor,åªèƒ½é€šè¿‡å†™ä¿¡çš„æ–¹å¼é€šçŸ¥å¦ä¸€ä¸ªactorè‡ªå·±è¦åšä»€ä¹ˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œactorä¸actoré»˜è®¤ä¸”å¼ºåˆ¶è¦æ±‚ä½¿ç”¨ç±»ä¼¼ç‰©ç†éš”ç¦»çš„ä¸»æœºé‚£æ ·ä½¿ç”¨rpcçš„æ–¹å¼åä½œã€‚ ä½ç½®é€æ˜ï¼ŒæŠ¹å¹³æœ¬åœ°ä¸éæœ¬åœ°çš„å·®å¼‚ï¼Œactoræ¨¡å‹ä¸­æ— éœ€å…³æ³¨ä¸€ä¸ªactoréƒ¨ç½²åœ¨äº†å“ªä¸ªåœ°æ–¹ã€‚ å¼‚æ­¥ï¼Œç”±äºé€šè¿‡mailboxæ¥å®ç°åä½œï¼Œæ‰€ä»¥å‘é€è€…åœ¨å°†æ¶ˆæ¯æ¨é€åˆ°æ¥æ”¶è€…çš„mailboxåï¼Œè‹¥æ— éœ€ç­‰å¾…ç»“æœï¼Œå°±å¯ä»¥ç›´æ¥å»åšåˆ«çš„äº‹æƒ…ã€‚å‰©ä¸‹çš„å°±å¯ä»¥äº¤ç»™æ¥æ”¶è€…è®©å®ƒè‡ªå·±å»æ¶ˆè´¹è¿™æ¡æ¶ˆæ¯äº†ã€‚ æ— é”ï¼ŒåŒæ ·ç”±äºåŸºäºmailboxå®ç°åä½œï¼Œæ¶ˆæ¯æ˜¯å…·æœ‰é¡ºåºçš„ï¼Œæˆ‘ä»¬æ— éœ€å…³æ³¨èµ„æºç«äº‰å¸¦æ¥çš„æ•°æ®ä¸€è‡´æ€§é—®é¢˜(ä½ ä¸èƒ½ç›´æ¥æ“ä½œactorï¼Œåªèƒ½å‘Šè¯‰å®ƒä½ è¦åšä»€ä¹ˆ) å¤©ç”Ÿæ”¯æŒè´Ÿè½½å‡è¡¡ï¼Œè€Œä¸”å¯¹æ°´å¹³æ‰©å®¹çš„æ”¯æŒéå¸¸å¥½(actor å¼ºè¿«ä½ å¯¹æœåŠ¡è¿›è¡Œåˆ’åˆ†ï¼Œåšæˆå¾®æœåŠ¡é‚£æ ·) note è¿™é‡Œæä¸€å˜´åœ¨æˆ‘é¢è¯•ç°ä¸œå®¶çš„æ—¶å€™ï¼Œè€å¤§å’Œæˆ‘æ¢è®¨actoræ¨¡å‹æ—¶ï¼Œç»™æˆ‘å‡ºçš„ä¸€ä¸ªé¢˜ç›®ã€‚å½“æ—¶å›ç­”çš„ä¸æ˜¯éå¸¸å¥½ï¼Œæ‰€ä»¥è¿™æ¬¡å†™åšå®¢æ€»ç»“ä¸€ä¸‹ã€‚ å½“æ—¶è€å¤§åœ¨å¬å®Œæˆ‘ä»‹ç»actoræ¨¡å‹åï¼Œå°±é—®æˆ‘ï¼Œç”±äºactorå’Œactorä¹‹é—´æ˜¯é€šè¿‡mailboxè¿›è¡Œåä½œçš„ï¼Œæ¯ä¸ªactorçš„çŠ¶æ€éƒ½æ˜¯è‡ªç»´æŠ¤çš„ã€‚ç°åœ¨æ¯ä¸ªç©å®¶ç™»é™†ï¼Œæˆ‘ä»¬å°±ä¼šå®ä¾‹åŒ–ä¸€ä¸ªactorå‡ºæ¥ï¼Œå¦‚æœæˆ‘ç°åœ¨æƒ³å¹¿æ’­ä¸€æ¡åè®®ç»™å…¨æœåœ¨çº¿çš„ç©å®¶ï¼Œæˆ‘å°±éœ€è¦ç»™æ¯ä¸ªç©å®¶çš„actorçš„mailboxæ¨é€ä¸€æ¡æŒ‡ä»¤ï¼Œè¿™ä¸ªæ˜¯éå¸¸æ¶ˆè€—èµ„æºçš„ã€‚è¿™ç§æƒ…å†µï¼Œä½ è¦æ€ä¹ˆè§£å†³? è¿™ä¸ªé—®é¢˜å…¶å®é—®çš„ä¸»è¦æ˜¯ï¼Œå½“æˆ‘è¦è®©å¤§é‡çš„actorè¿›è¡Œç›¸åŒçš„æ“ä½œçš„æ—¶å€™ï¼Œå°±ä¼šé‡åˆ°éœ€è¦å‘æ¯ä¸€ä¸ªactorçš„mailboxæ’å…¥æ¶ˆæ¯çš„æƒ…å†µã€‚å‡è®¾ç°æœ‰3wçš„ç©å®¶åœ¨çº¿(è¿™ä¸ªå·²ç»å¾ˆå¤šäº†)ï¼Œå¦‚æœæ¶ˆæ¯çš„å¤§å°éå¸¸å°çš„æ—¶å€™ï¼ˆæ¯”å¦‚åªæœ‰byteçº§ï¼‰ï¼Œå¦‚æœä¸€æ¡æ¶ˆæ¯100byte,é‚£å¹¿æ’­ä¸€æ¬¡çš„æˆæœ¬æ˜¯2929KB ä¹Ÿå°±æ˜¯å·®ä¸å¤š3Mçš„æ ·å­ã€‚ä½†æ˜¯å¦‚æœå¹¿æ’­çš„æ¶ˆæ¯æ¯”è¾ƒå¤§ è¾¾åˆ°äº†Kçº§åˆ«å¦‚æœä¸€æ¡æ¶ˆæ¯çš„1kï¼Œé‚£å¹¿æ’­ä¸€æ¬¡çš„æˆæœ¬æ˜¯ 30M, ä½†æ˜¯100kçš„è¯ï¼Œæˆæœ¬å°±æ˜¯3Gã€‚ ä½†æ˜¯å®é™…çš„æƒ…å†µæ˜¯ï¼Œä¸€æ¡åè®®èƒ½è¿‡çªç ´1k,å·²ç»å¾ˆä¸å®¹æ˜“äº†ã€‚ å‡è®¾ä¸€æ¡åè®®æœ‰10ä¸ªå­—æ®µï¼Œæ¯ä¸ªå­—æ®µå 8Byte(64ä½),ä¹Ÿæ‰80byte,100ä¸ªå­—æ®µä¹Ÿæ‰çªç ´1kã€‚è™½ç„¶æ¶ˆè€—ä¸Šæ¥è¯´ï¼Œä¼šæ¯”ä¸ç”¨actorçš„è¦å¤§ï¼Œä½†æ˜¯å¹¶éæ— æ³•æ¥å—çš„ç¨‹åº¦ã€‚ å‡è®¾çœŸçš„é‡åˆ°äº†é‚£ç§éœ€è¦å¹¿æ’­ä¸€æ¡éå¸¸å¤§çš„åè®®ï¼ˆå‡è®¾ä¸€æ¡åè®®ä»–çªç ´äº†100k?ï¼‰ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä»æ¡†æ¶çš„å±‚é¢å»è§£å†³è¿™ä¸ªé—®é¢˜ã€‚è¿™é‡Œç»™å‡ºå‡ ä¸ªè§£å†³çš„æ€è·¯ã€‚ å‡è®¾æˆ‘ä»¬ç°åœ¨é‡åˆ°äº†ç¾¤å‘åè®®çš„æƒ…å†µï¼Œå…¶å®æ­£å¸¸çš„æ¡†æ¶è®¾è®¡æ˜¯ä¸å¯èƒ½è®©ç©å®¶çš„agent actor(ä¸€ä¸ªç©å®¶ä¼šæœ‰ä¸€ä¸ªå«åšagentçš„actor)å»æ”¶å‘åè®®çš„ï¼Œè€Œæ˜¯åœ¨å®¢æˆ·ç«¯å’Œ agent actorä¹‹é—´ç”¨ä¸€ä¸ªå«åšrouterçš„actorè¿›è¡Œä¸€ä¸ªä¸­è½¬ï¼Œè¿™ä¸ªrouterè´Ÿè´£ç¼–ç /è§£ç åè®®ï¼Œå¹¶æ¨é€ç»™æŒ‡å®šçš„agent actoræˆ–è€…å®¢æˆ·ç«¯, å®ƒç®¡ç†äº†ç©å®¶çš„socketã€‚ æ‰€ä»¥å¦‚æœæ˜¯å¹¿æ’­åè®®ï¼Œå…¶å®ä¸ç”¨é€šè¿‡agent actor. ç›´æ¥é€šè¿‡router, è®©routeræ‹¿åˆ°æ¯ä¸€ä¸ªåœ¨çº¿ç©å®¶çš„å¥—æ¥å­—å»ç¾¤å‘å°±å¥½äº†ã€‚æ‰€ä»¥é‡åˆ°è¿™ç§éœ€è¦å‘é€ç»™ä¸€ç±»actorçš„æƒ…å†µï¼Œä¼˜å…ˆè€ƒè™‘æ˜¯å¦èƒ½é€šè¿‡è¿™äº›actor çš„ manageræ¥è§£å†³ï¼Œä¸å¾—å·²çš„æƒ…å†µä¸‹æ‰éœ€è¦ç»™æ¯ä¸ªactor åˆ†å‘messageã€‚ è¿˜å¯ä»¥æŠŠåè®®åšæˆæŒ‡é’ˆï¼ŒæŒ‡é’ˆçš„æŒ‡é’ˆçš„ä¼ é€æˆæœ¬æ˜¯éå¸¸å°çš„ï¼Œä¸€æ‹›é²œåƒéå¤©ğŸ˜‚ã€‚skynetä¸­å°±æœ‰ä¸€ä¸ªè¿™æ ·çš„æœåŠ¡ï¼Œä¸“é—¨ç”¨äºå¹¿æ’­æ¶ˆæ¯ã€‚ä¸è¿‡å®ç°çš„ç»†èŠ‚æ˜¯æ¯”è¾ƒå¤æ‚çš„å¯ä»¥å»çœ‹ä¸€çœ‹skynetçš„æ–°ç»„æ’­æ–¹æ¡ˆ è¿™é‡Œæˆ‘å…ˆç«‹ä¸ªflag ç­‰æˆ‘çš„æ¡†æ¶å†™åˆ°è¿™éƒ¨åˆ†çš„æ—¶å€™å†ç»†ç»†ç ”ç©¶ å†ä¸æµï¼Œä½ å°±æŠŠè¿™ç§éœ€è¦ä¸–ç•Œå¹¿æ’­çš„ä¸šåŠ¡(æ¯”å¦‚ä¸–ç•ŒèŠå¤©)ç”¨å•ç‹¬çš„æœåŠ¡å™¨æ‰¿è½½ï¼ŒæŠŠä¸šåŠ¡åˆ’åˆ†å‡ºæ¥ï¼Œè®©å•ç‹¬çš„æœåŠ¡å™¨å»åšã€‚ actoræ¨¡å‹çš„å®ç°é™¤äº†skynet,akka,proto.actor(æœ‰ä¸¤ç§å®ç°ä¸€ç§æ˜¯ c# è¿˜æœ‰ä¸€ç§æ˜¯ golangå®ç°çš„ golangå®ç°çš„è¿˜ä¸ç¨³å®š) è¿˜æœ‰åœ¨æ¸¸æˆä¸­å¹¿æ³›ä½¿ç”¨çš„erlangè¯­è¨€ï¼Œå¤©ç”Ÿä»è¯­è¨€å±‚é¢å°±æ”¯æŒactoræ¨¡å‹ è¦æƒ³è‡ªå·±é€ ä¸€ä¸ªactorçš„è½®å­ä½ å¾—æ¸…æ¥šç½‘ç»œæ•°æ®ä¼ è¾“çš„è§£ç /ç¼–ç ï¼Œç†Ÿæ‚‰æ¶ˆæ¯é˜Ÿåˆ—ã€‚ ","date":"2022-10-04","objectID":"/introduction/:2:0","tags":["actor","gamedev"],"title":"actor æ¨¡å‹ä»‹ç»å’Œæ„Ÿæ‚Ÿ","uri":"/introduction/"},{"categories":["golang"],"content":"golangçš„è¯­æ³•åŸºç¡€: ç¼–ç¨‹è¯­è¨€çš„è¯­æ³•æ€»æ˜¯ç¦»ä¸å¼€ä¸‰ä»¶å¥—ï¼Œå˜é‡ï¼Œå‡½æ•°ï¼Œæ§åˆ¶ç»“æ„. è¿™é‡Œç€é‡ä»‹ç»golangè¿™ä¸‰éƒ¨åˆ†çš„åŸºç¡€çŸ¥è¯†.","date":"2022-10-04","objectID":"/syntax/","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"å®šä¹‰(Declarations) å®šä¹‰ç”¨æ¥æè¿°ä¸€ä¸ªç¼–ç¨‹å…ƒç´ çš„åŸºæœ¬å±æ€§ï¼Œæ¯”è¾ƒéš¾ç†è§£ã€‚é€šä¿—æ¥è¯´ï¼Œå°±æ˜¯æŒ‡å®šè¿™ä¸ªå…ƒç´ æ˜¯å¹²ä»€ä¹ˆçš„ã€‚å…ƒç´ è¢«å®šä¹‰çš„é‚£ä¸€åˆ»å°±è¢«èµ‹äºˆäº†èŒèƒ½ã€‚æ¯”å¦‚æ€»ç»Ÿæœ‰æ€»ç»Ÿè¯¥å¹²çš„äº‹ï¼ŒçŒ«å¤©ç”Ÿå°±ä¼šæŠ“è€é¼ ï¼Œæ°´å¯ä»¥å‘ˆç°æ¶²æ€ï¼Œå›ºæ€ï¼Œæ°”æ€ä¸‰ç§å½¢å¼ã€‚ golangæœ‰ä¸‰ç§å½¢å¼çš„å®šä¹‰ var ç”¨æ¥å®šä¹‰å˜é‡ const ç”¨æ¥å®šä¹‰å¸¸é‡ type ç”¨æ¥å®šä¹‰ç±»å‹ func ç”¨æ¥å®šä¹‰å‡½æ•° ","date":"2022-10-04","objectID":"/syntax/:1:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"å®šä¹‰çš„ä½œç”¨åŸŸ å®šä¹‰æ˜¯åˆ†ä½œç”¨èŒƒå›´çš„ï¼Œgolangçš„ä½œç”¨èŒƒå›´åˆ†ä¸º package-level åŒ…çº§åˆ«: åœ¨åŒ…ä¸­éƒ½èƒ½è¢«è®¿é—®åˆ° func-level å‡½æ•°çº§åˆ«: åªèƒ½åœ¨å‡½æ•°ä¸­è¢«è®¿é—®åˆ° block-level å—çº§åˆ«: åªèƒ½åœ¨ä»£ç å—ä¸­è¢«è®¿é—®åˆ° ä¸‰ä¸ªä½œç”¨åŸŸçº§åˆ«ç”±å¤§åˆ°å°ï¼Œblock-levelæœ€å°. package-level package main //ç”³æ˜æ‰€åœ¨çš„åŒ… import \"fmt\" const boilingF = 212.0 func main() { } åœ¨è¿™æ®µä»£ç ä¸­ boilingF å°±æ˜¯åŒ…çº§åˆ«çš„å¸¸é‡. åªè¦é¡¹ç›®æ–‡ä»¶çš„å¼€å¤´ç”³æ˜äº† package main é‚£ä¹ˆboilingFå°±å¯ä»¥åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­è¢«è®¿é—®åˆ° func-level package main import \"fmt\" func main() { const boilingF = 212.0 } è¿™æ®µä»£ç çš„boilingFå°±åªèƒ½åœ¨mainå‡½æ•°ä¸­è¢«è®¿é—®åˆ° block-level package main import \"fmt\" func main() { if true { const boilingF = 212.0 } } è¿™é‡Œçš„boilingFå°±åªèƒ½åœ¨ifä»£ç å—ä¸­è¢«è®¿é—® åŒåå®šä¹‰çš„è®¿é—®é¡ºåºè‡ªåº•å‘ä¸Š è¯•æƒ³ä¸€ç§åœºæ™¯ï¼Œè‹¥åœ¨ä¸‰ä¸ªä½œç”¨åŸŸçº§åˆ«ä¸­ï¼Œæˆ‘ä»¬åˆ†åˆ«éƒ½å®šä¹‰äº† boilingF é‚£æˆ‘ä»¬å°†è®¿é—®åˆ°å“ªä¸€ä¸ª boilingF package main import \"fmt\" const boilingF = 212.0 func main() { const boilingF = 213.0 fmt.Printf(\"boilingF %d\\n\",boilingF) if true { const boilingF = 214.0 fmt.Printf(\"boilingF %d\\n\",boilingF) } } æ‰§è¡Œç»“æœ boilingF = 213.000000 boilingF = 214.000000 å¯ä»¥çœ‹åˆ°ç¬¬ä¸€ä¸ªæ‰“å°æ‰“å°çš„æ˜¯213è€Œä¸æ˜¯212.0 è¯´æ˜212è¢«213éšè—äº†. è€Œåœ¨ifä»£ç å—ä¸­ æ‰“å°çš„æ˜¯214è€Œä¸æ˜¯213è¯´æ˜213è¢«éšè—äº†ã€‚ è¿™è¯´æ˜è‹¥æœ‰åŒåå˜é‡ï¼Œé‚£ä¹ˆä½ä½œç”¨åŸŸçš„å®šä¹‰å°†ä¼šè¦†ç›–é«˜ä½œç”¨åŸŸçš„å®šä¹‰ åŒä½œç”¨åŸŸå†…ï¼Œä¸å¯é‡å®šä¹‰åŒåå˜é‡ package main import \"fmt\" const boilingF = 212.0 const boilingF = 212.0 func main() { } è¿™æ®µä»£ç ç¼–è¯‘æ˜¯ä¸ä¼šé€šè¿‡çš„ï¼Œå› ä¸ºå®šä¹‰äº†ä¸¤æ¬¡boilingFå±äºé‡å®šä¹‰é”™è¯¯ note è¿™äº›åªæ˜¯ä¸€äº›åŸºæœ¬çš„çŸ¥è¯†ï¼Œæ›´å¤šçš„æœ‰å…³å®šä¹‰çš„å‘å°†ä¼šåœ¨ä¸‹é¢çš„å˜é‡ä¸­ä»‹ç» ","date":"2022-10-04","objectID":"/syntax/:1:1","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"å˜é‡(variable) å˜é‡æœ‰ä¸¤ç§å®šä¹‰æ–¹å¼ var var name type = expression è¯­æ³•ç³– := name := expression ","date":"2022-10-04","objectID":"/syntax/:2:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"ä½¿ç”¨varæ¥å®šä¹‰ åœ¨ä½¿ç”¨var æ¥å®šä¹‰å˜é‡æ—¶ type å’Œ expressionå¯ä»¥çœç•¥å…¶ä¸­ä¸€ä¸ª ä½†æ˜¯ä¸å¯ä»¥åŒæ—¶çœç•¥ï¼ˆåŒæ—¶çœç•¥çš„è¯ï¼Œgoå°†ä¸æ¸…æ¥šæˆ‘ä»¬å…·ä½“è¦å®šä¹‰ä»€ä¹ˆï¼‰ çœç•¥type(è‡ªåŠ¨æ¨å€’ç±»å‹) çœç•¥type çš„æ—¶å€™ golangå°†ä¼šæ ¹æ®expressionè‡ªåŠ¨æ¨å€’ç±»å‹ï¼Œ åé¢å°†ä¼šä»‹ç»çš„ := å°±æ˜¯è¿™ç§å†™æ³•çš„è¯­æ³•ç³– æ¯”å¦‚ var name = \"jidibinlin\" // name çš„ç±»å‹æ˜¯string var age = 12 // age çš„ç±»å‹æ˜¯age çœç•¥expression è‹¥çœç•¥expression å˜é‡å°†è¢«é»˜è®¤å€¼ï¼ˆ0å€¼)å–ä»£ã€‚ å¯¹äºæ•°å€¼ç±»å‹ï¼Œé»˜è®¤å€¼å°†æ˜¯0, å¯¹äºå­—ç¬¦ä¸²å°†ä¼šæ˜¯\"\" å¯¹äºboolå‹å°†ä¼šæ˜¯false,å¯¹äºå¼•ç”¨ç±»å‹(slice,pointer,map,channel,function) å°†ä¼šæ˜¯nil å¯¹äºarrayå’Œstructæ¥è¯´ï¼Œä»–ä»¬çš„å…ƒç´ å°†ä¼šæ˜¯0å€¼ var s string // s = \"\" var i int // i = 0 var b bool // b = false var slc []int // slic = nil var arr [3]int // arr[0]=0 arr[1]=0 arr[2]=0 type astruct struct { s string i int b bool slc []int } var stru astruct // stru.s = \"\" stru.i = 0 stru.b = false stru.slc = nil ä¸€æ¬¡å®šä¹‰å¤šä¸ªå˜é‡ var i, j, k int //int, int, int var b, f, s = true, 2.3, \"fout\" //bool,float64,string æ¥å—å¤šè¿”å›å€¼å‡½æ•°çš„è¿”å›å€¼ goå¯ä»¥å®šä¹‰å¤šè¿”å›å€¼çš„å‡½æ•°ã€‚ ä½¿ç”¨var å°±å¯ä»¥å¾ˆä¾¿æ·çš„ç”³æ˜å¤šä¸ªå˜é‡ç”¨æ¥æ¥å—å‡½æ•°çš„è¿”å›å€¼. var f,err = os.Open(name) //os.Open ä¼šè¿”å›ä¸€ä¸ªfile å’Œ ä¸€ä¸ªerror note æ³¨æ„ï¼Œç”±äºå‡½æ•°çš„è¿”å›å€¼ç±»å‹æ˜¯ä¸ç¡®å®šçš„ã€‚ è€Œvar åœ¨å®šä¹‰å¤šå˜é‡çš„æ—¶å€™åªèƒ½æ˜¯åŒä¸€ç±»å‹çš„ var i, j ,k int æ‰€ä»¥åœ¨æ¥æ”¶å¤šè¿”å›å€¼å‡½æ•°çš„æ—¶å€™ï¼Œå»ºè®®ä½¿ç”¨è‡ªåŠ¨ç±»å‹æ¨å€’(å¼ºçƒˆå»ºè®®) ","date":"2022-10-04","objectID":"/syntax/:2:1","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":":= è¯­æ³•ç³– := æ˜¯ç”¨æ¥å®šä¹‰å’Œåˆå§‹åŒ–å˜é‡çš„è¯­æ³•ç³– name := expression ä¹ä¸€çœ‹ä¼¼ä¹å’Œè‡ªåŠ¨æ¨å€’ç±»å‹çš„var å½¢å¼å¾ˆåƒï¼Œä½†æ˜¯ä¸¤è€…æ˜¯æœ‰åŒºåˆ«çš„. ä¸¤è€…éƒ½å¯ä»¥è‡ªåŠ¨æ¨å€’å˜é‡çš„ç±»å‹, éƒ½å¯ä»¥åŒæ—¶ç”³æ˜å¤šä¸ªvariable var name = \"\" //nameçš„ç±»å‹ä¸ºstring name1 := \"\" // nameçš„ç±»å‹ä¸ºstring name2, name3, name4 := \"\",\"\",\"\" ä½†æ˜¯ := è¯­æ³•ç³–åªèƒ½åœ¨å‡½æ•°çš„å†…éƒ¨ç”¨æ¥ç”³æ˜å’Œåˆå§‹åŒ–å˜é‡,è€Œvar å´å¯ä»¥ç”¨åœ¨å‡½æ•°å¤–éƒ¨ package main var i = 1 // right j := 1 //wrong func main() { k := 2 //right var g = 1 //right } := å’Œ var éƒ½ä¼šç”³æ˜æ–°çš„å˜é‡ï¼Œä½†æ˜¯:=å´ä¼šè€ƒè™‘é‡ç”¨å·²æœ‰çš„å˜é‡ var n1, n2 = \"\",\"\" var n2, n3 = \"\",\"\" // wrong è¿™é‡Œä¼šæŠ¥n2é‡å®šä¹‰ name1,name2 := \"\",\"\" name2,name3 := \"\",\"\" //right := ä¼šé‡ç”¨name2 (å¦‚æœæœ‰å·²ç»ç”³æ˜çš„å˜é‡çš„è¯ ä¼šé‡ç”¨) warning æ³¨æ„ := çš„å·¦ä¾§å¿…é¡»æœ‰æœªè¢«ç”³æ˜çš„å˜é‡æ‰èƒ½è¢«æ‰§è¡Œ name1,name2 :=\"\",\"\" name1,name2 :=\"\",\"\" //wrong ","date":"2022-10-04","objectID":"/syntax/:2:2","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"PointeræŒ‡é’ˆ å¦‚æœå¯¹cç³»åˆ—çš„è¯­è¨€æœ‰äº†è§£çš„è¯ï¼Œåº”è¯¥å¯¹æŒ‡é’ˆæ˜¯ä¸é™Œç”Ÿçš„. åœ¨go ä¸­æŒ‡é’ˆçš„ç”¨æ³•å’Œcè¯­è¨€å‡ ä¹ç›¸åŒ ä½¿ç”¨* å£°æ˜/è§£å¼•ç”¨ï¼Œä½¿ç”¨\u0026æ¥å–åœ°å€ x := 1 p := \u0026x //å–åœ°å€ å¹¶å£°æ˜ä¸€ä¸ªpæŒ‡é’ˆæŒ‡å‘x *p = 2 // å°†2å­˜è¿›pæŒ‡å‘çš„å˜é‡ä¹Ÿå°±æ˜¯x æœ‰å…³goçš„æŒ‡é’ˆä¸è¿‡å¤šä»‹ç» ","date":"2022-10-04","objectID":"/syntax/:2:3","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"newå‡½æ•° newä¹Ÿå¯ä»¥ç”¨æ¥åˆ›å»ºæŒ‡é’ˆ,ä½†æ˜¯newåˆ›å»ºçš„æ˜¯æŒ‡é’ˆç±»å‹,ä½¿ç”¨çš„æ—¶å€™ç›´æ¥åœ¨ä¼ å…¥ä¸€ä¸ªç±»å‹å³å¯ p := new(int) //pæŒ‡å‘ä¸€å—intå‹çš„å†…å­˜ç©ºé—´ *p = 2 //ç»™pæŒ‡å‘çš„ç©ºé—´èµ‹å€¼ new å’Œå£°æ˜æŒ‡é’ˆçš„åŒºåˆ«åœ¨äºï¼Œnewä¼šå…ˆåˆ†é…å†…å­˜ç©ºé—´å†å°†è¿™å—ç©ºé—´çš„åœ°å€è¿”å›ï¼Œè€Œå£°æ˜æŒ‡é’ˆåªæ˜¯å£°æ˜äº†ä¸€ä¸ªæŒ‡é’ˆï¼Œä½†æ˜¯å®ƒå¹¶ä¸æŒ‡å‘ä»»ä½•åœ°å€ã€‚new æ›´åƒæ˜¯å…ˆå£°æ˜å˜é‡ï¼Œå†å°†å˜é‡çš„åœ°å€è¿”å›. ","date":"2022-10-04","objectID":"/syntax/:2:4","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ é™¤äº†åŒ…çº§åˆ«çš„å˜é‡å¤–(å£°æ˜åœ¨å‡½æ•°å¤–çš„å˜é‡), å…¶ä½™å˜é‡çš„ç”Ÿå‘½å‘¨æœŸéƒ½æ˜¯åŠ¨æ€çš„ã€‚ åŒ…çº§åˆ«çš„å˜é‡ç”Ÿå‘½å‘¨æœŸå°†ä¼šæŒç»­åˆ°æ•´ä¸ªç¨‹åºè¢«ç»ˆæ­¢ã€‚ åŠ¨æ€ç”Ÿå‘½å‘¨æœŸæŒ‡å˜é‡ä»å˜é‡è¢«å£°æ˜çš„é‚£ä¸€åˆ»èµ·ï¼Œä¸€ç›´åˆ°å®ƒæ— æ³•è¢«è®¿é—®åˆ°ä¸ºæ­¢ã€‚å½“å˜é‡æ— æ³•è¢«è®¿é—®æ—¶ä»–çš„å†…å­˜å¯èƒ½ä¼šè¢«å›æ”¶ã€‚ ç”±äºå˜é‡çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ç”±å…¶èƒ½å¦è¢«è®¿é—®åˆ°å†³å®šçš„ï¼Œæ‰€ä»¥å˜é‡æœ‰å¯èƒ½ä¼šè·³å‡ºå¾ªç¯æˆ–è€…å‡½æ•°ç»§ç»­å­˜åœ¨ã€‚ note ä¸€èˆ¬æ¥è¯´å±€éƒ¨å˜é‡çš„å¯ä»¥è·³å‡ºä»£ç å—è€Œå­˜åœ¨çš„è¯ï¼Œæˆ‘ä»¬å°±è¯´è¿™æ˜¯ä¸€ä¸ªé€ƒé€¸å˜é‡ã€‚ç›¸å¯¹äºéé€ƒé€¸å˜é‡æ¥è¯´ï¼Œé€ƒé€¸å˜é‡çš„å†…å­˜å°†ä¼šè¢«åˆ†é…åœ¨å †ä¸Šï¼Œè€Œéé€ƒé€¸å˜é‡æ˜¯åˆ†é…åœ¨æ ˆä¸Šçš„ã€‚ c++ ç¨‹åºå‘˜éœ€è¦å…³å¿ƒå˜é‡æ˜¯åˆ†é…åœ¨æ ˆä¸Šå¥½ï¼Œè¿˜æ˜¯åˆ†é…åœ¨å †ä¸Šå¥½ã€‚ä½†æ˜¯å¯¹äºgoæ¥è¯´ï¼Œè¿™äº›éƒ½æ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨å®Œæˆçš„ï¼Œç¨‹åºå‘˜æ— éœ€å…³å¿ƒå˜é‡çš„å†…å­˜æ˜¯åˆ†é…åœ¨æ ˆä¸Šè¿˜æ˜¯å †ä¸Šã€‚ æ ˆæ˜¯åŠæ—¶å›æ”¶çš„æ•°æ®ç»“æ„ï¼Œæ‰€æœ‰åœ¨æ ˆä¸Šå£°æ˜çš„å˜é‡åœ¨å‡½æ•°ç»“æŸçš„é‚£ä¸€åˆ»éƒ½ä¼šè¢«å›æ”¶ï¼Œæ‰€ä»¥å¦‚æœå˜é‡åœ¨å‡½æ•°å¤–è¿˜å¯ä»¥è¢«ä½¿ç”¨ï¼Œå°±åº”è¯¥åˆ†é…åœ¨å †ä¸Šã€‚c++ä¸­å †æ˜¯ç¨‹åºå‘˜è‡ªå·±é‡Šæ”¾çš„ï¼Œè€Œåœ¨goä¸­ï¼Œgoæœ‰è‡ªå·±çš„å›æ”¶æ–¹æ¡ˆã€‚ var global *int func f() { var x int //xå°†è¢«åˆ†é…åœ¨å †ä¸Šï¼Œå› ä¸ºglobalæŒ‡å‘å®ƒï¼Œä»–é€ƒé€¸å‡ºäº†få‡½æ•° x = 1 global = \u0026x } func g() { y := new(int) //yå°†è¢«åˆ†é…åœ¨æ ˆä¸Šï¼Œå› ä¸ºä»–ä¸æ˜¯é€ƒé€¸å˜é‡ï¼Œå‡ºäº†gå‡½æ•°åï¼Œæ˜¯æ²¡æ³•è¢«è®¿é—®çš„ *y = 1 } ","date":"2022-10-04","objectID":"/syntax/:2:5","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"å˜é‡èµ‹å€¼ èµ‹å€¼å¯ä»¥æ›´æ–°å˜é‡å­˜å‚¨çš„value,ä½†æ˜¯å·¦è¾¹å’Œå³è¾¹çš„ç±»å‹å¿…é¡»æ˜¯åŒ¹é…çš„ï¼ˆæ¯”å¦‚å·¦å³éƒ½æ˜¯åŒç±»å‹çš„,éƒ½å®ç°äº†åŒä¸€ä¸ªæ¥å£ï¼‰ x = 1 *p = true person.name = \"bob\" count[x] = count[x]*scale cè¯­è¨€æ”¯æŒçš„èµ‹å€¼æ“ä½œgoéƒ½æ”¯æŒåŒ…æ‹¬++,â€“,+=,-=, ç§»ä½ç­‰ç­‰ ","date":"2022-10-04","objectID":"/syntax/:3:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"å…ƒç»„èµ‹å€¼(tuple assignment) å…ƒç»„èµ‹å€¼å…è®¸å¤šä¸ªå˜é‡åŒæ—¶è¢«èµ‹å€¼ï¼Œæ‰€æœ‰å³è¾¹çš„å˜é‡éƒ½ä¼šå…ˆè¢«è¿ç®—ç„¶åå†èµ‹å€¼ç»™å·¦è¾¹ã€‚ä¹Ÿå°±æ˜¯è¯´ä½ å¯ä»¥è¿™æ ·äº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼ x, y = y, x å‰é¢æœ‰æåˆ°è¿‡ï¼Œgoçš„è¿”å›å€¼å¯ä»¥æœ‰å¤šä¸ªã€‚goä¹ æƒ¯ç”¨ç¬¬äºŒä¸ªè¿”å›å€¼è¡¨ç¤ºå‡½æ•°æ‰§è¡Œçš„çŠ¶æ€ï¼Œç¬¬äºŒä¸ªè¿”å›å€¼å¯ä»¥æ˜¯error,æˆ–è€…ä¸€ä¸ªboolå€¼ok,è¿™æ ·å°±å¯ä»¥çŸ¥é“åœ¨å–å‡ºå˜é‡å’Œè°ƒç”¨å‡½æ•°çš„æ—¶å€™æ˜¯å¦æœ‰é”™è¯¯å’Œå¼‚å¸¸å‡ºç°ã€‚ f, err = os.Open(\"foo.text\") //å¦‚æœerr ä¸ä¸ºnilçš„è¯è¡¨ç¤ºæ‰“å¼€æ–‡ä»¶å¤±è´¥ è¿™ä¸€ç‚¹åœ¨goä¸­ç»å¸¸è¢«ç”¨åˆ° v,ok = m[key] //ä»mapä¸­å–å€¼ v,ok = x.(T) //ç±»å‹æ–­è¨€ v,ok = \u003c-ch //ä»channelä¸­æ¥å— å¦‚æœä½ å¹¶ä¸éœ€è¦ç”¨åˆ°æŸäº›è¿”å›å€¼ï¼Œä½ å¯ä»¥ç”¨ â€œ_â€ å ä½æ¥å¿½ç•¥å®ƒ _, err = io.Copy(dst,src) //discard byte count _, ok = x.(T) //check type but discard result ä½†æ˜¯æï¼Œä¸è¦è¿™æ ·ç”¨ v, _ = io.Copy(dst,src) è¿™æ ·ç”¨å’Œ v = io.Copy(dst,src) æ˜¯æ²¡æœ‰åŒºåˆ«çš„ï¼Œä½†æ˜¯ä¸Šé¢çš„å½¢å¼ä¸æ¨èã€‚å› ä¸ºå…ƒç¥–èµ‹å€¼æ˜¯æŒ‰é¡ºåºçš„ï¼Œå¦‚æœå·¦è¾¹å˜é‡æ•°é‡ä¸è¶³ï¼Œé‚£ä¹ˆå³è¾¹çš„å¤šä½™è¿”å›å€¼ä¼šè¢«è‡ªåŠ¨å¿½ç•¥ note åœ¨goä¸­å‡½æ•°ç»å¸¸ä»¥è¿”å›ä¸€ä¸ªerræˆ–è€…bool å€¼çš„å½¢å¼æ¥å‘Šè¯‰å‡½æ•°åœ¨è°ƒç”¨çš„æ—¶å€™æ˜¯å¦å‡ºç°é—®é¢˜ã€‚è¿™æ˜¯goå¤„ç†å¼‚å¸¸çš„æ–¹å¼ã€‚ ","date":"2022-10-04","objectID":"/syntax/:3:1","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"Typeå®šä¹‰ variableå’Œexpressionçš„ç±»å‹å®šä¹‰äº†è¿™ä¸ªvariableçš„ç‰¹å¾ï¼Œä¾‹å¦‚è¿™ä¸ªå€¼çš„å¤§å°ï¼Œå†…éƒ¨æ˜¯å¦‚ä½•è¡¨ç¤ºçš„ï¼Œå¯ä»¥å¯¹å®ƒåšå“ªäº›æ“ä½œï¼Œå’Œå®ƒç›¸å…³çš„å‡½æ•°æœ‰å“ªäº›ã€‚ type å¯ä»¥å®šä¹‰ä¸€ä¸ªæ–°çš„ç±»å‹ï¼ˆåŸºäºå·²æœ‰ç±»å‹ï¼Œå¹¶ä¸”å…·æœ‰ä»–çš„ä¸€åˆ‡ç‰¹æ€§ï¼‰ type name underlying-type typeå®šä¹‰ä¸€èˆ¬å†™åœ¨åŒ…çº§åˆ«çš„ä½œç”¨åŸŸä¸­ï¼Œè¿™æ ·å¯¹æ•´ä¸ªåŒ…ä¸­çš„ä»£ç éƒ½æ˜¯å¯è§çš„ã€‚å¦‚æœè¿™ä¸ªç±»å‹è¢«å¯¼å‡ºäº†ï¼Œä¹Ÿå¯ä»¥åœ¨åŒ…å¤–ä½¿ç”¨. æˆ‘é—¨å…ˆçœ‹ä¸€æ®µç®€çŸ­çš„ä»£ç  package tempconv import \"fmt\" type Celsius float64 type Fahrenheit float64 const ( AbsoluteZeroC Celsius = -273.15 FreezingC Celsius = 0 BoilingC Celsius = 100 ) func CToF (c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } func FToC (f Fahrenheit) Celsius { return Celsius((f-32) * 5 /9) } è¿™æ®µä»£ç å®šä¹‰äº†æ¸©åº¦çš„ä¸¤ç§è¡¨ç¤ºæ–¹æ³•Celsius(æ‘„æ°åº¦)å’ŒFahrenheit(åæ°åº¦),ä¸¤è€…çš„åŸºæœ¬ç±»å‹éƒ½æ˜¯Float64ã€‚Celsiuså’ŒFahrenheitæ˜¯ä¸¤ç§ä¸åŒçš„ç±»å‹ï¼Œæ‰€ä»¥ä¸¤è€…ä¸èƒ½åšæ•°å­¦è¿ç®—å’Œé€»è¾‘è¿ç®—ã€‚è¿™æ ·åšæ˜¯ä¸ºäº†é˜²æ­¢å› ä¸ºè¡¨ç¤ºæ¸©åº¦çš„å•ä½ä¸åŒè€Œå¯¼è‡´é”™è¯¯ã€‚Celsius(t)å’ŒFahrenheit(t)æ˜¯è½¬å‹å™¨ï¼Œå¹¶ä¸æ˜¯å‡½æ•°è°ƒç”¨ã€‚typeå®šä¹‰æ˜¾ç¤ºçš„æ”¹å˜äº†ç±»å‹çš„æ„ä¹‰ã€‚ å¯¹äºä»»æ„çš„ç±»å‹Téƒ½æœ‰å¯¹åº”çš„è½¬å‹æ“ä½œT(x)ç”¨æ¥å°†å…¶ä»–ç±»å‹çš„å€¼xè½¬å‹æˆTç±»å‹çš„å€¼. å½“ä¸¤ç§ç±»å‹çš„åŸºæœ¬ç±»å‹æ˜¯ç›¸åŒçš„æ—¶å€™ï¼Œè½¬å‹æ‰è¢«å…è®¸ã€‚å¦‚æœæ˜¯æŒ‡é’ˆç±»å‹ï¼Œè¢«æŒ‡å‘çš„å€¼å¿…é¡»å…·æœ‰ç›¸åŒçš„åŸºæœ¬ç±»å‹æ‰èƒ½å¤Ÿè¢«è½¬å‹ã€‚è¿™äº›è½¬å‹åªä¼šè½¬æ¢typeä½†æ˜¯å€¼çš„è¡¨ç¤ºæ˜¯ä¸ä¼šæ”¹å˜çš„ã€‚ è½¬å‹ä¹Ÿèƒ½å‘ç”Ÿåœ¨æ•°å€¼ç±»å‹ï¼Œstring,å’Œä¸€äº›sliceç±»å‹ä¹‹é—´ï¼Œè¿™äº›è½¬å‹å¯èƒ½ä¼šæ”¹å˜å€¼çš„è¡¨ç¤ºï¼Œæ¯”å¦‚å°†floatç±»å‹è½¬å‹æˆintegerç±»å‹ä¼šä¸¢å¤±å°æ•°ç‚¹ã€‚å°†stringç±»å‹è½¬æˆ[]byte slice. åŸºæœ¬ç±»å‹å†³å®šäº† named typeçš„ç»“æ„å’Œè¡¨ç¤ºï¼Œä»¥åŠæ‰€æ”¯æŒçš„æ“ä½œï¼Œå°±åƒæ˜¯åŸºæœ¬ç±»å‹è¢«ç›´æ¥ä½¿ç”¨ä¸€æ ·ã€‚ä¸è¿‡ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºnamed type é¢å¤–å®šä¹‰ä¸€äº›æ“ä½œã€‚ func (c Celsius) string() string { return fmt.Sprintf(\"%g*c\"ï¼Œc) } è¿™æ®µä»£ç ä¼šè¿”å›Celsiusçš„stringç±»å‹å¹¶ä»¥*cç»“å°¾ note è®¸å¤šç±»å‹éƒ½å®šä¹‰äº†stringæ“ä½œï¼Œè¿™æ ·åœ¨ä½¿ç”¨fmtæ‰“å°çš„æ—¶å€™ï¼Œå°±å¯ä»¥æ›´åŠ çš„å¥½çœ‹ ","date":"2022-10-04","objectID":"/syntax/:4:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"packages å’Œ Files goä¸­çš„packageå°±åƒå…¶ä»–è¯­è¨€ä¸­çš„libraries å’Œ modules. æä¾›modularity(æ¨¡å—åŒ–),encapsulation(å°è£…),separate compilation(éš”ç¦»ç¼–è¯‘)å’Œreuse(é‡ç”¨)ç‰¹æ€§ã€‚ä»£ç å¯ä»¥å†™åœ¨packageä¸­å¤šä¸ª.goç»“å°¾çš„æ–‡ä»¶ä¸­ã€‚ æ¯ä¸ªåŒ…éƒ½æœ‰ä¸€ä¸ªç‹¬ç«‹çš„å‘½åç©ºé—´ï¼Œå½“æˆ‘ä»¬è¦åœ¨å¤–éƒ¨ä½¿ç”¨è¿™ä¸ªåŒ…ä¸­çš„ä¸œè¥¿çš„æ—¶å€™ï¼Œå¿…é¡»è¦åŠ ä¸ŠåŒ…åä½œä¸ºå‰ç¼€ã€‚ä¾‹å¦‚è¦æ˜¯ç”¨imageåŒ…ä¸­çš„Decodeæˆ‘ä»¬éœ€è¦ image.Docode,è¦ä½¿ç”¨utf16åŒ…ä¸­çš„Decodeæˆ‘ä»¬éœ€è¦utf16.Decode. è¦æƒ³å¯¼å‡ºpackageä¸­çš„å˜é‡ï¼Œå®šä¹‰ï¼Œå‡½æ•°ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨å®šä¹‰ä»–ä»¬çš„æ—¶å€™ä»¥å¤§å†™å­—æ¯å¼€å¤´ã€‚æˆ‘ä»¬ä¸¾ä¸€ä¸ªä¾‹å­ //Package tempconv performs Celsius and Fahrenheit conversions. package tempconv import \"fmt\" type Celsius float64 type Fahrenheit float64 const ( AbsoluteZeroC Celsius = -273.15 FreezingC Celsius = 0 BoilingC celsius = 100 ) func (c Celsius) String() string { return fmt.Sprintf(\"%g*c\",c) } func (f Fahrenheit) String() string { return fmt.Sprintf(\"%g*F\",f) } package tempconv // CToF converts a Celsius temperature to Fahrenheit. func CToF (c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } //FToC converts a Fahrenheit temperature to Celsius. func FToC (f Fahrenheit) Celsius { return Celsius((f-32) *5 / 9) } åœ¨åŒ…ä¸­ï¼Œæ‰€æœ‰æ–‡ä»¶éƒ½åº”ä»¥åŒ…å®šä¹‰å¼€å¤´ï¼Œè¿™é‡Œæ˜¯ package tempconv. å½“åŒ…è¢«å¯¼å…¥åï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨tempconv.CToF è¿™æ ·çš„å½¢å¼ä½¿ç”¨åŒ…ä¸­æš´éœ²å‡ºæ¥çš„æˆå‘˜(ä»¥å¤§å†™å­—æ¯å¼€å¤´)ã€‚ ","date":"2022-10-04","objectID":"/syntax/:5:0","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"imports åœ¨goä¸­ï¼Œæ‰€æœ‰çš„åŒ…éƒ½è¢«ä¸€ä¸ªå”¯ä¸€çš„import pathæ ‡è¯†(string ç±»å‹) æ¯”å¦‚\"foo/tempconv\"ã€‚import path è¡¨æ˜äº†åŒ…å«åŒ…ä¸­çš„æ–‡ä»¶çš„è·¯å¾„. é™¤äº†import path æ¯ä¸ªåŒ…è¿˜æœ‰ä¸€ä¸ªpackage name, ç›¸å¯¹import pathè¦çŸ­å¾ˆå¤š. é€šå¸¸ä¸€ä¸ªåŒ…çš„åå­—é€šå¸¸æ˜¯import path çš„æœ€åä¸€ä¸ªåˆ†å‰²æ®µ æ¯”å¦‚foot/tempconv çš„åŒ…åå°±æ˜¯tempconv. // Cf converts its numeric argument to Celsius and Fahrenheit. package main import ( \"fmt\" \"os\" \"strconv\" \"foo/tempconv\" ) func main() { for _, arg := range os.Args[1:] { t, err := strconv.ParseFloat(arg, 64) if err != nil { fmt.Fprintf(os.Stderr, \"cf: %v\\n\", err) os.Exit(1) } f := tempconv.Fahrenheit(t) c := tempconv.Celsius(t) fmt.Printf(\"%s = %s, %s = %s\\n\", f, tempconv.FToC(f), c, tempconv.CToF(c)) } } æˆ‘ä»¬åº”ç›´æ¥ä½¿ç”¨tempconv(åŒ…å)è€Œä¸æ˜¯import path,æˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨import çš„æ—¶å€™å®šä¹‰åŒ…çš„åˆ«åä»¥é˜²æ­¢å†²çª. package main import ( \"fmt\" \"os\" \"strconv\" conv \"foo/tempconv\" ) func main () { for _, arg := range os.Args[1:] { t,err := strconv.ParseFloat(arg,64) if err != nil { fmt.Fprintf(os.Stderr,\"cf:%v\\n\",err) os.Exit(1) } f := conv.Fahrenheit(t) c := conv.Celsius(t) fmt.Printf(\"%s = %s, %s = %s\\n\", f,conv.FToC(f),c,conv.CToF(c)) } } å¯¼å…¥æœªä½¿ç”¨çš„åŒ…æ˜¯ä¸è¢«å…è®¸çš„ï¼Œåœ¨ç¼–è¯‘å‰å¿…é¡»åˆ é™¤å¤šä½™çš„å¯¼å…¥ï¼Œæ¨èä½¿ç”¨golang.org/x/tools/cmd/goimports å·¥å…·ã€‚ å®ƒä¼šè‡ªåŠ¨å¯¼å…¥å’Œåˆ é™¤ä¸å¿…è¦çš„å¯¼å…¥ã€‚ ","date":"2022-10-04","objectID":"/syntax/:5:1","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"åŒ…åˆå§‹åŒ– packageä¼šæŒ‰å®šä¹‰çš„é¡ºåºå…ˆåˆå§‹åŒ–åŒ…çº§åˆ«çš„å˜é‡ï¼ˆä½†æ˜¯ä¼šå…ˆè§£å†³ä¾èµ–ï¼‰ var a = b + c // a initialized third, to 3 var b = f() // b initialized second, to 2, by calling f var c = 1 // c initialized first, to 1 func f() int { return c + 1 } ä¸ºäº†ä½¿ç”¨å¯¼å…¥çš„ç¨‹åºåŒ…ï¼Œå¿…é¡»é¦–å…ˆå¯¹å…¶è¿›è¡Œåˆå§‹åŒ–ï¼Œè€ŒåŒ…çš„åˆå§‹åŒ–è¿‡ç¨‹å¯ä»¥ç”±è¿™å¼ å›¾è¡¨ç¤ºå‡ºæ¥ æµç¨‹æ˜¯ å…ˆå¯¼å…¥åŒ…ï¼ˆé€’å½’å¯¼å…¥ï¼‰ åˆå§‹åŒ–const åˆå§‹åŒ–var è°ƒç”¨init()å‡½æ•° warning åœ¨golangä¸­ init()å‡½æ•°ä¼šåœ¨åˆå§‹åŒ–æ—¶è¢«è‡ªåŠ¨è°ƒç”¨ï¼Œä½†æ˜¯init()å‡½æ•°ä¸èƒ½å¤Ÿè¢«æ‰‹åŠ¨è°ƒç”¨ã€‚åŒä¸€ä¸ªåŒ…ä¸­å¯ä»¥å‡ºç°å¤šä¸ªinit()å‡½æ•°ï¼Œä½†æ˜¯init()çš„è°ƒç”¨é¡ºåºæ˜¯ä¸è¢«ä¿è¯çš„ã€‚æ‰€ä»¥å°½é‡åªå†™ä¸€ä¸ªinit()å‡½æ•° warning éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œgolangä¸­ä¸å…è®¸å¯¼å…¥äº†ï¼Œä½†æœªè¢«ä½¿ç”¨çš„åŒ…å­˜åœ¨ï¼Œä¹Ÿä¸å…è®¸å®šä¹‰äº†ä½†æœªä½¿ç”¨çš„å˜é‡å­˜åœ¨ ","date":"2022-10-04","objectID":"/syntax/:5:2","tags":["golang"],"title":"golang syntax","uri":"/syntax/"},{"categories":["golang"],"content":"golang çš„functional options","date":"2022-10-04","objectID":"/functional_options/","tags":["golang"],"title":"golang functional-options","uri":"/functional_options/"},{"categories":["golang"],"content":"Functional Options goè¯­è¨€çš„å‡½æ•°æ²¡æœ‰é‡è½½ä»¥åŠé»˜è®¤å‚æ•°çš„åŠŸèƒ½ï¼Œè¿™ä¸ªæ—¶å€™ç”Ÿæˆä¸€ä¸ªiå¯¹è±¡ä¼šå˜å¾—æå…¶éº»çƒ¦ type Person struct{ Name string Age int Country string Gender string Height string Address string } func main(){ person :=Person{ Name:\"å¼ ä¸‰\", Age: -1ï¼Œ Country: \"China\", Gender: \"Male\", Height: \"-1\", Address: \"unknown\", } } æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‡½æ•°å¼é€‰é¡¹æ¥è§£å†³è¿™ä¸€é—®é¢˜ã€‚ type Person struct { Name string Age int Country string Gender string Height string Address string } // å°†func(*Person)è¿™ç§ç±»å‹çš„å‡½æ•°ç®€åŒ–å‘½å type per func(*Person) func Country(country string) per { return func(person *Person) { person.Country = country } } func Gender(gender string) per{ return func(person *Person){ person.Gender = gender } } func Gender(gender string) per{ return func(person *Person){ person.Gender = gender } } func Address(address string) per{ return func(person *Person){ person.Address = address } } // NewPerson ... func NewPerson(name string,ops ...per) *Person { person := \u0026Person{ Name: name, Age: -1, Country: \"China\", Gender: \"Male\", Height: 0, Address: \"unknown\", } for _,op:= range ops { op(person) } return person } ","date":"2022-10-04","objectID":"/functional_options/:1:0","tags":["golang"],"title":"golang functional-options","uri":"/functional_options/"},{"categories":["golang"],"content":"ç”¨æ³•ï¼š package main import ( \"fmt\" op \"studygo/pattern/functionOptions\" ) // main ... func main() { person1 := op.NewPerson(\"zhangsan\") fmt.Println(person1) person2 := op.NewPerson(\"Marry\", op.Gender(\"Female\"), op.Country(\"Japan\")) fmt.Println(person2) } ","date":"2022-10-04","objectID":"/functional_options/:1:1","tags":["golang"],"title":"golang functional-options","uri":"/functional_options/"},{"categories":["golang"],"content":"golang ä¸­ä¸€äº›tips ä»effective goé‚£è¾¹è¶…è¿‡æ¥çš„","date":"2022-10-04","objectID":"/tips/","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"this artical is copied from golang official ","date":"2022-10-04","objectID":"/tips/:0:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Formatting Go let the machine take care of most formatting issues. The gofmt program(also available as go fmt,which operates at the package level rather than source file level) emits the source in a standard style of indentation and vertical alignment,retaining and if necessary reformatting comments. before formatted type T struct{ name string //name of the object value int//its value } after formatted type T struct { name string // name of the object value int // its value } ","date":"2022-10-04","objectID":"/tips/:1:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Commentary Go Support C++ style comments. Line comments are norm;block comments appear mostly as package comments. The godoc process Go source files to extract documentation about the contents of the package. Comments that appear before top-level declarations,with no intervening newlines,are extracted along with the declaration to serve as explanatory text for the item. Every package should have a package comment,a block comment preceding the package clause. For multi-file packages,the package comment only needs to be present in one file. The package comment should introduce the package and provide information revelant to the whole package.It will appear first on the godoc page and should set up the detailed documentation as follows. /* Package regexp implements a simple library for regular expressions. The syntax of the regular expressions accepted is: regexp: concatenation { '|' concatenation } concatenation: { closure } closure: term [ '*' | '+' | '?' ] term: '^' '$' '.' character '[' [ '^' ] character-ranges ']' '(' regexp ')' */ package regexp If the package is simple,the package comment can be brief // Package path implements utility routines for // manipulating slash-separated filename paths. Depending on the context, godoc might not even reformat comments, so make sure they look good straight up: use correct spelling, punctuation, and sentence structure, fold long lines, and so on. Inside a package,any comment immediately preceding a top-level delaration serves as doc comment for that declaration.Every exported(Capitalized) name in a program should have a doc comment. Doc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared. // Compile parses a regular expression and returns, if successful, // a Regexp that can be used to match against text. func Compile(str string) (*Regexp, error) { If every doc comment begins with the name of the item it describes, you can use the doc subcommand of the go tool and run the output through grep. Imagine you couldnâ€™t remember the name â€œCompileâ€ but were looking for the parsing function for regular expressions, so you ran the command, $ go doc -all regexp | grep -i parse If all the doc comments in the package began, â€œThis functionâ€¦â€, grep wouldnâ€™t help you remember the name. But because the package starts each doc comment with the name, youâ€™d see something like this, which recalls the word youâ€™re looking for. $ go doc -all regexp | grep -i parse Compile parses a regular expression and returns, if successful, a Regexp MustCompile is like Compile but panics if the expression cannot be parsed. parsed. It simplifies safe initialization of global variables holding $ Go`s declaration syntax allows grouping of declarations.A single doc comment can introduce a group of related constants or variables.Since the whole declaration is presented,such a comment can often be perfunctory // Error codes returned by failures to parse an expression. var ( ErrInternal = errors.New(\"regexp: internal error\") ErrUnmatchedLpar = errors.New(\"regexp: unmatched '('\") ErrUnmatchedRpar = errors.New(\"regexp: unmatched ')'\") ) Grouping can also indicate relationships between items,such as the fact that a set of variables is protected by a mutex var ( countLock sync.Mutex inputCount uint32 outputCount uint32 errorCount uint32 ) ","date":"2022-10-04","objectID":"/tips/:2:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Names The visibility of a name outside a package is determined by whether its first character is upper case. ","date":"2022-10-04","objectID":"/tips/:3:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"package names When a package is imported,the package name becomes an accessor for the contents After import \"bytes\" bytes.Buffer This means that the package name should be good:short concise,evocative.By convention,packages a given lower case,single-word names;there should be no need for underscores or mixedCaps.Err on the side of brevity,since everyone using you package will be typing that name. Another convention is that the package name is the base name of its source directory; the package in src/encoding/base64 is imported as â€œencoding/base64â€ but has name base64, not encoding_base64 and not encodingBase64. The importer of a package will use the name to refer to its contents,so exported names in the package can use that fact to avoid repetition. For instance,the buffered reader type in bufio package is called Reader not BufReader,because users see it as bufio.Reader,which is a clear,concise name. Another short example is once.Do; once.Do(setup) reads well and would not be improved by writing once.DoOrWaitUntilDone(setup). Long names donâ€™t automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name. ","date":"2022-10-04","objectID":"/tips/:3:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Getters Go doesnâ€™t provide automatic support for getters and setters. Thereâ€™s nothing wrong with providing getters and setters yourself, and itâ€™s often appropriate to do so, but itâ€™s neither idiomatic nor necessary to put Get into the getterâ€™s name. If you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported), not GetOwner. The use of upper-case names for export provides the hook to discriminate the field from the method. A setter function, if needed, owner := obj.Owner() if owner != user { obj.SetOwner(user) } ","date":"2022-10-04","objectID":"/tips/:3:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interface names By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc. ","date":"2022-10-04","objectID":"/tips/:3:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"MixedCaps Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names. ","date":"2022-10-04","objectID":"/tips/:3:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Control structures ","date":"2022-10-04","objectID":"/tips/:4:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Redeclaration and reassignment f,err := os.Open(name) d,err := f.Stat() The call to f.Stat uses the existing err variable declared above,and just gives it a new value ","date":"2022-10-04","objectID":"/tips/:4:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"For There are three forms,only one of which has semicolons //like a c for for init;condition;post{ } //like a C While for condition { } // like a c For(;;) for { } Shot declarations make it easy to declare the index varible right in the loop sum := 0 for i := 0;i\u003c10;i++{ sum += i } If youâ€™re looping over an array, slice, string, or map, or reading from a channel, a range clause can manage the loop. for key,value := range oldMap { newMap[key] = value } If you only need the first item in the range (the key or index), drop the second: for key := range m { if key.expired() { delete(m,key) } } If you only need the second item in the range (the value), use the blank identifier, an underscore, to discard the first: sum := 0 for _,value := range array { sum += value } For strings, the range does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD. (The name (with associated builtin type) rune is Go terminology for a single Unicode code point. See the language specification for details.) The loop for pos, char := range \"æ—¥æœ¬\\x80èª\" { // \\x80 is an illegal UTF-8 encoding fmt.Printf(\"character %#U starts at byte position %d\\n\", char, pos) } prints character U+65E5 'æ—¥' starts at byte position 0 character U+672C 'æœ¬' starts at byte position 3 character U+FFFD 'ï¿½' starts at byte position 6 character U+8A9E 'èª' starts at byte position 7 Finally, Go has no comma operator and \\++ and â€“ are statements not expressions. Thus if you want to run multiple variables in a for you should use parallel assignment (although that precludes ++ and â€“). for i,j := 0,len(a)-1 ;i\u003cj;i,j = i+1,j-1{ a[i],a[j] = a[j],a[i] } ","date":"2022-10-04","objectID":"/tips/:4:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Switch Goâ€™s switch is more general than Câ€™s. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the switch has no expression it switches on true. Itâ€™s therefore possibleâ€”and idiomaticâ€”to write an if-else-if-else chain as a switch. func unhex(c byte) byte { switch { case '0' \u003c= c \u0026\u0026 c\u003c= '9': return c- '0' case 'a' \u003c= c \u0026\u0026 c \u003c='f': return c - 'a' + 10 case 'A' \u003c= c \u0026\u0026 c \u003c= 'F': return c - 'A' + 10 } return 0 } There is no automatic fall through,but cases can be presented in comma-separated lists. func shouldEscape(c byte) bool { switch c { case ' ', '?', '\u0026', '=', '#', '+', '%': return true } return false } Although they are not nearly as common in Go as some other C-like languages, break statements can be used to terminate a switch early. Sometimes, though, itâ€™s necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and â€œbreakingâ€ to that label. This example shows both uses. Loop: for n := 0; n \u003c len(src); n += size { switch { case src[n] \u003c sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] \u003c sizeTwo: if n+1 \u003e= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]\u003c\u003cshift) } } Of course, the continue statement also accepts an optional label but it applies only to loops. ","date":"2022-10-04","objectID":"/tips/:4:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Type switch A switch can also be used to discover the dynamic type of an interface variable. Such a type switch uses the syntax of a type assertion with the keyword type inside the parentheses. var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\\n\", t) // %T prints whatever type t has case bool: fmt.Printf(\"boolean %t\\n\", t) // t has type bool case int: fmt.Printf(\"integer %d\\n\", t) // t has type int case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t has type *bool case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t has type *int } ","date":"2022-10-04","objectID":"/tips/:4:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Functions ","date":"2022-10-04","objectID":"/tips/:5:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"multiple return values One of Goâ€™s unusual features is that functions and methods can return multiple values. This form can be used to improve on a couple of clumsy idioms in C programs: in-band error returns such as -1 for EOF and modifying an argument passed by address. In C, a write error is signaled by a negative count with the error code secreted away in a volatile location. In Go, Write can return a count and an error: â€œYes, you wrote some bytes but not all of them because you filled the deviceâ€. The signature of the Write method on files from package os is: func (file *File) Write(b []byte) (n int, err error) and as the documentation says, it returns the number of bytes written and a non-nil error when n != len(b). This is a common style; see the section on error handling for more examples. A similar approach obviates the need to pass a pointer to a return value to simulate a reference parameter. Hereâ€™s a simple-minded function to grab a number from a position in a byte slice, returning the number and the next position. func nextInt(b []byte, i int) (int, int) { for ; i \u003c len(b) \u0026\u0026 !isDigit(b[i]); i++ { } x := 0 for ; i \u003c len(b) \u0026\u0026 isDigit(b[i]); i++ { x = x*10 + int(b[i]) - '0' } return x, i } You could use it to scan the numbers in an input slice b like this: for i := 0; i \u003c len(b); { x, i = nextInt(b, i) fmt.Println(x) } ","date":"2022-10-04","objectID":"/tips/:5:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Named result parameters The return or result â€œparametersâ€ of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values. The names are not mandatory but they can make code shorter and clearer: theyâ€™re documentation. If we name the results of nextInt it becomes obvious which returned int is which. func nextInt(b []byte, pos int) (value, nextPos int) { ","date":"2022-10-04","objectID":"/tips/:5:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Defer Goâ€™s defer statement schedules a function call (the deferred function) to be run immediately before the function executing the defer returns. Itâ€™s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. The canonical examples are unlocking a mutex or closing a file. // Contents returns the file's contents as a string. func Contents(filename string) (string, error) { f, err := os.Open(filename) if err != nil { return \"\", err } defer f.Close() // f.Close will run when we're finished. var result []byte buf := make([]byte, 100) for { n, err := f.Read(buf[0:]) result = append(result, buf[0:n]...) // append is discussed later. if err != nil { if err == io.EOF { break } return \"\", err // f will be closed if we return here. } } return string(result), nil // f will be closed if we return here. } The arguments to be deferred function are evaluated when the defer executes, not when the call executes.Besides avoiding worries about variable changing values as the function executes, this means that a single defer call sit can defer multiple function executions for i := 0; i \u003c 5; i++ { defer fmt.Printf(\"%d \", i) } Defered functions are executed in LIFO order,so this code will caause 4,3,2,1 to be printed when the function returns.A more plausible example is a simple way to trace function execution through the program. We could write a couple of simple tracing routine like this: func trace(s string) { fmt.Println(\"entering:\", s) } func untrace(s string) { fmt.Println(\"leaving:\", s) } // Use them like this: func a() { trace(\"a\") defer untrace(\"a\") // do something.... } We can do better by exploiting the fact that arguments to defer functions are evaluated when the defer executes. The tracing routine can set up the argument to the untracing routine. func trace(s string) string { fmt.Println(\"entering:\", s) return s } func un(s string) { fmt.Println(\"leaving:\", s) } func a() { defer un(trace(\"a\")) fmt.Println(\"in a\") } func b() { defer un(trace(\"b\")) fmt.Println(\"in b\") a() } func main() { b() } prints entering: b in b entering: a in a leaving: a leaving: b ","date":"2022-10-04","objectID":"/tips/:5:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Data ","date":"2022-10-04","objectID":"/tips/:6:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Allocation with new Go have two allocation primitives,the built-in function new and make.They do different things and apply to different types. new built-in function that allocates memory, new(T) allocates zeroed storage for a new item of type T and returns its address. it returns a pointer to a newly allocated zero value of type T. make built-in function make(T,args) creates slices,maps and channels only and it returns an initialized(not zeroed) value of type T(not *T) ","date":"2022-10-04","objectID":"/tips/:6:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Constructors and composite literals Sometimes the zero value isnâ€™t good enough and an initializing constructor is necessary, as in this example derived from package os. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f } Thereâ€™s a lot of boiler plate in there. We can simplify it using a composite literal, which is an expression that creates a new instance each time it is evaluated. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := File{fd, name, nil, 0} return \u0026f } Note that, unlike in C, itâ€™s perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns. In fact, taking the address of a composite literal allocates a fresh instance each time it is evaluated, so we can combine these last two lines. return \u0026File{fd, name, nil, 0} The fields of a composite literal are laid out in order and must all be present. However, by labeling the elements explicitly as field:value pairs, the initializers can appear in any order, with the missing ones left as their respective zero values. Thus we could say return \u0026File{fd: fd, name: name} As a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions new(File) and \u0026File{} are equivalent. Composite literals can also be created for arrays, slices, and maps, with the field labels being indices or map keys as appropriate. In these examples, the initializations work regardless of the values of Enone, Eio, and Einval, as long as they are distinct. a := [...]string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} s := []string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} m := map[int]string{Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} ","date":"2022-10-04","objectID":"/tips/:6:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Allocation with make The built-in function make(T, args) serves a purpose different from new(T). It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is nil. For slices, maps, and channels, make initializes the internal data structure and prepares the value for use. For instance, make([]int, 10, 100) allocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array(When making a slice, the capacity can be omitted; see the section on slices for more information.) In contrast,new([]int) returns a pointer to a newly allocated,zeroed slice structure,that is,a pointer to a nil slice value. These examples illustrate the difference between new and make. var p *[]int = new([]int) // allocates slice structure; *p == nil; rarely useful var v []int = make([]int, 100) // the slice v now refers to a new array of 100 ints // Unnecessarily complex: var p *[]int = new([]int) *p = make([]int, 100, 100) // Idiomatic: v := make([]int, 100) Remember that make applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with new or take the address of a variable explicitly. ","date":"2022-10-04","objectID":"/tips/:6:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Arrays Arrays are useful when planning the detailed layout of memory and sometimes can help avoid allocation, but primarily they are a building block for slices, the subject of the next section. To lay the foundation for that topic, here are a few words about arrays. There are major differences between the ways arrays work in Go and C. In Go, Arrays are values. Assigning one array to another copies all the elements. In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it. The size of an array is part of its type. The types [10]int and [20]int are distinct. The value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array. func Sum(a *[3]float64) (sum float64) { for _, v := range *a { sum += v } return } array := [...]float64{7.0, 8.5, 9.1} x := Sum(\u0026array) // Note the explicit address-of operator But even this style isnâ€™t idiomatic Go. Use slices instead. ","date":"2022-10-04","objectID":"/tips/:6:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Slices Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays. Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array. If a function takes a slice argument, changes it makes to the elements of the slice will be visible to the caller, analogous to passing a pointer to the underlying array. A Read function can therefore accept a slice argument rather than a pointer and a count; the length within the slice sets an upper limit of how much data to read. Here is the signature of the Read method of the File type in package os: func (f *File) Read(buf []byte) (n int, err error) The method returns the number of bytes read and an error value, if any. To read into the first 32 bytes of a larger buffer buf, slice (here used as a verb) the buffer. n, err := f.Read(buf[0:32]) Such slicing is common and efficient. In fact, leaving efficiency aside for the moment, the following snippet would also read the first 32 bytes of the buffer. var n int var err error for i := 0; i \u003c 32; i++ { nbytes, e := f.Read(buf[i:i+1]) // Read one byte. n += nbytes if nbytes == 0 || e != nil { err = e break } } The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The capacity of a slice, accessible by the built-in function cap, reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that len and cap are legal when applied to the nil slice, and return 0. func Append(slice,data[] byte) [] byte{ l := len(slice) if l+len(data)\u003ecap(slice){ //reallocate //Allocate double what`s needed,for future growth newSlice :=make([]byte,(l+len(data))*2) //Tye copy function is predeclared and works for any slice type. copy(newSlice,slice) slice = newSlice } slice = slice[0:l+len(data)] copy(slice[l:],data) return slice } We must return the slice afterwards because, although Append can modify the elements of slice, the slice itself (the run-time data structure holding the pointer, length, and capacity) is passed by value. The idea of appending to a slice is so useful itâ€™s captured by the append built-in function. To understand that functionâ€™s design, though, we need a little more information, so weâ€™ll return to it later. ","date":"2022-10-04","objectID":"/tips/:6:5","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Two-dimensional slices Goâ€™s arrays and slices are one-dimensional. To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices, like this: type Transform [3][3]float64 // A 3x3 array, really an array of arrays. type LinesOfText [][]byte // A slice of byte slices. Because slices are variable-length, it is possible to have each inner slice be a different length. That can be a common situation, as in our LinesOfText example: each line has an independent length. text := LinesOfText{ []byte(\"Now is the time\"), []byte(\"for all good gophers\"), []byte(\"to bring some fun to the party.\"), } Sometimes itâ€™s necessary to allocate a 2D slice, a situation that can arise when processing scan lines of pixels, for instance. There are two ways to achieve this. One is to allocate each slice independently; the other is to allocate a single array and point the individual slices into it. Which to use depends on your application. If the slices might grow or shrink, they should be allocated independently to avoid overwriting the next line; if not, it can be more efficient to construct the object with a single allocation. For reference, here are sketches of the two methods. First, a line at a time: // Allocate the top-level slice. picture := make([][]uint8, YSize) // One row per unit of y. // Loop over the rows, allocating the slice for each row. for i := range picture { picture[i] = make([]uint8, XSize) } And now as one allocation, sliced into lines: // Allocate the top-level slice, the same as before. picture := make([][]uint8, YSize) // One row per unit of y. // Allocate one large slice to hold all the pixels. pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8. // Loop over the rows, slicing each row from the front of the remaining pixels slice. for i := range picture { picture[i], pixels = pixels[:XSize], pixels[XSize:] } ","date":"2022-10-04","objectID":"/tips/:6:6","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Maps Maps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value). The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller. Maps can be constructed using the usual composite literal syntax with colon-separated key-value pairs, so itâ€™s easy to build them during initialization. var timeZone = map[string]int{ \"UTC\": 0*60*60, \"EST\": -5*60*60, \"CST\": -6*60*60, \"MST\": -7*60*60, \"PST\": -8*60*60, } Assigning and fetching map values looks syntactically just like doing the same for arrays and slices except that the index doesnâ€™t need to be an integer. offset := timeZone[\"EST\"] An attempt to fetch a map value with a key that is not present in the map will return the zero value for the type of the entries in the map. For instance, if the map contains integers, looking up a non-existent key will return 0. A set can be implemented as a map with value type bool. Set the map entry to true to put the value in the set, and then test it by simple indexing. attended := map[string]bool{ \"Ann\": true, \"Joe\": true, ... } if attended[person] { // will be false if person is not in the map fmt.Println(person, \"was at the meeting\") } Sometimes you need to distinguish a missing entry from a zero value. Is there an entry for â€œUTCâ€ or is that 0 because itâ€™s not in the map at all? You can discriminate with a form of multiple assignment. var seconds int var ok bool seconds,ok = timeZone[tz] For obvious reasons this is called the â€œcomma okâ€ idiom. In this example, if tz is present, seconds will be set appropriately and ok will be true; if not, seconds will be set to zero and ok will be false. Hereâ€™s a function that puts it together with a nice error report: func offset(tz string) int { if seconds, ok := timeZone[tz]; ok { return seconds } log.Println(\"unknown time zone:\", tz) return 0 } To test for presence in the map without worrying about the actual value, you can use the blank identifier (_) in place of the usual variable for the value. _, present := timeZone[tz] To delete a map entry, use the delete built-in function, whose arguments are the map and the key to be deleted. Itâ€™s safe to do this even if the key is already absent from the map. delete(timeZone, \"PDT\") // Now on Standard Time ","date":"2022-10-04","objectID":"/tips/:6:7","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Printing Formatted printing in Go uses a style similar to Câ€™s printf family but is richer and more general. The functions live in the fmt package and have capitalized names: fmt.Printf, fmt.Fprintf, fmt.Sprintf and so on. The string functions (Sprintf etc.) return a string rather than filling in a provided buffer. You donâ€™t need to provide a format string. For each of Printf, Fprintf and Sprintf there is another pair of functions, for instance Print and Println. These functions do not take a format string but instead generate a default format for each argument. The Println versions also insert a blank between arguments and append a newline to the output while the Print versions add blanks only if the operand on neither side is a string. In this example each line produces the same output. fmt.Printf(\"Hello %d\\n\", 23) fmt.Fprint(os.Stdout, \"Hello \", 23, \"\\n\") fmt.Println(\"Hello\", 23) fmt.Println(fmt.Sprint(\"Hello \", 23)) The formatted print functions fmt.Fprint and friends take as a first argument any object that implements the io.Writer interface; the variables os.Stdout and os.Stderr are familiar instances. Here things start to diverge from C. First, the numeric formats such as %d do not take flags for signedness or size; instead, the printing routines use the type of the argument to decide these properties. var x uint64 = 1\u003c\u003c64 - 1 fmt.Printf(\"%d %x; %d %x\\n\", x, x, int64(x), int64(x)) prints: 18446744073709551615 ffffffffffffffff; -1 -1 If you just want the default conversion, such as decimal for integers, you can use the catchall format %v (for â€œvalueâ€); the result is exactly what Print and Println would produce. Moreover, that format can print any value, even arrays, slices, structs, and maps. Here is a print statement for the time zone map defined in the previous section. fmt.Printf(\"%v\\n\", timeZone) // or just fmt.Println(timeZone) which gives output: map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0] For maps, Printf and friends sort the output lexicographically by key. When printing a struct, the modified format %+v annotates the fields of the structure with their names, and for any value the alternate format %#v prints the value in full Go syntax. type T struct { a int b float64 c string } t := \u0026T{ 7, -2.35, \"abc\\tdef\" } fmt.Printf(\"%v\\n\", t) fmt.Printf(\"%+v\\n\", t) fmt.Printf(\"%#v\\n\", t) fmt.Printf(\"%#v\\n\", timeZone) prints: \u0026{7 -2.35 abc def} \u0026{a:7 b:-2.35 c:abc def} \u0026main.T{a:7, b:-2.35, c:\"abc\\tdef\"} map[string]int{\"CST\":-21600, \"EST\":-18000, \"MST\":-25200, \"PST\":-28800, \"UTC\":0} (Note the ampersands.) That quoted string format is also available through %q when applied to a value of type string or []byte. The alternate format %#q will use backquotes instead if possible. (The %q format also applies to integers and runes, producing a single-quoted rune constant.) Also, %x works on strings, byte arrays and byte slices as well as on integers, generating a long hexadecimal string, and with a space in the format (% x) it puts spaces between the bytes. Another handy format is %T, which prints the type of a value. fmt.Printf(\"%T\\n\", timeZone) prints: map[string]int If you want to control the default format for a custom type, all thatâ€™s required is to define a method with the signature String() string on the type. For our simple type T, that might look like this. func (t *T) String() string { return fmt.Sprintf(\"%d/%g/%q\", t.a, t.b, t.c) } fmt.Printf(\"%v\\n\", t) to print in the format 7/-2.35/\"abc\\tdef\" (If you need to print values of type T as well as pointers to T, the receiver for String must be of value type; this example used a pointer because thatâ€™s more efficient and idiomatic for struct types. See the section below on pointers vs. value receivers for more information.) Our String method is able to call Sprintf because the print routines are fully reentrant and can be wrapped this way. There is one important detail to understand about this approach, however: donâ€™t construct a String method by calling Sprintf in a w","date":"2022-10-04","objectID":"/tips/:6:8","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Append Now we have the missing piece we needed to explain the design of the append built-in function. The signature of append is different from our custom Append function above. Schematically, itâ€™s like this: func append(slice []T, elements ...T) []T where T is a placeholder for any given type. You canâ€™t actually write a function in Go where the type T is determined by the caller. Thatâ€™s why append is built in: it needs support from the compiler. What append does is append the elements to the end of the slice and return the result. The result needs to be returned because, as with our hand-written Append, the underlying array may change. This simple example x := []int{1,2,3} x = append(x, 4, 5, 6) fmt.Println(x) prints [1 2 3 4 5 6]. So append works a little like Printf, collecting an arbitrary number of arguments. But what if we wanted to do what our Append does and append a slice to a slice? Easy: use â€¦ at the call site, just as we did in the call to Output above. This snippet produces identical output to the one above. x := []int{1,2,3} y := []int{4,5,6} x = append(x, y...) fmt.Println(x) Without that â€¦, it wouldnâ€™t compile because the types would be wrong; y is not of type int. ","date":"2022-10-04","objectID":"/tips/:6:9","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Initialization Although it doesnâ€™t look superficially very different from initialization in C or C++, initialization in Go is more powerful. Complex structures can be built during initialization and the ordering issues among initialized objects, even among different packages, are handled correctly. ","date":"2022-10-04","objectID":"/tips/:7:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Constants Constants in Go are just thatâ€”constant. They are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. For instance, 1\u003c\u003c3 is a constant expression, while math.Sin(math.Pi/4) is not because the function call to math.Sin needs to happen at run time. In Go, enumerated constants are created using the iota enumerator. Since iota can be part of an expression and expressions can be implicitly repeated, it is easy to build intricate sets of values. type ByteSize float64 const ( _ = iota // ignore first value by assigning to blank identifier KB ByteSize = 1 \u003c\u003c (10 * iota) MB GB TB PB EB ZB YB ) The ability to attach a method such as String to any user-defined type makes it possible for arbitrary values to format themselves automatically for printing. Although youâ€™ll see it most often applied to structs, this technique is also useful for scalar types such as floating-point types like ByteSize. func (b ByteSize) String() string { switch { case b \u003e= YB: return fmt.Sprintf(\"%.2fYB\", b/YB) case b \u003e= ZB: return fmt.Sprintf(\"%.2fZB\", b/ZB) case b \u003e= EB: return fmt.Sprintf(\"%.2fEB\", b/EB) case b \u003e= PB: return fmt.Sprintf(\"%.2fPB\", b/PB) case b \u003e= TB: return fmt.Sprintf(\"%.2fTB\", b/TB) case b \u003e= GB: return fmt.Sprintf(\"%.2fGB\", b/GB) case b \u003e= MB: return fmt.Sprintf(\"%.2fMB\", b/MB) case b \u003e= KB: return fmt.Sprintf(\"%.2fKB\", b/KB) } return fmt.Sprintf(\"%.2fB\", b) } The use here of Sprintf to implement ByteSizeâ€™s String method is safe (avoids recurring indefinitely) not because of a conversion but because it calls Sprintf with %f, which is not a string format: Sprintf will only call the String method when it wants a string, and %f wants a floating-point value. ","date":"2022-10-04","objectID":"/tips/:7:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Variables Variables can be initialized just like constants but the initializer can be a general expression computed at run time. var ( home = os.Getenv(\"HOME\") user = os.Getenv(\"USER\") gopath = os.Getenv(\"GOPATH\") ) ","date":"2022-10-04","objectID":"/tips/:7:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"The init function Finally, each source file can define its own niladic init function to set up whatever state is required. (Actually each file can have multiple init functions.) And finally means finally: init is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized. Besides initializations that cannot be expressed as declarations, a common use of init functions is to verify or repair correctness of the program state before real execution begins. func init() { if user == \"\" { log.Fatal(\"$USER not set\") } if home == \"\" { home = \"/home/\" + user } if gopath == \"\" { gopath = home + \"/go\" } // gopath may be overridden by --gopath flag on command line. flag.StringVar(\u0026gopath, \"gopath\", gopath, \"override default GOPATH\") } ","date":"2022-10-04","objectID":"/tips/:7:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Methods ","date":"2022-10-04","objectID":"/tips/:8:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Pointer vs Values As we saw with ByteSize, methods can be defined for any named type (except a pointer or an interface); the receiver does not have to be a struct. In the discussion of slices above, we wrote an Append function. We can define it as a method on slices instead. To do this, we first declare a named type to which we can bind the method, and then make the receiver for the method a value of that type. type ByteSlice []byte func (slice ByteSlice) Append(data []byte) []byte { l := len(slice) if l+len(data)\u003ecap(slice){ //reallocate //Allocate double what`s needed,for future growth newSlice :=make([]byte,(l+len(data))*2) //Tye copy function is predeclared and works for any slice type. copy(newSlice,slice) slice = newSlice } slice = slice[0:l+len(data)] copy(slice[l:],data) return slice } This still requires the method to return the updated slice.We can eliminate that clumsiness by redefining the method to take a pointer to a ByteSlice as its receiver,so the method can overwrite the caller`s slice. func (p *ByteSlice) Append(data []byte) { slice := *p l := len(slice) if l+len(data)\u003ecap(slice){ //reallocate //Allocate double what`s needed,for future growth newSlice :=make([]byte,(l+len(data))*2) //Tye copy function is predeclared and works for any slice type. copy(newSlice,slice) slice = newSlice } slice = slice[0:l+len(data)] copy(slice[l:],data) *p = slice } In fact,we can de even better. If we modify our function so it look like a standard Write method, like this, func (p *ByteSlice) Write(data []byte) (n int, err error) { slice := *p l := len(slice) if l+len(data)\u003ecap(slice){ //reallocate //Allocate double what`s needed,for future growth newSlice :=make([]byte,(l+len(data))*2) //Tye copy function is predeclared and works for any slice type. copy(newSlice,slice) slice = newSlice } slice = slice[0:l+len(data)] copy(slice[l:],data) *p = slice return len(data), nil } then the type *ByteSlice satisfies the standard interface io.Writer, which is handy. For instance, we can print into one. var b ByteSlice fmt.Fprintf(\u0026b, \"This hour has %d days\\n\", 7) We pass the address of a ByteSlice because only *ByteSlice satisfies io.Writer. The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers. This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (\u0026b).Write for us. By the way, the idea of using Write on a slice of bytes is central to the implementation of bytes.Buffer. ","date":"2022-10-04","objectID":"/tips/:8:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interfaces and other types Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here. Weâ€™ve seen a couple of simple examples already; custom printers can be implemented by a String method while Fprintf can generate output to anything with a Write method. Interfaces with only one or two methods are common in Go code, and are usually given a name derived from the method, such as io.Writer for something that implements Write. A type can implement multiple interfaces. For instance, a collection can be sorted by the routines in package sort if it implements sort.Interface, which contains Len(), Less(i, j int) bool, and Swap(i, j int), and it could also have a custom formatter. In this contrived example Sequence satisfies both. type Sequence []int //Methods required by sort.Interface func (s Sequence) Len() int { return len(s) } func (s Sequence) Less(i, j int) bool { return s[i] \u003c s[j] } func (s Sequence) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s Sequence) Copy() Sequence { copy: make(Sequence, 0, len(s)) return append(copy, s...) } func (s Sequence) String() string { s = s.Copy() sort.Sort(s) srt := \"[\" for i, elem := range s { // Loop is O(NÂ²); will fix that in next example. if i \u003e 0 { str += \" \" } str += fmt.Sprint(elem) } return str + \"]\" } ","date":"2022-10-04","objectID":"/tips/:9:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Conversions The String method of Sequence is recreating the work that Sprint already dose for slices.(it also has complexity O(N2), which is poor.) We can share the effort (and also speed it up) if we convert the Sequence to a plain []int before calling Spring. func (s Sequence) String() string{ s = s.Copy() sort.Sort(s) return fmt.Sprint([]int(s)) } This method is another example of the conversion technique for calling Sprintf safely from a String method. Because the two types (Sequence and []int) are the same if we ignore the type name, itâ€™s legal to convert between them. The conversion doesnâ€™t create a new value, it just temporarily acts as though the existing value has a new type. (There are other legal conversions, such as from integer to floating point, that do create a new value.) Itâ€™s an idiom in Go programs to convert the type of an expression to access a different set of methods. As an example, we could use the existing type sort.IntSlice to reduce the entire example to this: type Sequence []int // Method for printing - sorts the elements before printing func (s Sequence) String() string { s =s.Copy() sort.IntSlice(s).Sort() return fmt.Sprint([]int(s)) } Now, instead of having Sequence implement multiple interfaces (sorting and printing), weâ€™re using the ability of a data item to be converted to multiple types (Sequence, sort.IntSlice and []int), each of which does some part of the job. Thatâ€™s more unusual in practice but can be effective. ","date":"2022-10-04","objectID":"/tips/:9:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interface conversions and type assertions Type switches are a form of conversion: they take an interface and, for each case in the switch, in a sense convert it to the type of that case. Hereâ€™s a simplified version of how the code under fmt.Printf turns a value into a string using a type switch. If itâ€™s already a string, we want the actual string value held by the interface, while if it has a String method we want the result of calling the method. type Stringer interface { String() string } var value interface{} // Value provided by caller. switch str := value.(type) { case string: return str case Stringer: return str.String() } The first case finds a concrete value; the second converts the interface into another interface. Itâ€™s perfectly fine to mix types this way. What if thereâ€™s only one type we care about? If we know the value holds a string and we just want to extract it? A one-case type switch would do, but so would a type assertion. A type assertion takes an interface value and extracts from it a value of the specified explicit type. The syntax borrows from the clause opening a type switch, but with an explicit type rather than the type keyword: value.(typeName) and the result is a new value with the static type typeName. That type must either be the concrete type held by the interface, or a second interface type that the value can be converted to. To extract the string we know is in the value, we could write: But if it turns out that the value does not contain a string, the program will crash with a run-time error. To guard against that, use the â€œcomma, okâ€ idiom to test, safely, whether the value is a string str, ok := value.(string) if ok { fmt.Printf(\"string value is: %q\\n\", str) } else { fmt.Printf(\"value is not a string\\n\") } If the type assertion fails, str will still exist and be of type string, but it will have the zero value, an empty string. As an illustration of the capability, hereâ€™s an if-else statement thatâ€™s equivalent to the type switch that opened this section. if str, ok := value.(string); ok { return str } else if str, ok := value.(Stringer); ok { return str.String() } ","date":"2022-10-04","objectID":"/tips/:9:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Generality If a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface. It also avoids the need to repeat the documentation on every instance of a common method. In such cases, the constructor should return an interface value rather than the implementing type. As an example, in the hash libraries both crc32.NewIEEE and adler32.New return the interface type hash.Hash32. Substituting the CRC-32 algorithm for Adler-32 in a Go program requires only changing the constructor call; the rest of the code is unaffected by the change of algorithm. A similar approach allows the streaming cipher algorithms in the various crypto packages to be separated from the block ciphers they chain together. The Block interface in the crypto/cipher package specifies the behavior of a block cipher, which provides encryption of a single block of data. Then, by analogy with the bufio package, cipher packages that implement this interface can be used to construct streaming ciphers, represented by the Stream interface, without knowing the details of the block encryption. The crypto/cipher interfaces look like this: type Block interface { BlockSize() int Encrypt(dst, src []byte) Decrypt(dst, src []byte) } type Stream interface { XORKeyStream(dst, src []byte) } Hereâ€™s the definition of the counter mode (CTR) stream, which turns a block cipher into a streaming cipher; notice that the block cipherâ€™s details are abstracted away: // NewCTR returns a Stream that encrypts/decrypts using the given Block in // counter mode. The length of iv must be the same as the Block's block size. func NewCTR(block Block, iv []byte) Stream NewCTR applies not just to one specific encryption algorithm and data source but to any implementation of the Block interface and any Stream. Because they return interface values, replacing CTR encryption with other encryption modes is a localized change. The constructor calls must be edited, but because the surrounding code must treat the result only as a Stream, it wonâ€™t notice the difference. ","date":"2022-10-04","objectID":"/tips/:9:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interfaces and methods Since almost anything can have methods attached, almost anything can satisfy an interface. One illustrative example is in the http package, which defines the Handler interface. Any object that implements Handler can serve HTTP requests. type Handler interface { ServeHTTP(ResponseWriter, *Request) } ResponseWriter is itself an interface that provides access to the methods needed to return the response to the client. Those methods include the standard Write method, so an http.ResponseWriter can be used wherever an io.Writer can be used. Request is a struct containing a parsed representation of the request from the client. For brevity, letâ€™s ignore POSTs and assume HTTP requests are always GETs; that simplification does not affect the way the handlers are set up. Hereâ€™s a trivial implementation of a handler to count the number of times the page is visited. // Simple counter server. type Counter struct { n int } func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) { ctr.n++ fmt.Fprintf(w, \"counter = %d\\n\", ctr.n) } (Keeping with our theme, note how Fprintf can print to an http.ResponseWriter.) In a real server, access to ctr.n would need protection from concurrent access. See the sync and atomic packages for suggestions. For reference, hereâ€™s how to attach such a server to a node on the URL tree. import \"net/http\" ... ctr := new(Counter) http.Handle(\"/counter\", ctr) But why make Counter a struct? An integer is all thatâ€™s needed. (The receiver needs to be a pointer so the increment is visible to the caller.) // Simpler counter server. type Counter int func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) { *ctr++ fmt.Fprintf(w, \"counter = %d\\n\", *ctr) } What if your program has some internal state that needs to be notified that a page has been visited? Tie a channel to the web page. // A channel that sends a notification on each visit. // (Probably want the channel to be buffered.) type Chan chan *http.Request func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) { ch \u003c- req fmt.Fprint(w, \"notification sent\") } Finally, letâ€™s say we wanted to present on /args the arguments used when invoking the server binary. Itâ€™s easy to write a function to print the arguments. func ArgServer() { fmt.Println(os.Args) } How do we turn that into an HTTP server? We could make ArgServer a method of some type whose value we ignore, but thereâ€™s a cleaner way. Since we can define a method for any type except pointers and interfaces, we can write a method for a function. The http package contains this code: // The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers. If f is a function // with the appropriate signature, HandlerFunc(f) is a // Handler object that calls f. type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP calls f(w, req). func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) { f(w, req) } HandlerFunc is a type with a method, ServeHTTP, so values of that type can serve HTTP requests. Look at the implementation of the method: the receiver is a function, f, and the method calls f. That may seem odd but itâ€™s not that different from, say, the receiver being a channel and the method sending on the channel. To make ArgServer into an HTTP server, we first modify it to have the right signature. // Argument server. func ArgServer(w http.ResponseWriter, req *http.Request) { fmt.Fprintln(w, os.Args) } ArgServer now has same signature as HandlerFunc, so it can be converted to that type to access its methods, just as we converted Sequence to IntSlice to access IntSlice.Sort. The code to set it up is concise: http.Handle(\"/args\", http.HandlerFunc(ArgServer)) When someone visits the page /args, the handler installed at that page has value ArgServer and type HandlerFunc. The HTTP server will invoke the method ServeHTTP of that type, with ArgServer as the receiver, which will in turn call ArgServer (via the invocation f(w, req) i","date":"2022-10-04","objectID":"/tips/:9:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"The blank identifier Weâ€™ve mentioned the blank identifier a couple of times now, in the context of for range loops and maps. The blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. Itâ€™s a bit like writing to the Unix /dev/null file: it represents a write-only value to be used as a place-holder where a variable is needed but the actual value is irrelevant. It has uses beyond those weâ€™ve seen already. ","date":"2022-10-04","objectID":"/tips/:10:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"The blank identifier in multiple assignment If an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and makes it clear that the value is to be discarded. For instance, when calling a function that returns a value and an error, but only the error is important, use the blank identifier to discard the irrelevant value. if _, err := os.Stat(path); os.IsNotExist(err) { fmt.Printf(\"%s does not exist\\n\", path) } Occasionally youâ€™ll see code that discards the error value in order to ignore the error; this is terrible practice. Always check error returns; theyâ€™re provided for a reason. // Bad! This code will crash if path does not exist. fi, _ := os.Stat(path) if fi.IsDir() { fmt.Printf(\"%s is a directory\\n\", path) } ","date":"2022-10-04","objectID":"/tips/:10:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Unused imports and variables It is an error to import a package or to declare a variable without using it. Unused imports bloat the program and slow compilation, while a variable that is initialized but not used is at least a wasted computation and perhaps indicative of a larger bug. When a program is under active development, however, unused imports and variables often arise and it can be annoying to delete them just to have the compilation proceed, only to have them be needed again later. The blank identifier provides a workaround. This half-written program has two unused imports (fmt and io) and an unused variable (fd), so it will not compile, but it would be nice to see if the code so far is correct. package main import ( \"fmt\" \"io\" \"log\" \"os\" ) func main() { fd, err := os.Open(\"test.go\") if err != nil { log.Fatal(err) } // TODO: use fd. } To silence complaints about the unused imports, use a blank identifier to refer to a symbol from the imported package. Similarly, assigning the unused variable fd to the blank identifier will silence the unused variable error. This version of the program does compile. package main import ( \"fmt\" \"io\" \"log\" \"os\" ) var _ = fmt.Printf // For debugging; delete when done. var _ io.Reader // For debugging; delete when done. func main() { fd, err := os.Open(\"test.go\") if err != nil { log.Fatal(err) } // TODO: use fd. _ = fd } By convention, the global declarations to silence import errors should come right after the imports and be commented, both to make them easy to find and as a reminder to clean things up later. ","date":"2022-10-04","objectID":"/tips/:10:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Import for side effect An unused import like fmt or io in the previous example should eventually be used or removed: blank assignments identify code as a work in progress. But sometimes it is useful to import a package only for its side effects, without any explicit use. For example, during its init function, the net/http/pprof package registers HTTP handlers that provide debugging information. It has an exported API, but most clients need only the handler registration and access the data through a web page. To import the package only for its side effects, rename the package to the blank identifier: import _ \"net/http/pprof\" This form of import makes clear that the package is being imported for its side effects, because there is no other possible use of the package: in this file, it doesnâ€™t have a name. (If it did, and we didnâ€™t use that name, the compiler would reject the program.) ","date":"2022-10-04","objectID":"/tips/:10:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Interface checks As we saw in the discussion of interfaces above, a type need not declare explicitly that it implements an interface. Instead, a type implements the interface just by implementing the interfaceâ€™s methods. In practice, most interface conversions are static and therefore checked at compile time. For example, passing an *os.File to a function expecting an io.Reader will not compile unless *os.File implements the io.Reader interface. Some interface checks do happen at run-time, though. One instance is in the encoding/json package, which defines a Marshaler interface. When the JSON encoder receives a value that implements that interface, the encoder invokes the valueâ€™s marshaling method to convert it to JSON instead of doing the standard conversion. The encoder checks this property at run time with a type assertion like: m, ok := val.(json.Marshaler) If itâ€™s necessary only to ask whether a type implements an interface, without actually using the interface itself, perhaps as part of an error check, use the blank identifier to ignore the type-asserted value: if _, ok := val.(json.Marshaler); ok { fmt.Printf(\"value %v of type %T implements json.Marshaler\\n\", val, val) } One place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface. If a typeâ€”for example, json.RawMessageâ€”needs a custom JSON representation, it should implement json.Marshaler, but there are no static conversions that would cause the compiler to verify this automatically. If the type inadvertently fails to satisfy the interface, the JSON encoder will still work, but will not use the custom implementation. To guarantee that the implementation is correct, a global declaration using the blank identifier can be used in the package: var _ json.Marshaler = (*RawMessage)(nil) In this declaration, the assignment involving a conversion of a *RawMessage to a Marshaler requires that *RawMessage implements Marshaler, and that property will be checked at compile time. Should the json.Marshaler interface change, this package will no longer compile and we will be on notice that it needs to be updated. The appearance of the blank identifier in this construct indicates that the declaration exists only for the type checking, not to create a variable. Donâ€™t do this for every type that satisfies an interface, though. By convention, such declarations are only used when there are no static conversions already present in the code, which is a rare event. ","date":"2022-10-04","objectID":"/tips/:10:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Concurrency Concurrent programming is a large topic and there is space only for some Go-specific highlights here. Concurrent programming in many environments is made difficult by the subtleties required to implement correct access to shared variables. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan: Do not communicate by sharing memory; instead, share memory by communicating. This approach can be taken too far. Reference counts may be best done by putting a mutex around an integer variable, for instance. But as a high-level approach, using channels to control access makes it easier to write clear, correct programs. One way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, thereâ€™s still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Goâ€™s approach to concurrency originates in Hoareâ€™s Communicating Sequential Processes (CSP), it can also be seen as a type-safe generalization of Unix pipes. ","date":"2022-10-04","objectID":"/tips/:11:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Goroutines Theyâ€™re called goroutines because the existing termsâ€”threads, coroutines, processes, and so onâ€”convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required. Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and management. Prefix a function or method call with the go keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. (The effect is similar to the Unix shellâ€™s \u0026 notation for running a command in the background.) go list.Sort() // run list.Sort concurrently; don't wait for it. A function literal can be handy in a goroutine invocation. func Announce(message string, delay time.Duration) { go func() { time.Sleep(delay) fmt.Println(message) }() // Note the parentheses - must call the function. } In Go, function literals are closures: the implementation makes sure the variables referred to by the function survive as long as they are active. These examples arenâ€™t too practical because the functions have no way of signaling completion. For that, we need channels. ","date":"2022-10-04","objectID":"/tips/:11:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Channels Like maps, channels are allocated with make, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel. ci := make(chan int) // unbuffered channel of integers cj := make(chan int, 0) // unbuffered channel of integers cs := make(chan *os.File, 100) // buffered channel of pointers to Files Unbuffered channels combine communicationâ€”the exchange of a valueâ€”with synchronizationâ€”guaranteeing that two calculations (goroutines) are in a known state. There are lots of nice idioms using channels. Hereâ€™s one to get us started. In the previous section we launched a sort in the background. A channel can allow the launching goroutine to wait for the sort to complete. c := make(chan int) // Allocate a channel. // Start the sort in a goroutine; when it completes, signal on the channel. go func() { list.Sort() c \u003c- 1 // Send a signal; value does not matter. }() doSomethingForAWhile() \u003c-c // Wait for sort to finish; discard sent value. Receivers always block until there is data to receive. If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until the value has been copied to the buffer; if the buffer is full, this means waiting until some receiver has retrieved a value. A buffered channel can be used like a semaphore, for instance to limit throughput. In this example, incoming requests are passed to handle, which sends a value into the channel, processes the request, and then receives a value from the channel to ready the â€œsemaphoreâ€ for the next consumer. The capacity of the channel buffer limits the number of simultaneous calls to process. var sem = make(chan int, MaxOutstanding) func handle(r *Request) { sem \u003c- 1 // Wait for active queue to drain. process(r) // May take a long time. \u003c-sem // Done; enable next request to run. } func Serve(queue chan *Request) { for { req := \u003c-queue go handle(req) // Don't wait for handle to finish. } } This design has a problem, though: Serve creates a new goroutine for every incoming request, even though only MaxOutstanding of them can run at any moment. As a result, the program can consume unlimited resources if the requests come in too fast. We can address that deficiency by changing Serve to gate the creation of the goroutines. Hereâ€™s an obvious solution, but beware it has a bug weâ€™ll fix subsequently: func Serve(queue chan *Request) { for req := range queue { sem \u003c- 1 go func() { process(req) // Buggy; see explanation below. \u003c-sem }() } } The bug is that in a Go for loop, the loop variable is reused for each iteration, so the req variable is shared across all goroutines. Thatâ€™s not what we want. We need to make sure that req is unique for each goroutine. Hereâ€™s one way to do that, passing the value of req as an argument to the closure in the goroutine: func Serve(queue chan *Request) { for req := range queue { sem \u003c- 1 go func(req *Request) { process(req) \u003c-sem }(req) } } Compare this version with the previous to see the difference in how the closure is declared and run. Another solution is just to create a new variable with the same name, as in this example: func Serve(queue chan *Request) { for req := range queue { req := req // Create new instance of req for the goroutine. sem \u003c- 1 go func() { process(req) \u003c-sem }() } } but itâ€™s legal and idiomatic in Go to do this. You get a fresh version of the variable with the same name, deliberately shadowing the loop variable locally but unique to each goroutine. Going back to the general problem of writing the server, another approach that manages resources well is to start a fixed number of handle goroutines all reading from the request channel. The number of goroutines limits the number of simultaneous calls to process. This Serve function also accepts a channel on which it will be told to exit; ","date":"2022-10-04","objectID":"/tips/:11:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Channels of channels One of the most important properties of Go is that a channel is a first-class value that can be allocated and passed around like any other. A common use of this property is to implement safe, parallel demultiplexing. In the example in the previous section, handle was an idealized handler for a request but we didnâ€™t define the type it was handling. If that type includes a channel on which to reply, each client can provide its own path for the answer. Hereâ€™s a schematic definition of type Request. type Request struct { args []int f func([]int) int resultChan chan int } The client provides a function and its arguments, as well as a channel inside the request object on which to receive the answer. func sum(a []int) (s int) { for _, v := range a { s += v } return } request := \u0026Request{[]int{3, 4, 5}, sum, make(chan int)} // Send request clientRequests \u003c- request // Wait for response. fmt.Printf(\"answer: %d\\n\", \u003c-request.resultChan) On the server side, the handler function is the only thing that changes. Thereâ€™s clearly a lot more to do to make it realistic, but this code is a framework for a rate-limited, parallel, non-blocking RPC system, and thereâ€™s not a mutex in sight. ","date":"2022-10-04","objectID":"/tips/:11:3","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Parallelization Another application of these ideas is to parallelize a calculation across multiple CPU cores. If the calculation can be broken into separate pieces that can execute independently, it can be parallelized, with a channel to signal when each piece completes. Letâ€™s say we have an expensive operation to perform on a vector of items, and that the value of the operation on each item is independent, as in this idealized example. type Vector []float64 // Apply the operation to v[i], v[i+1] ... up to v[n-1]. func (v Vector) DoSome(i, n int, u Vector, c chan int) { for ; i \u003c n; i++ { v[i] += u.Op(v[i]) } c \u003c- 1 // signal that this piece is done } We launch the pieces independently in a loop, one per CPU. They can complete in any order but it doesnâ€™t matter; we just count the completion signals by draining the channel after launching all the goroutines. const numCPU = 4 // number of CPU cores func (v Vector) DoAll(u Vector) { c := make(chan int, numCPU) // Buffering optional but sensible. for i := 0; i \u003c numCPU; i++ { go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c) } // Drain the channel. for i := 0; i \u003c numCPU; i++ { \u003c-c // wait for one task to complete } // All done. } Rather than create a constant value for numCPU, we can ask the runtime what value is appropriate. The function runtime.NumCPU returns the number of hardware CPU cores in the machine, so we could write var numCPU = runtime.NumCPU() There is also a function runtime.GOMAXPROCS, which reports (or sets) the user-specified number of cores that a Go program can have running simultaneously. It defaults to the value of runtime.NumCPU but can be overridden by setting the similarly named shell environment variable or by calling the function with a positive number. Calling it with zero just queries the value. Therefore if we want to honor the userâ€™s resource request, we should write var numCPU = runtime.GOMAXPROCS(0) Be sure not to confuse the ideas of concurrencyâ€”structuring a program as independently executing componentsâ€”and parallelismâ€”executing calculations in parallel for efficiency on multiple CPUs. Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Goâ€™s model. For a discussion of the distinction, see the talk cited in this blog post. ","date":"2022-10-04","objectID":"/tips/:11:4","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"A leaky buffer The tools of concurrent programming can even make non-concurrent ideas easier to express. Hereâ€™s an example abstracted from an RPC package. The client goroutine loops receiving data from some source, perhaps a network. To avoid allocating and freeing buffers, it keeps a free list, and uses a buffered channel to represent it. If the channel is empty, a new buffer gets allocated. Once the message buffer is ready, itâ€™s sent to the server on serverChan. var freeList = make(chan *Buffer, 100) var serverChan = make(chan *Buffer) func client() { for { var b *Buffer // Grab a buffer if available; allocate if not. select { case b = \u003c-freeList: // Got one; nothing more to do. default: // None free, so allocate a new one. b = new(Buffer) } load(b) // Read next message from the net. serverChan \u003c- b // Send to server. } } The server loop receives each message from the client, processes it, and returns the buffer to the free list. func server() { for { b := \u003c-serverChan // Wait for work. process(b) // Reuse buffer if there's room. select { case freeList \u003c- b: // Buffer on free list; nothing more to do. default: // Free list full, just carry on. } } } The client attempts to retrieve a buffer from freeList; if none is available, it allocates a fresh one. The serverâ€™s send to freeList puts b back on the free list unless the list is full, in which case the buffer is dropped on the floor to be reclaimed by the garbage collector. (The default clauses in the select statements execute when no other case is ready, meaning that the selects never block.) This implementation builds a leaky bucket free list in just a few lines, relying on the buffered channel and the garbage collector for bookkeeping. ","date":"2022-10-04","objectID":"/tips/:11:5","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Errors Library routines must often return some sort of error indication to the caller. As mentioned earlier, Goâ€™s multivalue return makes it easy to return a detailed error description alongside the normal return value. It is good style to use this feature to provide detailed error information. For example, as weâ€™ll see, os.Open doesnâ€™t just return a nil pointer on failure, it also returns an error value that describes what went wrong. By convention, errors have type error, a simple built-in interface. type error interface { Error() string } A library writer is free to implement this interface with a richer model under the covers, making it possible not only to see the error but also to provide some context. As mentioned, alongside the usual *os.File return value, os.Open also returns an error value. If the file is opened successfully, the error will be nil, but when there is a problem, it will hold an os.PathError: // PathError records an error and the operation and // file path that caused it. type PathError struct { Op string // \"open\", \"unlink\", etc. Path string // The associated file. Err error // Returned by the system call. } func (e *PathError) Error() string { return e.Op + \" \" + e.Path + \": \" + e.Err.Error() } PathErrorâ€™s Error generates a string like this: open /etc/passwx: no such file or directory Such an error, which includes the problematic file name, the operation, and the operating system error it triggered, is useful even if printed far from the call that caused it; it is much more informative than the plain â€œno such file or directoryâ€. When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. For example, in package image, the string representation for a decoding error due to an unknown format is â€œimage: unknown formatâ€. Callers that care about the precise error details can use a type switch or a type assertion to look for specific errors and extract details. For PathErrors this might include examining the internal Err field for recoverable failures. for try := 0; try \u003c 2; try++ { file, err = os.Create(filename) if err == nil { return } if e, ok := err.(*os.PathError); ok \u0026\u0026 e.Err == syscall.ENOSPC { deleteTempFiles() // Recover some space. continue } return } The second if statement here is another type assertion. If it fails, ok will be false, and e will be nil. If it succeeds, ok will be true, which means the error was of type *os.PathError, and then so is e, which we can examine for more information about the error. ","date":"2022-10-04","objectID":"/tips/:12:0","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Panic The usual way to report an error to a caller is to return an error as an extra return value. The canonical Read method is a well-known instance; it returns a byte count and an error. But what if the error is unrecoverable? Sometimes the program simply cannot continue. For this purpose, there is a built-in function panic that in effect creates a run-time error that will stop the program (but see the next section). The function takes a single argument of arbitrary typeâ€”often a stringâ€”to be printed as the program dies. Itâ€™s also a way to indicate that something impossible has happened, such as exiting an infinite loop. // A toy implementation of cube root using Newton's method. func CubeRoot(x float64) float64 { z := x/3 // Arbitrary initial value for i := 0; i \u003c 1e6; i++ { prevz := z z -= (z*z*z-x) / (3*z*z) if veryClose(z, prevz) { return z } } // A million iterations has not converged; something is wrong. panic(fmt.Sprintf(\"CubeRoot(%g) did not converge\", x)) } This is only an example but real library functions should avoid panic. If the problem can be masked or worked around, itâ€™s always better to let things continue to run rather than taking down the whole program. One possible counterexample is during initialization: if the library truly cannot set itself up, it might be reasonable to panic, so to speak. var user = os.Getenv(\"USER\") func init() { if user == \"\" { panic(\"no value for $USER\") } } ","date":"2022-10-04","objectID":"/tips/:12:1","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"Recover When panic is called, including implicitly for run-time errors such as indexing a slice out of bounds or failing a type assertion, it immediately stops execution of the current function and begins unwinding the stack of the goroutine, running any deferred functions along the way. If that unwinding reaches the top of the goroutineâ€™s stack, the program dies. However, it is possible to use the built-in function recover to regain control of the goroutine and resume normal execution. A call to recover stops the unwinding and returns the argument passed to panic. Because the only code that runs while unwinding is inside deferred functions, recover is only useful inside deferred functions. One application of recover is to shut down a failing goroutine inside a server without killing the other executing goroutines. func server(workChan \u003c-chan *Work) { for work := range workChan { go safelyDo(work) } } func safelyDo(work *Work) { defer func() { if err := recover(); err != nil { log.Println(\"work failed:\", err) } }() do(work) } In this example, if do(work) panics, the result will be logged and the goroutine will exit cleanly without disturbing the others. Thereâ€™s no need to do anything else in the deferred closure; calling recover handles the condition completely. Because recover always returns nil unless called directly from a deferred function, deferred code can call library routines that themselves use panic and recover without failing. As an example, the deferred function in safelyDo might call a logging function before calling recover, and that logging code would run unaffected by the panicking state. With our recovery pattern in place, the do function (and anything it calls) can get out of any bad situation cleanly by calling panic. We can use that idea to simplify error handling in complex software. Letâ€™s look at an idealized version of a regexp package, which reports parsing errors by calling panic with a local error type. Hereâ€™s the definition of Error, an error method, and the Compile function. // Error is the type of a parse error; it satisfies the error interface. type Error string func (e Error) Error() string { return string(e) } // error is a method of *Regexp that reports parsing errors by // panicking with an Error. func (regexp *Regexp) error(err string) { panic(Error(err)) } // Compile returns a parsed representation of the regular expression. func Compile(str string) (regexp *Regexp, err error) { regexp = new(Regexp) // doParse will panic if there is a parse error. defer func() { if e := recover(); e != nil { regexp = nil // Clear return value. err = e.(Error) // Will re-panic if not a parse error. } }() return regexp.doParse(str), nil } If doParse panics, the recovery block will set the return value to nilâ€”deferred functions can modify named return values. It will then check, in the assignment to err, that the problem was a parse error by asserting that it has the local type Error. If it does not, the type assertion will fail, causing a run-time error that continues the stack unwinding as though nothing had interrupted it. This check means that if something unexpected happens, such as an index out of bounds, the code will fail even though we are using panic and recover to handle parse errors. With error handling in place, the error method (because itâ€™s a method bound to a type, itâ€™s fine, even natural, for it to have the same name as the builtin error type) makes it easy to report parse errors without worrying about unwinding the parse stack by hand: if pos == 0 { re.error(\"'*' illegal at start of expression\") } By the way, this re-panic idiom changes the panic value if an actual error occurs. However, both the original and new failures will be presented in the crash report, so the root cause of the problem will still be visible. Thus this simple re-panic approach is usually sufficientâ€”itâ€™s a crash after allâ€”but if you want to display only the original value, you can write a little more code to filter unexpe","date":"2022-10-04","objectID":"/tips/:12:2","tags":["golang"],"title":"golang tips","uri":"/tips/"},{"categories":["golang"],"content":"golangåå°„, æ¥å£å€¼ï¼ŒåŸºæœ¬ä½¿ç”¨","date":"2022-10-04","objectID":"/reflect/","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"ä¼šæƒ³èµ·æ¥å†™è¿™ç¯‡åšå®¢æ˜¯å› ä¸ºï¼Œæœ€è¿‘æ€»æ˜¯åœ¨æƒ³æ€ä¹ˆè®©golangçš„ä»£ç å†™çš„æ›´åŠ¨æ€ä¸€ç‚¹ã€‚å†åŠ ä¸Šæœ€è¿‘åœ¨å…³æ³¨æ¶æ„ä¸Šé¢çš„äº‹æƒ…ï¼Œæ— æ„ä¸­è®©æˆ‘çœ‹åˆ°äº†gonetè¿™ä¸ªæ¡†æ¶ä¸­å¯¹golangåå°„çš„ä½¿ç”¨ã€‚è®©æˆ‘ä¸€æ—¶é—´æœ‰ç§æƒŠè®¶çš„æ„Ÿè§‰ï¼ˆè¿™ä¸œè¥¿è¿˜èƒ½è¿™ä¹ˆç”¨ï¼ŸğŸ˜‚ï¼‰, äºæ˜¯æ„Ÿè§‰è¿˜æ˜¯å…ˆæŠŠè¿™ä¸Šé¢çš„åªæ˜¯æ¶è¡¥ä¸€ä¸‹ï¼Œä¹Ÿè®¸å¯¹åé¢å†™æ¶æ„æœ‰å¥½å¤„ä¹Ÿä¸ä¸€å®šå‘¢ã€‚ ","date":"2022-10-04","objectID":"/reflect/:0:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"å¼•è¨€ åœ¨è®¨è®ºåå°„ä¹‹å‰ï¼Œå…ˆè¯´ä¸€ä¸‹åå°„çš„åˆ©å¼Šã€‚åå°„å¯ä»¥ç”¨æ¥åšéå¸¸çµæ´»çš„å·¥ä½œï¼Œä½†æ˜¯åå°„çš„ä½¿ç”¨å¾€å¾€å’Œä»£ç çš„å¯è¯»æ€§èµ°å‘å¯¹ç«‹é¢ã€‚è¿™å”¤èµ·äº†æˆ‘åœ¨ç¬¬ä¸€å®¶å…¬å¸çš„è®°å¿†ã€‚ ç¬¬ä¸€å®¶å…¬å¸å¯¹äºæ¸¸æˆçš„ç†è§£éå¸¸é€å½»ï¼Œä¸»ç¨‹çš„æ°´å¹³éå¸¸çš„é«˜ï¼Œå¯¹æ¸¸æˆä¸­å„ä¸ªå…ƒç´ çš„æŠ½è±¡éå¸¸é€å½»ã€‚ä»–å¯¹ä»£ç çš„ä¼˜åŒ–ï¼Œä»¥åŠç®€æ´æ€§ä¹Ÿæœ‰ä¸€å®šçš„åæ‰§ã€‚ é¡¹ç›®è§£è€¦éå¸¸å½»åº•ï¼Œè¿™åº”è¯¥æ˜¯ä¸€ä¸ªå¯¹é¡¹ç›®é‡Œæ‰€æœ‰äººéƒ½éå¸¸å‹å¥½çš„æ¡†æ¶ã€‚ä½†æ˜¯å¯¹æˆ‘ä¸æ˜¯ï¼Œæˆ‘ç»å¸¸è¢«æ¨¡å—é‡Œé¢çš„å„ç§æŠ½è±¡å’Œç»§æ‰¿å¼„å¾—çƒ¦ä¸èƒœçƒ¦ã€‚ å› ä¸ºluaä¸åƒjavaé‚£æ ·æœ‰éå¸¸æ ‡å‡†çš„é¢å‘å¯¹è±¡æ¦‚å¿µï¼Œluaæ˜¯å‡½æ•°å¼è¯­è¨€ï¼Œluaçš„tableæ•°æ®ç»“æ„å¯ä»¥ç”¨æ¥å®ç°å¾ˆå¤šæ•°æ®ç»“æ„ï¼Œé“¾è¡¨ï¼Œé˜Ÿåˆ—ï¼Œç”šè‡³ç”¨å®ƒå®ç°ä¸€å¥—é¢å‘å¯¹è±¡ã€‚ä½†æ˜¯ï¼Œä¸æ˜¯è¯­è¨€åŸç”Ÿæ”¯æŒçš„ä¸œè¥¿å°±æ€»æ˜¯æœ‰åˆ«æ‰­çš„åœ°æ–¹ã€‚é¡¹ç›®æ²¡æœ‰ä»»ä½•æ–‡æ¡£ï¼Œæˆ‘åœ¨å®Œå…¨ä¸äº†è§£æ¡†æ¶çš„æƒ…å†µä¸‹å¼€å§‹äº†å·¥ä½œã€‚å°è±¡æœ€æ·±çš„æ˜¯ï¼Œæˆ‘ç»å¸¸æ‹…å¿ƒæˆ‘ç”¨çš„å¯¹è±¡é‡Œé¢æ˜¯æ²¡æœ‰é‚£ä¸ªå­—æ®µçš„ï¼Œäºæ˜¯é€¼è¿«ç€æˆ‘å»ä»”ç»†æ¢³ç†ä¸€éä»£ç çš„æ¥é¾™å»è„‰ã€‚è¿™ç§ä½“éªŒè®©æˆ‘æ„Ÿè§‰éå¸¸ç³Ÿç³•ã€‚åŠ ä¸Šæ²¡æœ‰ç±»å‹æ£€æŸ¥ï¼Œæ²¡æœ‰debugè°ƒè¯•å™¨ï¼ˆæŠŠæˆ‘å–œæ¬¢ç”¨è°ƒè¯•å™¨çš„æ¯›ç—…ç»™çº æ­£è¿‡æ¥äº†ï¼Œç°åœ¨æˆ‘åªä¹ æƒ¯æ‰“logğŸ˜‚ï¼‰ è€Œåå°„çš„ä½¿ç”¨ï¼Œå°±ä¼šå¸¦æ¥å¯è¯»æ€§çš„é—®é¢˜ã€‚åº”ç”¨åå°„çš„æœ€ä¸»è¦ç›®çš„æ˜¯ä¸ºäº†æé«˜ä»£ç çš„çµæ´»æ€§ï¼Œç®€æ´æ€§ï¼Œå¤ç”¨ç‡ã€‚ä½†æ˜¯åå°„ä¼šæ¨¡ç³Šç¨‹åºå†…éƒ¨é€»è¾‘ï¼Œè¿˜ä¼šæœ‰æ€§èƒ½é—®é¢˜ã€‚åå°„ä»£ç ä¼šæ¯”æ™®é€šçš„ä»£ç è¦æ›´åŠ éš¾è¯»ã€‚æ‰€ä»¥åå°„çš„ä½¿ç”¨åº”è¯¥æ…é‡ã€‚åå°„æ˜¯ä¸€æŠŠåŒåˆƒå‰‘ã€‚ ","date":"2022-10-04","objectID":"/reflect/:1:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"åŸºæœ¬æ¦‚å¿µ golang çš„reflectåŒ…æä¾›äº†åå°„æ”¯æŒï¼Œgolangä¸­æœ‰ä¸¤ä¸ªé‡è¦ç±»å‹Typeå’ŒValue,ä»»æ„çš„æ¥å£å€¼éƒ½ç”±reflect.Type å’Œ reflect.Valueç»„æˆ ","date":"2022-10-04","objectID":"/reflect/:2:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"æ¥å£å€¼ ç®€å•è¯´æ¥å£å€¼å°±æ˜¯ç”±reflect.Type å’Œ reflect.Valueç»„æˆçš„å€¼. Typeéƒ¨åˆ†ä¿å­˜äº†ä»–çš„åŠ¨æ€ç±»å‹æè¿°ç¬¦ï¼Œvalueéƒ¨åˆ†ä¿å­˜äº†ä»–çš„åŠ¨æ€å€¼ã€‚ æ¥å£å€¼çš„ä½œç”¨æ˜¯ç”¨æ¥æè¿°ã€‚åå°„çš„åŸºæœ¬ç†å¿µå°±æ˜¯è®©ç¨‹åºèƒ½å¤Ÿè‡ªæˆ‘æè¿°ï¼Œé‚£ä¹ˆæ¥å£å€¼çš„å®šä¹‰å°±æ˜¯ä¸ºäº†èƒ½å¤Ÿè®©ç¨‹åºè‡ªæˆ‘æè¿°ã€‚ åŠ¨æ€ç±»å‹æè¿°ç¬¦ å¯¹äºgoè¯­è¨€è¿™ç§é™æ€ç±»å‹è¯­è¨€ï¼Œç±»å‹åªæ˜¯ç¼–è¯‘æœŸçš„æ¦‚å¿µã€‚ç±»å‹ä¸æ˜¯å€¼ï¼Œç±»å‹ä¿¡æ¯è¢«ç§°ä¸ºç±»å‹æè¿°ç¬¦ã€‚æ‰€ä»¥æ¥å£å€¼ä¸­çš„ç±»å‹éƒ¨åˆ†ä»£è¡¨ç±»å‹çš„æè¿°ç¬¦ çœ‹ä¸‹é¢çš„ä»£ç  var w io.Writer //wæ˜¯ä¸€ä¸ªio.Writerç±»å‹çš„ç©ºæ¥å£å€¼ w = os.Stdout //å°†*os.Fileç±»å‹çš„å€¼èµ‹å€¼ç»™å˜é‡w w = new(bytes.Buffer) // å°†*bytes.Bufferç±»å‹çš„å€¼èµ‹å€¼ç»™å˜é‡w w = nil // å°†nilèµ‹å€¼ç»™æ¥å£å€¼ ç”±æµ…å…¥æ·± å…ˆçœ‹ç¬¬ä¸€è¡Œä»£ç  var w io.Writer å®šä¹‰äº†ä¸€ä¸ªç©ºçš„æ¥å£å€¼, è¿™é‡Œè¡¨æ˜wåªèƒ½æ¥æ”¶å®ç°äº†io.Writerçš„æ¥å£çš„æ¥å£å€¼ã€‚ä½†æ˜¯å¯¹äºwæœ¬èº«æ¥è¯´ä»–çš„å†…éƒ¨æ˜¯è¿™æ ·çš„ã€‚è¿™é‡Œè¡¨æ˜ï¼Œä»–æ²¡æœ‰æè¿°ä»»ä½•å…·ä½“ç±»å‹çš„å€¼ golangä¸­åªæœ‰å€¼ä¼ é€’ï¼Œè€Œæ¥å£å€¼æ˜¯ç”¨æ¥æè¿°å­˜å‚¨åœ¨æ¥å£å€¼ç”¨å€¼çš„ç±»å‹æè¿°ç¬¦å’Œå®ƒçš„çœŸå®å€¼çš„ å†çœ‹ç¬¬äºŒè¡Œï¼Œæˆ‘ä»¬ç»™æ¥å£å€¼ä¸€ä¸ªå€¼ w = os.Stdout æ­¤æ—¶ wçš„å†…éƒ¨æ¥å£æ˜¯è¿™æ ·çš„ å‰é¢è¯´è¿‡æ¥å£å€¼çš„ä½œç”¨æ˜¯ç”¨æ¥æè¿°ï¼Œè¿™é‡Œæ¥å£å€¼ä¼ è¾¾çš„ä¿¡æ¯æ˜¯ï¼Œæˆ‘æè¿°äº†ä¸€ä¸ª*os.Fileç±»å‹çš„å€¼, åˆ°è¿™é‡Œçš„æ—¶å€™ï¼Œæ˜¯ä¸æ˜¯ä¸€ä¸‹å°±æ¸…æ™°äº†ã€‚ ç¬¬ä¸‰è¡Œ w = new(bytes.Buffer) è¿™é‡Œwè¢«ç”¨æ¥æè¿°*bytes.Bufferè¿”å›çš„å€¼ ç¬¬å››è¡Œ å†å°†wå†…éƒ¨åˆ¶ç©ºï¼Œè®©å®ƒä¸åœ¨æè¿°ä»»ä½•å€¼ w = nil æ¥å£å€¼å¯ä»¥ç”¨==å’Œ!=æ¥æ¯”è¾ƒï¼Œä½†æ˜¯åªæœ‰å½“æ¥å£å€¼éƒ½ä¸ºnilæˆ–è€…å®ƒä»¬çš„åŠ¨æ€ç±»å‹ç›¸åŒä¸”åŠ¨æ€å€¼ä¹Ÿå¯ä»¥ç”¨==å»åˆ¤æ–­ç›¸ç­‰ã€‚ å¦‚æœä¸¤ä¸ªæ¥å£å€¼åŠ¨æ€ç±»å‹ç›¸åŒï¼Œä½†æ˜¯åŠ¨æ€ç±»å‹ä¸å¯æ¯”è¾ƒï¼ˆåˆ‡ç‰‡å°±å±äºè¿™ç§ï¼‰æ˜¯ä¼šå¯¼è‡´panicçš„ï¼ˆæ³¨æ„ï¼Œå› ä¸ºåå°„çš„ä»£ç æ²¡æœ‰ç±»å‹æ£€æŸ¥ï¼Œæ‰€ä»¥å¯ä»¥è¢«ç¼–è¯‘é€šè¿‡ï¼Œåªæœ‰è¿è¡Œçš„æ—¶å€™æ‰ä¼šæŠ¥é”™, æ‰€ä»¥è¦å°¤ä¸ºæ³¨æ„ï¼‰ var x interface{} = []int{1, 2, 3} fmt.Println(x == x) // panic: comparing uncomparable type []int ä¸€ä¸ªåŒ…å«nilæŒ‡é’ˆçš„æ¥å£ä¸æ˜¯nilæ¥å£ ä¸€ä¸ªä¸åŒ…å«ä»»ä½•å€¼çš„nilæ¥å£å€¼ï¼Œå’Œä¸€ä¸ªåˆšå¥½åŒ…å«nilæŒ‡é’ˆçš„æ¥å£å€¼æ˜¯ä¸åŒçš„ ç©ºçš„æ¥å£å€¼æ˜¯è¿˜æ²¡æœ‰è¢«èµ‹å€¼çš„æ¥å£å€¼ï¼ˆgolangä¸­ï¼Œéƒ½æ˜¯å€¼ï¼Œç©ºæ¥å£ä¹Ÿæ˜¯å€¼ï¼‰ï¼Œæ²¡æœ‰è¢«èµ‹å€¼çš„æ¥å£é•¿è¿™æ · è€ŒåŒ…å«äº†nilæŒ‡é’ˆçš„æ¥å£å€¼é•¿è¿™æ · ç©ºæ¥å£å€¼æ˜¯æŒ‡å®ƒå†…éƒ¨çš„type å’Œ valueéƒ½ä¸ºnilï¼Œè¿™æ˜¯ w == nil æ—¶æ‰å›è¿”å›true ","date":"2022-10-04","objectID":"/reflect/:2:1","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"åå°„çš„ç±»å‹å¯¹è±¡ reflect.Type reflectåŒ…æä¾›reflect.TypeOf()è·å–ä»»æ„å€¼çš„ç±»å‹å¯¹è±¡(reflect.Type), é€šè¿‡ç±»å‹å¯¹è±¡ï¼Œæˆ‘ä»¬å°±å¯ä»¥çŸ¥é“ä»»æ„å€¼çš„ç±»å‹ä¿¡æ¯ ä½†æ˜¯ä½ å¯èƒ½ä¼šç–‘æƒ‘ï¼Œä¸ºä»€ä¹ˆæˆ‘ç›´æ¥ä¼ åŸå€¼å°±å¯ä»¥ï¼Œè€Œä¸éœ€è¦ä¼ æ¥å£å€¼ã€‚å› ä¸ºreflect.TypeOf()çš„å‡½æ•°ç­¾åæ˜¯è¿™æ ·çš„reflect.TypeOf(interface{})åœ¨å‚æ•°è¢«ä¼ å…¥çš„æ—¶å€™ï¼Œä¼šè‡ªåŠ¨ç”Ÿæˆæ¥å£å€¼ package main import ( \"fmt\" \"reflect\" ) func main() { var a int typeOfA := reflect.TypeOf(a) //è·å–ç±»å‹å˜é‡ fmt.Println(typeOfA.Name(), typeOfA.Kind()) //è·å–ç±»å‹å(int)ï¼Œå¯ç±»å‹ç§ç±»(int) } int int Name(),Kind()æ˜¯ç±»å‹å¯¹è±¡çš„æˆå‘˜å‡½æ•°åˆ†åˆ«ç”¨æ¥è·å–ç±»å‹åï¼Œå’Œç±»å‹çš„ç§ç±» çº¦å®š æ–‡ç« é‡Œreflect.TypeOf()å’Œreflect.ValueOf()éƒ½æ˜¯reflect.TypeOf(interface{})å’Œreflect.ValueOf(interface{})çš„ç®€å†™ ","date":"2022-10-04","objectID":"/reflect/:2:2","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"åå°„çš„ç±»å‹ type å’Œ ç§ç±» Kind TypeæŒ‡çš„æ˜¯åŸç”Ÿgo æ•°æ®ç±»å‹å’Œä½¿ç”¨typeå…³é”®å­—å®šä¹‰çš„ç±»å‹çš„é›†åˆ,è€ŒKindæŒ‡çš„æ˜¯ç§ç±»è¦æ¯”Typeæ›´åŠ èŒƒåŒ–ã€‚åœ¨éœ€è¦åŒºåˆ†å¤§å“ç§çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šç”¨åˆ°Kindã€‚ Kindçš„å®šä¹‰ Kindåœ¨reflectåŒ…çš„å®šä¹‰ä¸­æœ‰å¦‚ä¸‹ type Kind uint const ( Invalid Kind = iota // éæ³•ç±»å‹ Bool // å¸ƒå°”å‹ Int // æœ‰ç¬¦å·æ•´å‹ Int8 // æœ‰ç¬¦å·8ä½æ•´å‹ Int16 // æœ‰ç¬¦å·16ä½æ•´å‹ Int32 // æœ‰ç¬¦å·32ä½æ•´å‹ Int64 // æœ‰ç¬¦å·64ä½æ•´å‹ Uint // æ— ç¬¦å·æ•´å‹ Uint8 // æ— ç¬¦å·8ä½æ•´å‹ Uint16 // æ— ç¬¦å·16ä½æ•´å‹ Uint32 // æ— ç¬¦å·32ä½æ•´å‹ Uint64 // æ— ç¬¦å·64ä½æ•´å‹ Uintptr // æŒ‡é’ˆ Float32 // å•ç²¾åº¦æµ®ç‚¹æ•° Float64 // åŒç²¾åº¦æµ®ç‚¹æ•° Complex64 // 64ä½å¤æ•°ç±»å‹ Complex128 // 128ä½å¤æ•°ç±»å‹ Array // æ•°ç»„ Chan // é€šé“ Func // å‡½æ•° Interface // æ¥å£ Map // æ˜ å°„ Ptr // æŒ‡é’ˆ Slice // åˆ‡ç‰‡ String // å­—ç¬¦ä¸² Struct // ç»“æ„ä½“ UnsafePointer // åº•å±‚æŒ‡é’ˆ ) Map, Slice, Chanå±äºå¼•ç”¨ç±»å‹ï¼Œä½†æ˜¯å±äºç‹¬ç«‹çš„ç§ç±». type A struct{} æ•°æ®Struct ç§ç±», type Enum int æ˜¯Emumç±»å‹ æ˜¯intç§ç±» ","date":"2022-10-04","objectID":"/reflect/:2:3","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"ä»ç±»å‹å¯¹è±¡ä¸­è·å–ç±»å‹åç§°å’Œç§ç±» reflect.Typeå¯¹è±¡çš„Name()å¯ä»¥ç”¨æ¥è·å–ç±»å‹åç§°ï¼Œè€ŒKind()å°±å¯ä»¥å¸®æˆ‘ä»¬è·å–ç§ç±»ã€‚ package main import ( \"fmt\" \"reflect\" ) type Enum int const ( Zero Enum = 0 ) func main() { // å£°æ˜ä¸€ä¸ªç©ºç»“æ„ä½“ type cat struct { } // è·å–ç»“æ„ä½“å®ä¾‹çš„åå°„ç±»å‹å¯¹è±¡ typeOfCat := reflect.TypeOf(cat{}) // æ˜¾ç¤ºåå°„ç±»å‹å¯¹è±¡çš„åç§°å’Œç§ç±» fmt.Println(typeOfCat.Name(), typeOfCat.Kind()) // è·å–Zeroå¸¸é‡çš„åå°„ç±»å‹å¯¹è±¡ typeOfA := reflect.TypeOf(Zero) // æ˜¾ç¤ºåå°„ç±»å‹å¯¹è±¡çš„åç§°å’Œç§ç±» fmt.Println(typeOfA.Name(), typeOfA.Kind()) } cat struct Enum int ","date":"2022-10-04","objectID":"/reflect/:3:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"ä½¿ç”¨åå°„è·å–ç»“æ„ä½“æˆå‘˜çš„ç±»å‹ å¦‚æœç±»å‹æ˜¯ç»“æ„ä½“ï¼Œåœ¨ä½¿ç”¨reflect.TypeOf()è·å–åå°„å¯¹è±¡ç±»å‹ä¿¡æ¯åï¼Œå¯ä»¥é€šè¿‡ NumField()å’ŒField()æ–¹æ³•è·å¾—ç»“æ„ä½“æˆå‘˜çš„è¯¦ç»†ä¿¡æ¯ã€‚ æ–¹æ³• è¯´æ˜ Field(i int) StructField æ ¹æ®ç´¢å¼•è¿”å›ç´¢å¼•å¯¹åº”çš„ç»“æ„ä½“å­—æ®µçš„ä¿¡æ¯ï¼Œå½“å€¼ä¸æ˜¯ç»“æ„ä½“æˆ–ç´¢å¼•è¶…ç•Œæ—¶å‘ç”Ÿå®•æœº NumField() int è¿”å›ç»“æ„ä½“æˆå‘˜å­—æ®µæ•°é‡ï¼Œå½“ç±»å‹ä¸æ˜¯ç»“æ„ä½“æˆ–ç´¢å¼•è¶…ç•Œæ—¶å‘ç”Ÿå®•æœº FieldByName(name string) (StructField, bool) æ ¹æ®ç»™å®šå­—ç¬¦ä¸²è¿”å›å­—ç¬¦ä¸²å¯¹åº”çš„ç»“æ„ä½“å­—æ®µçš„ä¿¡æ¯ï¼Œæ²¡æœ‰æ‰¾åˆ°æ—¶ bool è¿”å› falseï¼Œå½“ç±»å‹ä¸æ˜¯ç»“æ„ä½“æˆ–ç´¢å¼•è¶…ç•Œæ—¶å‘ç”Ÿå®•æœº FieldByIndex(index []int) StructField å¤šå±‚æˆå‘˜è®¿é—®æ—¶ï¼Œæ ¹æ® []int æä¾›çš„æ¯ä¸ªç»“æ„ä½“çš„å­—æ®µç´¢å¼•ï¼Œè¿”å›å­—æ®µçš„ä¿¡æ¯ï¼Œæ²¡æœ‰æ‰¾åˆ°æ—¶è¿”å›é›¶å€¼ã€‚å½“ç±»å‹ä¸æ˜¯ç»“æ„ä½“æˆ–ç´¢å¼•è¶…ç•Œæ—¶å‘ç”Ÿå®•æœº FieldByNameFunc(match func(string) bool) (StructField,bool) æ ¹æ®åŒ¹é…å‡½æ•°åŒ¹é…éœ€è¦çš„å­—æ®µï¼Œå½“å€¼ä¸æ˜¯ç»“æ„ä½“æˆ–ç´¢å¼•è¶…ç•Œæ—¶å‘ç”Ÿå®•æœº ç»“æ„ä½“å­—æ®µç±»å‹ reflect.Typeçš„Field()ä¼šè¿”å›StructFieldç»“æ„ã€‚è¿™ä¸ªç»“æ„æè¿°äº†ç»“æ„ä½“æˆå‘˜çš„ä¿¡æ¯ type StructField struct { Name string // å­—æ®µå PkgPath string // å­—æ®µè·¯å¾„ Type Type // å­—æ®µåå°„ç±»å‹å¯¹è±¡ Tag StructTag // å­—æ®µçš„ç»“æ„ä½“æ ‡ç­¾ Offset uintptr // å­—æ®µåœ¨ç»“æ„ä½“ä¸­çš„ç›¸å¯¹åç§» Index []int // Type.FieldByIndexä¸­çš„è¿”å›çš„ç´¢å¼•å€¼ Anonymous bool // æ˜¯å¦ä¸ºåŒ¿åå­—æ®µ } è·å–æˆå‘˜ä¿¡æ¯ é€šè¿‡reflect.Typeå¯¹è±¡çš„FieldByName()æ–¹æ³•å¯ä»¥ç›´æ¥æŸ¥æ‰¾æ¥å£ä½“ä¸­æŒ‡å®šåç§°çš„å­—æ®µã€‚é€šè¿‡NumField()å¯ä»¥è·å–ç»“æ„ä½“ä¸­çš„å­—æ®µæ•°é‡ï¼Œè€Œé€šè¿‡Field()åˆ™å¯ä»¥è·å–å¯¹åº”ç´¢å¼•çš„å­—æ®µä¿¡æ¯ã€‚ package main import ( \"fmt\" \"reflect\" ) func main() { // å£°æ˜ä¸€ä¸ªç©ºç»“æ„ä½“ type cat struct { Name string // å¸¦æœ‰ç»“æ„ä½“tagçš„å­—æ®µ Type int `json:\"type\" id:\"100\"` } // åˆ›å»ºcatçš„å®ä¾‹ ins := cat{Name: \"mimi\", Type: 1} // è·å–ç»“æ„ä½“å®ä¾‹çš„åå°„ç±»å‹å¯¹è±¡ typeOfCat := reflect.TypeOf(ins) // éå†ç»“æ„ä½“æ‰€æœ‰æˆå‘˜ for i := 0; i \u003c typeOfCat.NumField(); i++ { // è·å–æ¯ä¸ªæˆå‘˜çš„ç»“æ„ä½“å­—æ®µç±»å‹ fieldType := typeOfCat.Field(i) // è¾“å‡ºæˆå‘˜åå’Œtag fmt.Printf(\"name: %v tag: '%v'\\n\", fieldType.Name, fieldType.Tag) } // é€šè¿‡å­—æ®µå, æ‰¾åˆ°å­—æ®µç±»å‹ä¿¡æ¯ if catType, ok := typeOfCat.FieldByName(\"Type\"); ok { // ä»tagä¸­å–å‡ºéœ€è¦çš„tag fmt.Println(catType.Tag.Get(\"json\"), catType.Tag.Get(\"id\")) } } name: Name tag: '' name: Type tag: 'json:\"type\" id:\"100\"' type 100 ç»“æ„ä½“æ ‡ç­¾ ä½ å¯èƒ½æ³¨æ„åˆ°äº†ä¸Šé¢æœ‰è¿™æ ·çš„å†™æ³• type cat struct { Type int `json:\"type\" id:\"100\"` } å¯¹äºType int åé¢è·Ÿçš„é‚£ä¸€ä¸²é”®å€¼å¯¹ï¼ŒgolangæŠŠå®ƒç§°ä½œç»“æ„ä½“æ ‡ç­¾ã€‚ ç»“æ„ä½“æ ‡ç­¾æ˜¯å¯¹ç»“æ„ä½“å­—æ®µä¿¡æ¯çš„é¢å¤–è¡¥å……ï¼Œå¾ˆå¤šORMç³»ç»Ÿéƒ½ä¼šç”¨åˆ°è¿™æ ·çš„æ ‡ç­¾ ç»“æ„ä½“æ ‡ç­¾çš„æ ¼å¼ `key1:\"value1\" key2:\"value2\"` ç»“æ„ä½“å¯ä»¥ç”±ä¸€ä¸ªæˆ–å¤šä¸ªé”®å€¼å¯¹ç»„æˆï¼›é”®ä¸å€¼ä¹‹é—´ç”¨å†’å·åˆ†å‰²ï¼Œå€¼ç”¨åŒå¼•å·æ‹¬èµ·æ¥ï¼Œé”®å€¼å¯¹ä¸é”®å€¼å¯¹ä¹‹é—´ä½¿ç”¨ç©ºæ ¼åˆ†å‰²ã€‚ è·å–ç»“æ„ä½“æ ‡ç­¾ä¸­çš„å€¼ reflect.Type.Tag çš„ Get(key string)stringå¯ä»¥æ ¹æ®ç»“æ„ä½“æ ‡ç­¾ä¸­çš„é”®è·å–å¯¹åº”çš„å€¼, Lookup(key string)(value string, ok bool)å¯ä»¥æ ¹æ®ç»“æ„ä½“æ ‡ç­¾ä¸­çš„é”®ï¼ŒæŸ¥è¯¢å€¼æ˜¯å¦å­˜åœ¨ ","date":"2022-10-04","objectID":"/reflect/:4:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"æŒ‡é’ˆä¸æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´  reflect.Elem()ä¸“ç”¨äºè·å–æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ çš„ç±»å‹, å› ä¸ºå½“æˆ‘ä»¬å¯¹ä¸€ä¸ªæŒ‡é’ˆä½¿ç”¨reflect.TypeOfæ—¶ï¼Œæˆ‘ä»¬åªèƒ½å¾—åˆ°è¿™ä¸ªæŒ‡é’ˆçš„æ¥å£å€¼çš„ç±»å‹ä¿¡æ¯(ä¹Ÿå°±æ˜¯interfaceå€¼çš„typeéƒ¨åˆ†), æ‰€ä»¥å¦‚æœæƒ³è¦è¿›ä¸€æ­¥è·å–å®ƒæŒ‡å‘çš„æŒ‡çš„ç±»å‹ä¿¡æ¯ï¼Œæˆ‘ä»¬å¿…é¡»å¾—å…ˆå°†æŒ‡é’ˆè§£å¼•ç”¨ã€‚è€Œreflect.Elem()å¯ä»¥å¸®æˆ‘ä»¬å®Œæˆè¿™ä¸€æ­¥çš„æ“ä½œã€‚ package main import ( \"fmt\" \"reflect\" ) func main() { // å£°æ˜ä¸€ä¸ªç©ºç»“æ„ä½“ type cat struct { } // åˆ›å»ºcatçš„å®ä¾‹ ins := \u0026cat{} // è·å–ç»“æ„ä½“å®ä¾‹çš„åå°„ç±»å‹å¯¹è±¡ typeOfCat := reflect.TypeOf(ins) // æ˜¾ç¤ºåå°„ç±»å‹å¯¹è±¡çš„åç§°å’Œç§ç±» fmt.Printf(\"name:'%v' kind:'%v'\\n\", typeOfCat.Name(), typeOfCat.Kind()) // å–ç±»å‹çš„å…ƒç´  typeOfCat = typeOfCat.Elem() // æ˜¾ç¤ºåå°„ç±»å‹å¯¹è±¡çš„åç§°å’Œç§ç±» fmt.Printf(\"element name: '%v', element kind: '%v'\\n\", typeOfCat.Name(), typeOfCat.Kind()) } name:'' kind:'ptr' element name: 'cat', element kind: 'struct' ","date":"2022-10-04","objectID":"/reflect/:5:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"ä½¿ç”¨åå°„å€¼å¯¹è±¡åŒ…è£…ä»»æ„å€¼ åå°„ä¸ä»…å¯ä»¥è·å–å€¼çš„ç±»å‹ä¿¡æ¯ï¼Œè¿˜èƒ½åŠ¨æ€è·å–æˆ–è®¾ç½®å˜é‡çš„å€¼ã€‚Goè¯­è¨€ä¸­ä½¿ç”¨reflect.Valueå¯ä»¥é€šè¿‡åŒ…è£…å’Œæ‹†åŒ…ç›¸äº’è½¬åŒ–ã€‚ åŒ…è£…ä¸æ‹†åŒ… æ‰€è°“åŒ…è£… å°±æ˜¯å°†åŸå€¼è½¬æ¢æˆreflect.Valueç±»å‹çš„å€¼ã€‚è€Œæ‹†åŒ…å°±æ˜¯å°†reflect.Valueç±»å‹çš„å€¼è½¬åŒ–æˆåŸå€¼ã€‚ åœ¨åŒ…è£…çš„æ—¶å€™ï¼ŒåŸå€¼è¢«è½¬æ¢æˆreflect.Value, è€Œreflect.Valueä¸­å°è£…äº†åŸå€¼çš„å„ç§ä¿¡æ¯ï¼Œå°±åƒé£Ÿå“åŠ å·¥å®Œååœ¨å¤–é¢å¥—ä¸€å±‚åŒ…è£…æ¥å‘Šè¯‰é¡¾å®¢æˆåˆ†ä¿¡æ¯ä¸€æ ·ï¼Œæ‰€ä»¥è¿™ä¸€æ­¥æˆ‘ä»¬é€šå¸¸å«åšåŒ…è£… æ‹†åŒ…ï¼Œå°±åƒé¡¾å®¢æ‹†æ‰é£Ÿå“åŒ…è£…ï¼Œè§åˆ°çœŸæ­£çš„é£Ÿç‰©ï¼Œæ‰€ä»¥ç”±reflect.Valueè½¬åŒ–æˆåŸå€¼è¿™ä¸€æ­¥å«æ‹†åŒ…ã€‚ value := refelct.ValueOf(rawValue) reflect.ValueOfè¿”å›reflect.Valueç±»å‹ï¼ŒåŒ…å«æœ‰rawValueçš„å€¼ä¿¡æ¯ã€‚ ","date":"2022-10-04","objectID":"/reflect/:6:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"ä»reflect.Valueç±»å‹çš„å¯¹è±¡ä¸­è·å–è¢«åŒ…è£…çš„å€¼çš„æ–¹æ³• æ–¹æ³•å è¯´ æ˜ Interface() interface {} å°†å€¼ä»¥ interface{} ç±»å‹è¿”å›ï¼Œå¯ä»¥é€šè¿‡ç±»å‹æ–­è¨€è½¬æ¢ä¸ºæŒ‡å®šç±»å‹ Int() int64 å°†å€¼ä»¥ int ç±»å‹è¿”å›ï¼Œæ‰€æœ‰æœ‰ç¬¦å·æ•´å‹å‡å¯ä»¥æ­¤æ–¹å¼è¿”å› Uint() uint64 å°†å€¼ä»¥ uint ç±»å‹è¿”å›ï¼Œæ‰€æœ‰æ— ç¬¦å·æ•´å‹å‡å¯ä»¥æ­¤æ–¹å¼è¿”å› Float() float64 å°†å€¼ä»¥åŒç²¾åº¦ï¼ˆfloat64ï¼‰ç±»å‹è¿”å›ï¼Œæ‰€æœ‰æµ®ç‚¹æ•°ï¼ˆfloat32ã€float64ï¼‰å‡å¯ä»¥æ­¤æ–¹å¼è¿”å› Bool() bool å°†å€¼ä»¥ bool ç±»å‹è¿”å› Bytes() []bytes å°†å€¼ä»¥å­—èŠ‚æ•°ç»„ []bytes ç±»å‹è¿”å› String() string å°†å€¼ä»¥å­—ç¬¦ä¸²ç±»å‹è¿”å› package main import ( \"fmt\" \"reflect\" ) func main() { // å£°æ˜æ•´å‹å˜é‡aå¹¶èµ‹åˆå€¼ var a int = 1024 // è·å–å˜é‡açš„åå°„å€¼å¯¹è±¡ valueOfA := reflect.ValueOf(a) // è·å–interface{}ç±»å‹çš„å€¼, é€šè¿‡ç±»å‹æ–­è¨€è½¬æ¢ var getA int = valueOfA.Interface().(int) // è·å–64ä½çš„å€¼, å¼ºåˆ¶ç±»å‹è½¬æ¢ä¸ºintç±»å‹ var getA2 int = int(valueOfA.Int()) fmt.Println(getA, getA2) } 1024 1024 ","date":"2022-10-04","objectID":"/reflect/:7:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"ä½¿ç”¨IsNil() å’Œ IsValid() â€“ åˆ¤æ–­åå°„å€¼çš„ç©ºå’Œæœ‰æ•ˆæ€§ åå°„å¯¹è±¡(reflect.Value)æä¾›äº†é›¶å€¼å’Œç©ºçš„åˆ¤æ–­ æ–¹ æ³• è¯´ æ˜ IsNil() bool è¿”å›å€¼æ˜¯å¦ä¸º nilã€‚å¦‚æœå€¼ç±»å‹ä¸æ˜¯é€šé“ï¼ˆchannelï¼‰ã€å‡½æ•°ã€æ¥å£ã€mapã€æŒ‡é’ˆæˆ– åˆ‡ç‰‡æ—¶å‘ç”Ÿ panicï¼Œç±»ä¼¼äºè¯­è¨€å±‚çš„v== nilæ“ä½œ IsValid() bool åˆ¤æ–­å€¼æ˜¯å¦æœ‰æ•ˆã€‚ å½“å€¼æœ¬èº«éæ³•æ—¶ï¼Œè¿”å› falseï¼Œä¾‹å¦‚ reflect Valueä¸åŒ…å«ä»»ä½•å€¼ï¼Œå€¼ä¸º nil ç­‰ã€‚ package main import ( \"fmt\" \"reflect\" ) func main() { // *intçš„ç©ºæŒ‡é’ˆ var a *int fmt.Println(\"var a *int:\", reflect.ValueOf(a).IsNil()) // nilå€¼ fmt.Println(\"nil:\", reflect.ValueOf(nil).IsValid()) // *intç±»å‹çš„ç©ºæŒ‡é’ˆ fmt.Println(\"(*int)(nil):\", reflect.ValueOf((*int)(nil)).Elem().IsValid()) // å®ä¾‹åŒ–ä¸€ä¸ªç»“æ„ä½“ s := struct{}{} // å°è¯•ä»ç»“æ„ä½“ä¸­æŸ¥æ‰¾ä¸€ä¸ªä¸å­˜åœ¨çš„å­—æ®µ fmt.Println(\"ä¸å­˜åœ¨çš„ç»“æ„ä½“æˆå‘˜:\", reflect.ValueOf(s).FieldByName(\"\").IsValid()) // å°è¯•ä»ç»“æ„ä½“ä¸­æŸ¥æ‰¾ä¸€ä¸ªä¸å­˜åœ¨çš„æ–¹æ³• fmt.Println(\"ä¸å­˜åœ¨çš„ç»“æ„ä½“æ–¹æ³•:\", reflect.ValueOf(s).MethodByName(\"\").IsValid()) // å®ä¾‹åŒ–ä¸€ä¸ªmap m := map[int]int{} // å°è¯•ä»mapä¸­æŸ¥æ‰¾ä¸€ä¸ªä¸å­˜åœ¨çš„é”® fmt.Println(\"ä¸å­˜åœ¨çš„é”®ï¼š\", reflect.ValueOf(m).MapIndex(reflect.ValueOf(3)).IsValid()) } var a *int: true nil: false (*int)(nil): false ä¸å­˜åœ¨çš„ç»“æ„ä½“æˆå‘˜: false ä¸å­˜åœ¨çš„ç»“æ„ä½“æ–¹æ³•: false ä¸å­˜åœ¨çš„é”®ï¼š false ","date":"2022-10-04","objectID":"/reflect/:8:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"ä½¿ç”¨åå°„ä¿®æ”¹å˜é‡çš„å€¼ ä½¿ç”¨reflect.Valueå¯¹åŒ…è£…çš„å€¼è¿›è¡Œä¿®æ”¹çš„æ—¶å€™ï¼Œå¿…é¡»å…ˆéµå¾ªä¸€äº›è§„åˆ™ï¼Œå¦åˆ™æœ‰å¯èƒ½ä¼šå¯¼è‡´ç¨‹åºå®•æœºã€‚ ","date":"2022-10-04","objectID":"/reflect/:9:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"åŸåˆ™ä¸€ï¼šå¯è¢«å¯»å€ å…ˆè¯´ä¸€è¯´ä»€ä¹ˆæ˜¯å¯è¢«å¯»å€¼ã€‚å…ˆä¸Šä»£ç  x := 2 // value type variable? a := reflect.ValueOf(2) // 2 int ä¸å¯å¯»å€ b := reflect.ValueOf(x) // 2 int ä¸å¯å¯»å€ c := reflect.ValueOf(\u0026x) // \u0026x *int ä¸å¯å¯»å€ d := c.Elem() // 2 int yes (x) å¯è¢«å¯»å€ ä¸Šé¢a b c éƒ½ä¸å¯è¢«å¯»å€ã€‚å› ä¸ºå€¼åœ¨è¢«ä¼ å…¥reflect.ValueOf()çš„æ—¶å€™ï¼Œä¼šè¢«è‡ªåŠ¨æ‹·è´ä¸€ä»½å‡ºæ¥ï¼Œè¿™æ—¶ a b c éƒ½æŒ‡å‘çš„æ˜¯åŸå€¼çš„å‰¯æœ¬ã€‚ è€Œåå°„çš„ç›®çš„æ˜¯å¯¹åŸå€¼æè¿°ï¼Œå¯¹åŸå€¼ä¿®æ”¹ã€‚å¦‚æœå…è®¸ä¿®æ”¹å‰¯æœ¬ï¼Œè¿èƒŒäº†åå°„çš„åˆè¡·ï¼Œæ‰€ä»¥å¦‚æœä¹‹é—´å°†å€¼ä¼ å…¥ï¼Œæ— æ³•ä¿®æ”¹åŸå€¼ã€‚å› ä¸ºa b c è¿™ä¸‰ä¸ªå˜é‡å·²ç»æ²¡æœ‰åŠæ³•æ‰¾åˆ°åŸå€¼äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬è¯´ä¸å¯è¢«å¯»å€ã€‚ å†çœ‹d, cä¸­å­˜å‚¨çš„æ˜¯xçš„æŒ‡é’ˆï¼Œè€Œä¹‹å‰è¯´è¿‡Elem()å‡½æ•°å¯ä»¥è·å–åˆ°æŒ‡é’ˆæŒ‡å‘å€¼ï¼Œæ‰€ä»¥è¿™é‡Œdæè¿°çš„å°±æ˜¯x,ç”±äºå¯è¢«å¯»å€ï¼Œæ‰€ä»¥ä»–å¯ä»¥è¢«ä¿®æ”¹ã€‚ ç®€å•çš„è¯´æ‰€æœ‰reflec.Valueéƒ½æ˜¯ä¸å¯å–åœ°å€çš„ï¼Œåªæœ‰å½“reflect.Valueæ˜¯æŒ‡é’ˆå¹¶ä¸”è°ƒç”¨äº† Elem()çš„æ—¶å€™æ‰èƒ½å–åœ°å€ï¼Œæ¯”å¦‚ reflect.ValueOf(\u0026s).Elem() package main import ( \"fmt\" \"reflect\" ) func main() { x := 2 c := reflect.ValueOf(\u0026x) c.Elem().SetInt(6) d := c.Elem() d.SetInt(0) fmt.Println(x) } 0 ä½¿ç”¨reflect.Valueå–å…ƒç´ ï¼Œå–åœ°å€ï¼Œåˆ¤æ–­æ˜¯å¦å¯å–åœ°å€å¯ä»¥ä¿®æ”¹çš„api æ–¹æ³•å å¤‡ æ³¨ Elem() Value å–å€¼æŒ‡å‘çš„å…ƒç´ å€¼ï¼Œç±»ä¼¼äºè¯­è¨€å±‚*æ“ä½œã€‚å½“å€¼ç±»å‹ä¸æ˜¯æŒ‡é’ˆæˆ–æ¥å£æ—¶å‘ç”Ÿå®• æœºï¼Œç©ºæŒ‡é’ˆæ—¶è¿”å› nil çš„ Value Addr() Value å¯¹å¯å¯»å€çš„å€¼è¿”å›å…¶åœ°å€ï¼Œç±»ä¼¼äºè¯­è¨€å±‚\u0026æ“ä½œã€‚å½“å€¼ä¸å¯å¯»å€æ—¶å‘ç”Ÿå®•æœº CanAddr() bool è¡¨ç¤ºå€¼æ˜¯å¦å¯å¯»å€ CanSet() bool è¿”å›å€¼èƒ½å¦è¢«ä¿®æ”¹ã€‚è¦æ±‚å€¼å¯å¯»å€ä¸”æ˜¯å¯¼å‡ºçš„å­—æ®µ ","date":"2022-10-04","objectID":"/reflect/:9:1","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"åŸåˆ™äºŒï¼šè¢«å¯¼å‡º ç»“æ„ä½“æˆå‘˜ä¸­ï¼Œå¦‚æœå­—æ®µæ²¡æœ‰è¢«å¯¼å‡ºï¼Œå³ä¾¿ä¸ä½¿ç”¨åå°„ä¹Ÿå¯ä»¥è¢«è®¿é—®ï¼Œä½†ä¸èƒ½é€šè¿‡åå°„ä¿®æ”¹ã€‚ package main import ( \"reflect\" ) func main() { type dog struct { legCount int } // è·å–dogå®ä¾‹çš„åå°„å€¼å¯¹è±¡ valueOfDog := reflect.ValueOf(dog{}) // è·å–legCountå­—æ®µçš„å€¼ vLegCount := valueOfDog.FieldByName(\"legCount\") // å°è¯•è®¾ç½®legCountçš„å€¼(è¿™é‡Œä¼šå‘ç”Ÿå´©æºƒ) vLegCount.SetInt(4) } :panic: reflect: reflect.Value.SetInt using value obtained using unexported field ä¸ºäº†èƒ½ä¿®æ”¹è¿™ä¸ªå€¼ï¼Œéœ€è¦å°†è¯¥å­—æ®µå¯¼å‡ºã€‚å°† dog ä¸­çš„ legCount çš„æˆå‘˜é¦–å­—æ¯å¤§å†™ï¼Œå¯¼å‡º LegCount è®©åå°„å¯ä»¥è®¿é—®ï¼Œä¿®æ”¹åçš„ä»£ç å¦‚ä¸‹ï¼š type dog struct { LegCount int } ç„¶åæ ¹æ®å­—æ®µåè·å–å­—æ®µçš„å€¼æ—¶ï¼Œå°†å­—ç¬¦ä¸²çš„å­—æ®µé¦–å­—æ¯å¤§å†™ï¼Œä¿®æ”¹åçš„ä»£ç å¦‚ä¸‹ï¼š vLegCount := valueOfDog.FieldByName(\"LegCount\") å†æ¬¡è¿è¡Œç¨‹åºï¼Œå‘ç°ä»ç„¶æŠ¥é”™ï¼š panic: reflect: reflect.Value.SetInt using unaddressable value è¿™ä¸ªé”™è¯¯è¡¨ç¤ºç¬¬ 13 è¡Œæ„é€ çš„ valueOfDog è¿™ä¸ªç»“æ„ä½“å®ä¾‹ä¸èƒ½è¢«å¯»å€ï¼Œå› æ­¤å…¶å­—æ®µä¹Ÿä¸èƒ½è¢«ä¿®æ”¹ã€‚ä¿®æ”¹ä»£ç ï¼Œå–ç»“æ„ä½“çš„æŒ‡é’ˆï¼Œå†é€šè¿‡ reflect.Value çš„ Elem() æ–¹æ³•å–åˆ°å€¼çš„åå°„å€¼å¯¹è±¡ã€‚ä¿®æ”¹åçš„å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š package main import ( \"reflect\" \"fmt\" ) func main() { type dog struct { LegCount int } // è·å–dogå®ä¾‹åœ°å€çš„åå°„å€¼å¯¹è±¡ valueOfDog := reflect.ValueOf(\u0026dog{}) // å–å‡ºdogå®ä¾‹åœ°å€çš„å…ƒç´  valueOfDog = valueOfDog.Elem() // è·å–legCountå­—æ®µçš„å€¼ vLegCount := valueOfDog.FieldByName(\"LegCount\") // å°è¯•è®¾ç½®legCountçš„å€¼(è¿™é‡Œä¼šå‘ç”Ÿå´©æºƒ) vLegCount.SetInt(4) fmt.Println(vLegCount.Int()) } 4 ","date":"2022-10-04","objectID":"/reflect/:9:2","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"å€¼ä¿®æ”¹ç›¸å…³api Set(x Value) å°†å€¼è®¾ç½®ä¸ºä¼ å…¥çš„åå°„å€¼å¯¹è±¡çš„å€¼ Setlnt(x int64) ä½¿ç”¨ int64 è®¾ç½®å€¼ã€‚å½“å€¼çš„ç±»å‹ä¸æ˜¯ intã€int8ã€int16ã€ int32ã€int64 æ—¶ä¼šå‘ç”Ÿå®•æœº SetUint(x uint64) ä½¿ç”¨ uint64 è®¾ç½®å€¼ã€‚å½“å€¼çš„ç±»å‹ä¸æ˜¯ uintã€uint8ã€uint16ã€uint32ã€uint64 æ—¶ä¼šå‘ç”Ÿå®•æœº SetFloat(x float64) ä½¿ç”¨ float64 è®¾ç½®å€¼ã€‚å½“å€¼çš„ç±»å‹ä¸æ˜¯ float32ã€float64 æ—¶ä¼šå‘ç”Ÿå®•æœº SetBool(x bool) ä½¿ç”¨ bool è®¾ç½®å€¼ã€‚å½“å€¼çš„ç±»å‹ä¸æ˜¯ bod æ—¶ä¼šå‘ç”Ÿå®•æœº SetBytes(x []byte) è®¾ç½®å­—èŠ‚æ•°ç»„ []byteså€¼ã€‚å½“å€¼çš„ç±»å‹ä¸æ˜¯ []byte æ—¶ä¼šå‘ç”Ÿå®•æœº SetString(x string) è®¾ç½®å­—ç¬¦ä¸²å€¼ã€‚å½“å€¼çš„ç±»å‹ä¸æ˜¯ string æ—¶ä¼šå‘ç”Ÿå®•æœº å¦‚æœCanSetè¿”å›çš„æ˜¯false, èè‹’è°ƒç”¨ä¸Šé¢çš„æ–¹æ³•å°±ä¼šå¯¼è‡´å®•æœº ","date":"2022-10-04","objectID":"/reflect/:9:3","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"é€šè¿‡ç±»å‹ä¿¡æ¯åˆ›å»ºå®ä¾‹ å½“å·²çŸ¥reflect.Typeæ—¶ï¼Œå¯ä»¥åŠ¨æ€åœ°åˆ›å»ºè¿™ä¸ªç±»å‹çš„å®ä¾‹ï¼Œå®ä¾‹çš„ç±»å‹ä¸ºæŒ‡é’ˆã€‚ç”¨ä¾‹ä»£ç å¦‚ä¸‹ package main import ( \"fmt\" \"reflect\" ) func main() { var a int // å–å˜é‡açš„åå°„ç±»å‹å¯¹è±¡ typeOfA := reflect.TypeOf(a) // æ ¹æ®åå°„ç±»å‹å¯¹è±¡åˆ›å»ºç±»å‹å®ä¾‹ aIns := reflect.New(typeOfA) // è¾“å‡ºValueçš„ç±»å‹å’Œç§ç±» fmt.Println(aIns.Type(), aIns.Kind()) } *int ptr ","date":"2022-10-04","objectID":"/reflect/:10:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"é€šè¿‡åå°„è°ƒç”¨å‡½æ•° åå°„è¿˜èƒ½è°ƒç”¨å‡½æ•°ï¼Œæ˜¯ä¸æ˜¯è§‰å¾—æŒºğŸ®ğŸºçš„ã€‚ å¦‚æœåå°„å€¼å¯¹è±¡(reflect.Value)ä¸­å€¼çš„ç±»å‹ä¸ºå‡½æ•°æ—¶ï¼Œå¯ä»¥é€šè¿‡reflect.Valueè°ƒç”¨è¯¥å‡½æ•°ã€‚ä½¿ç”¨åå°„è°ƒç”¨å‡½æ•°ï¼Œéœ€è¦å°†å‚æ•°ç”¨[]reflect.Valueæ„é€ åä¼ å…¥Call(). è°ƒç”¨å®Œæˆå‡½æ•°çš„è¿”å›å€¼ä¼šé€šè¿‡[]reflect.Valueè¿”å›ã€‚ package main import ( \"fmt\" \"reflect\" ) func add (a,b int) int { return a + b } func main(){ funcValue := reflect.ValueOf(add) paramList := []reflect.Value{reflect.ValueOf(10),reflect.ValueOf(20)} retList := funcValue.Call(paramList) fmt.Println(retList[0].Int()) } 30 åå°„è°ƒç”¨å‡½æ•°çš„è¿‡ç¨‹éœ€è¦æ„é€ å¤§é‡çš„ reflect.Value å’Œä¸­é—´å˜é‡ï¼Œå¯¹å‡½æ•°å‚æ•°å€¼è¿›è¡Œé€ä¸€æ£€æŸ¥ï¼Œè¿˜éœ€è¦å°†è°ƒç”¨å‚æ•°å¤åˆ¶åˆ°è°ƒç”¨å‡½æ•°çš„å‚æ•°å†…å­˜ä¸­ã€‚è°ƒç”¨å®Œæ¯•åï¼Œè¿˜éœ€è¦å°†è¿”å›å€¼è½¬æ¢ä¸º reflect.Valueï¼Œç”¨æˆ·è¿˜éœ€è¦ä»ä¸­å–å‡ºè°ƒç”¨å€¼ã€‚å› æ­¤ï¼Œåå°„è°ƒç”¨å‡½æ•°çš„æ€§èƒ½é—®é¢˜å°¤ä¸ºçªå‡ºï¼Œä¸å»ºè®®å¤§é‡ä½¿ç”¨åå°„å‡½æ•°è°ƒç”¨ã€‚ ","date":"2022-10-04","objectID":"/reflect/:11:0","tags":["golang"],"title":"golang reflect","uri":"/reflect/"},{"categories":["golang"],"content":"golang plugin è¯¦è§£","date":"2022-10-04","objectID":"/plugin/","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"golang çš„pluginç‰¹æ€§ æ˜¯å·²ç»å‡ºäº†å¥½å‡ å¹´äº†ã€‚ä¸è¿‡ç›´åˆ°æˆ‘å†™è¿™ç¯‡åšå®¢çš„æ—¶å€™ï¼Œgolangçš„plugin ä¹Ÿä»…æ”¯æŒlinux/unixå¹³å°ã€‚è€Œä¸”pluginçš„ä½¿ç”¨æœ‰è¯¸å¤šé™åˆ¶ï¼Œè®©å®ƒæˆä¸ºäº†ä¸€ä¸ªå†·é—¨ç‰¹æ€§ã€‚ ","date":"2022-10-04","objectID":"/plugin/:0:0","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"golang plugin golangçš„pluginä¸ºgolang æä¾›äº†ç±»ä¼¼åŠ¨æ€é“¾æ¥åº“çš„èƒ½åŠ›ã€‚é€šè¿‡pluginï¼Œæˆ‘ä»¬å¯ä»¥å°†GoåŒ…ç¼–è¯‘æˆå…±äº«åº“ï¼Œè¿™æ ·å°±å¯ä»¥åŠ¨æ€åŠ è½½æ¨¡å—ã€‚ ä½†æ˜¯ä»–æœ‰ä¸€äº›é™åˆ¶ æ’ä»¶çš„å®ç°å’Œä¸»åº”ç”¨ç¨‹åºå¿…é¡»ç”¨å®Œå…¨ç›¸åŒçš„Goå·¥å…·é“¾ç‰ˆæœ¬æ„å»ºã€‚è¿™ç§ç‰¹æ€§ä¸€èˆ¬åªä¼šç”¨äºç±»ä¼¼ç®—æ³•æ¨¡å—çš„æ›´æ–°ï¼Œå› ä¸ºç®—æ³•æ¨¡å—æ˜¯çº¯å‡½æ•°ã€‚ç¨‹åºåˆ†ä¸ºæ•°æ®å’Œç®—æ³•ï¼Œæ•°æ®ç»“æ„æ˜¯ä¸€å®šä¸èƒ½åŠ¨çš„ï¼Œå› ä¸ºé™æ€è¯­è¨€ä¼šæœ‰ç±»å‹æ£€æŸ¥ï¼Œè¿™ä¼šå¯¼è‡´å¾ˆå¤šçš„é—®é¢˜ã€‚ä½œä¸ºæ•°æ®ç»“æ„ä¸å•ä¼šè¢«ä¸»ç¨‹åºå¼•ç”¨ï¼Œpluginä¹Ÿå¾—å¼•ç”¨ã€‚ä¸¤è€…ç‰ˆæœ¬å¯¹ä¸ä¸Šï¼Œä¼šæ˜¯éå¸¸å¤´ç–¼çš„é—®é¢˜ã€‚ ä¸åŒsoæ–‡ä»¶å®šä¹‰çš„ç»“æ„ä½“ä¸èƒ½ä½¿ç”¨ç±»å‹æ–­è¨€è¿›è¡Œè½¬æ¢ æ¯ä¸ªsoä¸èƒ½å•ç‹¬ä¿å­˜æ•°æ®ï¼Œsoæ˜¯æ²¡æ³•è¢«å…³é—­çš„ã€‚å¯èƒ½å¤šä¸ªsoå¼•ç”¨åŒä¸€ä¸ªå˜é‡ï¼Œgcæ²¡æœ‰åŠæ³•é‡Šæ”¾ã€‚ ä½¿ç”¨pluginçš„ä¸»ç¨‹åºåªèƒ½å¤Ÿä½¿ç”¨åŠ¨æ€é“¾æ¥ï¼Œgoä»¥é™æ€ç¼–è¯‘è‘—ç§°ï¼Œç¼–è¯‘çš„ç¨‹åºä¸éœ€è¦åˆ«çš„ä¾èµ–å°±å¯ä»¥è·‘èµ·æ¥ã€‚ä½†æ˜¯ä½¿ç”¨äº†pluginçš„ä¸»ç¨‹åºå°±éœ€è¦ä¾èµ–ç³»ç»Ÿçš„åŠ¨æ€é“¾æ¥åº“äº†ã€‚ pluginçš„ä½¿ç”¨å¾ˆç®€å•ï¼Œåˆ†ä¸ºä¸‰ä¸ªæ­¥éª¤ã€‚ å…ˆç¼–å†™pluginç¨‹åºï¼Œ ç„¶åä½¿ç”¨-buildmode=plugin ç¼–è¯‘å‡º.soæ–‡ä»¶ ç¼–å†™ä¸»ç¨‹åº ä½¿ç”¨pluginåŒ…çš„apiå»è°ƒç”¨pluginä¸­çš„å‡½æ•° ä¸¾ä¸ªä¾‹å­ å…ˆçœ‹é¡¹ç›®ç»“æ„ pluginç›®å½•ä¸‹çš„plug.goæ˜¯plug.soçš„æºç æ–‡ä»¶ï¼Œ ä¸»ç¨‹åºæ˜¯testç›®å½•ä¸‹çš„test.go ç¼–å†™pluginç¨‹åº plug.go package main import ( \"fmt\" ) func PrintHahaha() { fmt.Println(\"Hahaha\") } func CallInDirect() { i:= 1 i++ } note å¿…é¡»è¦æ³¨æ„ï¼Œpluginç¨‹åºçš„åŒ…å®šä¹‰å¿…é¡»æ˜¯package main å¯ä»¥æ²¡æœ‰mainå‡½æ•°ã€‚åŒä¸€ä¸ªpluginç¨‹åºçš„initå‡½æ•°åªä¼šè¢«è°ƒç”¨ä¸€æ¬¡ï¼Œé‡å¤åŠ è½½åä¹Ÿä¸ä¼šå†è¢«è°ƒç”¨(å°±æ˜¯è¯´ pluginåœ¨ç¬¬ä¸€æ¬¡è¢«æ‰“å¼€æ—¶ï¼Œä¼šè°ƒç”¨åŒ…é‡Œé¢çš„initå‡½æ•°ï¼Œä½†æ˜¯åé¢å†æ¬¡æ‰“å¼€initæ˜¯ä¸ä¼šå†è¢«è°ƒç”¨çš„) ä½¿ç”¨-buildmode=pluginå‚æ•°ç¼–è¯‘ cd plugin go build -buildmode=plugin -o plug.so ./plug.go ç¼–å†™è°ƒç”¨çš„ä¸»ç¨‹åºtest.go package main import ( \"fmt\" \"plugin\" ) func main() { plug, err := plugin.Open(\"../plugin/plug.so\") if err != nil { fmt.Println(err) } foo, err := plug.Lookup(\"PrintHahaha\") if err != nil { fmt.Println(err) } PrintHahaha, ok := foo.(func()) if !ok { fmt.Println(\"unexpected type from module symbol\") } PrintHahaha() } è¿™é‡Œå…ˆä»‹ç»ä¸€ä¸‹åŸºæœ¬ä½¿ç”¨æµç¨‹ï¼Œæ–¹ä¾¿ä¸‹é¢çš„æ€§èƒ½æµ‹è¯• ","date":"2022-10-04","objectID":"/plugin/:1:0","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"æ€§èƒ½æµ‹è¯• å…ˆè¯´ç»“è®ºï¼Œpluginçš„å‡½æ•°è°ƒç”¨è¦æ¯”æ­£å¸¸çš„ç›´æ¥å‡½æ•°è°ƒç”¨æ…¢å¾ˆå¤šï¼Œå¤§æ¦‚æ…¢3å€å·¦å³ã€‚ä½†æ˜¯ä½ å¤§å¯ä¸å¿…æ„Ÿåˆ°å¤±æœ›ï¼Œå› ä¸ºå®é™…ä½¿ç”¨ä¸­å¹¶ä¸ä¸€å®šå°±ä¼šæœ‰å¾ˆå¤§çš„æ€§èƒ½å·®å¼‚ã€‚ è¿™é‡Œä¼šåˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯è°ƒç”¨pluginä¸­å‡½æ•°çš„è°ƒç”¨é€Ÿåº¦ä¸ç›´æ¥è°ƒç”¨å‡½æ•°é€Ÿåº¦çš„å¯¹æ¯”ï¼Œå¦ä¸€ä¸ªåˆ™æ˜¯æµ‹è¯•plugin LookUpçš„æ€§èƒ½ ","date":"2022-10-04","objectID":"/plugin/:2:0","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"directCall vs indirectCall å…ˆåœ¨å®¿ä¸»ç¨‹åºä¸­æ·»åŠ ä¸€ä¸ªCallDirectå‡½æ•°ä½œä¸ºç›´æ¥è°ƒç”¨çš„ç´ æ func CallDirect() { // for i := 0; i \u003c 1000; i++ { // } i := 10 i++ } å†åœ¨pluginä¸­æ·»åŠ CallInDirectå‡½æ•°ä½œä¸ºè°ƒç”¨pluginä¸­å‡½æ•°çš„ç´ æ func CallInDirect() { // for i := 0; i \u003c 1000; i++ { // } i := 10 i++ } æ¥ä¸‹æ¥ç¼–å†™benchmark func BenchmarkCallDirect(b *testing.B) { for i := 0; i \u003c b.N; i++ { CallDirect() } } func BenchmarkCallInDirect(b *testing.B) { plug, err := plugin.Open(\"../plugin/plug.so\") if err != nil { fmt.Println(err) } foo, err := plug.Lookup(\"CallInDirect\") if err != nil { fmt.Println(err) } CallInDirect, ok := foo.(func()) if !ok { return } for i := 0; i \u003c b.N; i++ { CallInDirect() } } ä¸‹é¢æ˜¯è·‘åˆ†ç»“æœ BenchmarkCallDirect ~/test/testPlugin/test â¯ go test -bench=\"CallDirect$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkCallDirect-8 1000000000 0.3317 ns/op BenchmarkCallDirect-8 1000000000 0.3271 ns/op BenchmarkCallDirect-8 1000000000 0.3228 ns/op PASS ok testplugin 1.346s BenchmarkCallInDirect ~/test/testPlugin/test â¯ go test -bench=\"CallInDirect$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkCallInDirect-8 1000000000 0.9653 ns/op BenchmarkCallInDirect-8 1000000000 0.9513 ns/op BenchmarkCallInDirect-8 1000000000 0.9542 ns/op PASS ok testplugin 3.801s å·®ä¸å¤šæ˜¯ä¸‰å€çš„å·®è·ï¼Œä½†æ˜¯è¿™é‡Œï¼Œæµ‹è¯•ç´ ææ¯”è¾ƒç®€å•ã€‚å¦‚æœè®©æµ‹è¯•ç´ æé‡Œé¢è·‘ä¸€äº›æ¯”è¾ƒè€—æ—¶çš„é€»è¾‘å‘¢ã€‚ CallDirect func CallDirect() { for i := 0; i \u003c 1000; i++ { } // i := 10 // i++ } CallInDirect func CallInDirect() { for i := 0; i \u003c 1000; i++ { } // i := 10 // i++ } è·‘åˆ†ç»“æœ BenchmarkCallDirect ~/test/testPlugin/test 13s â¯ go test -bench=\"CallDirect$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkCallDirect-8 16496887 327.1 ns/op BenchmarkCallDirect-8 17459262 328.3 ns/op BenchmarkCallDirect-8 18355296 332.5 ns/op PASS ok testplugin 21.329s BenchmarkCallInDirect â¯ go test -bench=\"CallInDirect$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkCallInDirect-8 16783506 331.3 ns/op BenchmarkCallInDirect-8 18161929 333.9 ns/op BenchmarkCallInDirect-8 18247104 328.9 ns/op PASS ok testplugin 18.826s summary å·®è·æ˜¯æ— é™ç¼©å°çš„ï¼Œå¤§æ¦‚èƒ½å¤Ÿå¾—å‡ºçš„ç»“è®ºæ˜¯ã€‚å¦‚æœä½ ä¸æ˜¯ä¸è¦å‘½çš„é¢‘ç¹çš„å»è°ƒç”¨å‡½æ•°ï¼Œé‚£ä¹ˆpluginè°ƒç”¨å¸¦æ¥çš„æ¶ˆè€—å‡ ä¹å¯ä»¥å¿½ç•¥ä¸è®¡ï¼Œå°¤å…¶æ˜¯å½“ä½ çš„å‡½æ•°æ‰§è¡Œè¶Šè€—æ—¶ï¼Œè¿™ç§å·®å¼‚å°±ä¼šè¶Šå°ã€‚ ","date":"2022-10-04","objectID":"/plugin/:2:1","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"LookUpçš„æ€§èƒ½ è·‘åˆ†ä»£ç  func BenchmarkLookUp(b *testing.B) { plug, err := plugin.Open(\"../plugin/plug.so\") if err != nil { fmt.Println(err) } for i := 0; i \u003c b.N; i++ { plug.Lookup(\"CallInDirect\") } } è·‘åˆ†ç»“æœ ~/test/testPlugin/test 20s â¯ go test -bench=\"LookUp$\" -benchtime=5s -count=3 . goos: darwin goarch: arm64 pkg: testplugin BenchmarkLookUp-8 1000000000 4.785 ns/op BenchmarkLookUp-8 1000000000 4.791 ns/op BenchmarkLookUp-8 1000000000 4.787 ns/op PASS ok testplugin 16.576s æ€§èƒ½ä¹Ÿè¿˜ä¸é”™å“¦ ","date":"2022-10-04","objectID":"/plugin/:2:2","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["golang"],"content":"ç»“è®º æ­£å¸¸ä½¿ç”¨è¿‡ç¨‹ä¸­ä½ å¹¶ä¸éœ€è¦ç‰¹åˆ«å…³å¿ƒpluginæ‰€å¸¦æ¥çš„æ¶ˆè€—ï¼Œå› ä¸ºç›¸æ¯”å‡½æ•°å†…éƒ¨é€»è¾‘å¸¦æ¥çš„æ¶ˆè€—ï¼Œplugin æ‰€å¸¦æ¥çš„æ¶ˆè€—å®åœ¨æ˜¯å¤ªå°äº†ã€‚åœ¨äº†è§£pluginç‰¹æ€§çš„æ—¶å€™ï¼Œæˆ‘è¿˜äº†è§£åˆ°golang æœ‰ä¸€ä¸ª go-plugin çš„åŒ…ï¼Œä½¿ç”¨grpcæ¥å®ç°ç»„ä»¶çš„æ‹”æ’ï¼Œæˆªæ­¢åˆ°ç°åœ¨å·²ç»æœ‰3.7kçš„æ”¶è—ã€‚æ‰€ä»¥æ€§èƒ½å¹¶ä¸ç”±è°ƒç”¨å‡½æ•°çš„é€Ÿåº¦å†³å®šï¼Œæ€§èƒ½å–å†³äºå‡½æ•°å†…éƒ¨çš„é€»è¾‘æ˜¯å¦‚ä½•å®ç°çš„ã€‚ ","date":"2022-10-04","objectID":"/plugin/:3:0","tags":["golang"],"title":"golang plugin","uri":"/plugin/"},{"categories":["lisp"],"content":"common lisp å­—ç¬¦ä¸²","date":"2022-10-04","objectID":"/strings/","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"ä½ åº”è¯¥çŸ¥é“ï¼Œstring åœ¨ common lisp ä¸­å®ƒæ—¢æ˜¯arrays ä¹Ÿæ˜¯ sequences. ä¹Ÿå°±æ˜¯è¯´ï¼Œarrays å’Œ sequencesçš„æ“ä½œéƒ½å¯ä»¥åº”ç”¨åœ¨stringä¸Šã€‚å¦‚æœä½ æ‰¾ä¸åˆ°æŸä¸ªstringç‰¹æœ‰çš„å‡½æ•°ï¼Œä½ åº”è¯¥å»æ‰¾ä¸€æ‰¾arrays å’Œ sequencesçš„å‡½æ•°ã€‚ è¿˜æœ‰ä¸€äº›é¢å¤–çš„libraries æ‰˜ç®¡åœ¨ quicklispä¸Šï¼Œè¿™é‡Œåªç»™å‡ºè‹±æ–‡ä»‹ç» ASDF3, which is included with almost all Common Lisp implementations, includes Utilities for Implementation- and OS- Portability (UIOP), which defines functions to work on strings (strcat, string-prefix-p, string-enclosed-p, first-char, last-char, split-string, stripln). Some external libraries available on Quicklisp bring some more functionality or some shorter ways to do. str defines trim, words, unwords, lines, unlines, concat, split, shorten, repeat, replace-all, starts-with?, ends-with?, blankp, emptyp, â€¦ Serapeum is a large set of utilities with many string manipulation functions. cl-change-case has functions to convert strings between camelCase, param-case, snake_case and more. They are also included into str. mk-string-metrics has functions to calculate various string metrics efficiently (Damerau-Levenshtein, Hamming, Jaro, Jaro-Winkler, Levenshtein, etc), and cl-ppcre can come in handy, for example ppcre:replace-regexp-all. See the regexp section. Last but not least, when youâ€™ll need to tackle the format construct, donâ€™t miss the following resources: the official CLHS documentation a quick reference a CLHS summary on HexstreamSoft plus a Slime tip: type C-c C-d ~ plus a letter of a format directive to open up its documentation. Again more useful with ivy-mode or helm-mode. ","date":"2022-10-04","objectID":"/strings/:0:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"åˆ›å»º å­—ç¬¦ä¸² æœ€ç®€å•çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨åŒå¼•å·åˆ›å»ºstring.ä½†æ˜¯å…¶å®æˆ‘ä»¬è¿˜æœ‰åˆ«çš„æ–¹æ³•: ä½¿ç”¨format nil (defparameter person \"you\") (format nil \"hello ~a\" person) ;; =\u003e \"hello you\" make-string count åˆ›å»ºæŒ‡å®šé•¿åº¦çš„å­—ç¬¦ä¸²ã€‚ :initial-element å­—ç¬¦ä¼šè¢«é‡å¤countæ¬¡ (make-string 3 :initial-element #\\â™¥) ;; =\u003e \"â™¥â™¥â™¥\" ","date":"2022-10-04","objectID":"/strings/:1:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"è®¿é—®å­ä¸² string æ˜¯ä¸€ä¸ªsequence,ä½ å¯ä»¥ä½¿ç”¨subseq æ¥è®¿é—®å®ƒçš„å­ä¸² å…ˆç»™å‡ºä¸€ä¸ªæ¯”è¾ƒæ˜“æ‡‚çš„ç­¾å (subseq my-string start end) è¿™é‡Œæ˜¯è°ƒç”¨ * (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* * (subseq *my-string* 8) \"Marx\" * (subseq *my-string* 0 7) \"Groucho\" * (subseq *my-string* 1 5) \"rouc\" ä¹Ÿå¯ä»¥åƒåºåˆ—é‚£æ ·ç”¨setf å’Œ subseq é…åˆæ¥æ“ä½œå­—ç¬¦ä¸² * (defparameter *my-string* (string \"Harpo Marx\")) *MY-STRING* * (subseq *my-string* 0 5) \"Harpo\" * (setf (subseq *my-string* 0 5) \"Chico\") \"Chico\" * *my-string* \"Chico Marx\" string isn`t stretchable å­—ç¬¦ä¸²çš„é•¿åº¦æ˜¯ä¸å¯å˜çš„ï¼Œå¦‚æœæ–°çš„å­ä¸²çš„é•¿åº¦å’ŒåŸå§‹å­ä¸²çš„é•¿åº¦ä¸åŒï¼ŒçŸ­çš„é‚£ä¸€ä¸ªå°†å†³å®šå¤šå°‘ä¸ªå­—ç¬¦å°†è¢«æ›¿æ¢ï¼Œ * (defparameter *my-string* (string \"Karl Marx\")) *MY-STRING* * (subseq *my-string* 0 4) \"Karl\" * (setf (subseq *my-string* 0 4) \"Harpo\") \"Harpo\" * *my-string* \"Harp Marx\" * (subseq *my-string* 4) \" Marx\" * (setf (subseq *my-string* 4) \"o Marx\") \"o Marx\" * *my-string* \"Harpo Mar\" ","date":"2022-10-04","objectID":"/strings/:2:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"è®¿é—®å•ä¸ªå­—ç¬¦ charå‡½æ•°ä¸“é—¨ç”¨æ¥è®¿é—®å­—ç¬¦ä¸²ä¸­çš„å•ä¸ªå­—ç¬¦ï¼Œcharä¹Ÿå¯ä»¥å’Œsetfé…åˆä½¿ç”¨ (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (char *my-string* 11) #\\x (char *my-string* 7) #\\Space (char *my-string* 6) #\\o (setf (char *my-string* 6) #\\y) #\\y *my-string* \"Grouchy Marx\" è¿˜æœ‰ä¸€ä¸ªscharä¹Ÿå¯ä»¥åšåˆ°åŒæ ·çš„äº‹æƒ…ï¼Œä½†æ˜¯åœ¨ç‰¹å®šæƒ…å†µä¸‹ï¼Œscharä¼šæ›´å¿«ä¸€äº› å› ä¸ºstrings æ—¢æ˜¯ arrays ä¹Ÿæ˜¯ sequence. ä½ ä¹Ÿå¯ä»¥ç”¨æ›´åŠ é€šç”¨çš„aref å’Œ elt (ä½†æ˜¯charçš„æ•ˆç‡ä¼šæ›´é«˜) (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (aref *my-string* 3) #\\u (elt *my-string* 8) #\\M ","date":"2022-10-04","objectID":"/strings/:3:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"ä»stringä¸­åˆ é™¤å’Œæ›¿æ¢ å¯ä»¥ä½¿ç”¨ sequenceçš„å‡½æ•°æ¥å¯¹stringä¸­çš„å­ä¸²è¿›è¡Œåˆ é™¤å’Œæ›¿æ¢æ“ä½œ ä»stringä¸­åˆ é™¤ä¸€ä¸ªå­—ç¬¦ (remove #\\o \"Harpo Marx\") \"Harp Marx\" (remove #\\a \"Harpo Marx\") \"Hrpo Mrx\" (remove #\\a \"Harpo Marx\" :start 2) \"Harpo Mrx\" (remove-if #'upper-case-p \"Harpo Marx\") \"arpo arx\" ä½¿ç”¨substitute(non destructive) æˆ–è€… replace (destructive) æ¥æ›¿æ¢ä¸€ä¸ªå­—ç¬¦ (substitute #\\u #\\o \"Groucho Marx\") \"Gruuchu Marx\" (substitute-if #\\_ #'upper-case-p \"Groucho Marx\") \"_roucho _arx\" (defparameter *my-string* (string \"Zeppo Marx\")) *MY-STRING* (replace *my-string* \"Harpo\" :end1 5) \"Harpo Marx\" *my-string* \"Harpo Marx\" ","date":"2022-10-04","objectID":"/strings/:4:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"æ‹¼æ¥å­—ç¬¦ä¸² (Concatenating string) concatenate æ˜¯sequenceçš„é€šç”¨å‡½æ•°ï¼Œåœ¨å¯¹stringè¿›è¡Œæ“ä½œæ—¶ï¼Œåº”è¯¥æŒ‡å®šè¿”å›å€¼çš„ç±»å‹ (concatenate 'string \"karl\" \" \" \"Marx\") ;; =\u003e \"Karl Marx\" (concatenate 'list \"Karl\" \" \" \"Marx\") ;; =\u003e (#\\K #\\a #\\r #\\l #\\Space #\\M #\\a #\\r #\\x) ä½¿ç”¨UIOPåº“çš„è¯ï¼Œå¯ä»¥ç”¨strcat: (uiop:strcat \"karl\" \" \" marx\") æˆ–è€…æ˜¯str library ä½¿ç”¨concat: (str:concat \"foo\" \"bar\") ","date":"2022-10-04","objectID":"/strings/:5:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"ä¸€æ¬¡æ“ä½œä¸€ä¸ªå­—ç¬¦ ä½¿ç”¨Mapå‡½æ•°ä¸€æ¬¡æ“ä½œä¸€ä¸ªå­—ç¬¦ (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (map 'string #'(lambda (c) (print c)) *my-string*) #\\G #\\r #\\o #\\u #\\c #\\h #\\o #\\Space #\\M #\\a #\\r #\\x \"Groucho Marx\" æˆ–è€…ä½¿ç”¨loop å‡½æ•° (loop for char across \"Zeppo\" collect char) (#\\Z #\\e #\\p #\\p #\\o) ","date":"2022-10-04","objectID":"/strings/:6:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"æ ¹æ®word æˆ– characterç¿»è½¬string ä½¿ç”¨reverse (æˆ–è€…destructive ç‰ˆçš„ nreverse) æ¥æ ¹æ®characteråè½¬å­—ç¬¦ä¸² (defparameter *my-string* (string \"DSL\")) *MY-STRING* (reverse *my-string*) \"LSD\" åœ¨CLä¸­ æ²¡æœ‰ç›´æ¥æ ¹æ®wordåè½¬å­—ç¬¦ä¸²çš„å‡½æ•°ï¼Œä½ å¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ æ¯”å¦‚SPLIT-SEQUENCE æˆ–è€…ä½ è‡ªå·±å®ç°ä¸€å¥—è§£å†³æ–¹æ¡ˆ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨stråº“ (defparameter *singing* \"singing in the rain\") *SINGING* (str:words *SINGING*) ;; =\u003e (\"singing\" \"in\" \"the\" \"rain\") (str:unwords (reverse (str:words *singing*))) ;; =\u003e \"rain the in singing\" ","date":"2022-10-04","objectID":"/strings/:7:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"Breaking strings into graphenes,sentences,lines and words These functions use SBCLâ€™s sb-unicode: they are SBCL specific. sb-unicode:sentences å°†string ä»¥æ®µè½åˆ‡å‰²ï¼Œæ ¹æ®ä»–é»˜è®¤çš„æ®µè½åˆ†å‰²è§„åˆ™ sb-unicode:lines å°†string åˆ†å‰²æˆè¡Œï¼ˆé•¿åº¦ä¸ä¼šè¶…è¿‡:margin æŒ‡å®šçš„å‚æ•° é»˜è®¤80ï¼‰ (sb-unicode:lines \"A first sentence. A second somewhat long one.\" :margin 10) ;; =\u003e (\"A first\" ;; \"sentence.\" ;; \"A second\" ;; \"somewhat\" ;; \"long one.\") sb-unicode:words å’Œ sb-unicode:graphenes å¯ä»¥è‡ªå·±å»æŸ¥çœ‹ ç¡®ä¿è¿è¡Œåœ¨sbclä¸­ #+sbcl (runs on sbcl) #-sbcl (runs on other implementations) ","date":"2022-10-04","objectID":"/strings/:8:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"Controlling Case æ§åˆ¶å¤§å°å†™ Common lisp æä¾›äº†å¤§é‡çš„å‡½æ•°æ¥æ§åˆ¶å­—ç¬¦ä¸²çš„å¤§å°å†™ (string-upcase \"cool\") ;; =\u003e \"COOL\" (string-upcase \"Cool\") ;; =\u003e \"COOL\" (string-downcase \"COOL\") ;; =\u003e \"cool\" (string-downcase \"Cool\") ;; =\u003e \"cool\" (string-capitalize \"cool\") ;; =\u003e \"Cool\" (string-capitalize \"cool example\") ;; =\u003e \"Cool Example\" è¿™äº›å‡½æ•°å¯ä»¥æ¥å—:start å’Œ :key æ‰€ä»¥ä½ å¯ä»¥åªå¯¹å­—ç¬¦ä¸²çš„æŒ‡å®šéƒ¨åˆ†è¿›è¡Œæ“ä½œã€‚ è¿™äº›å‡½æ•°ä¹Ÿæœ‰destructiveçš„ç‰ˆæœ¬éƒ½ä»¥nå¼€å¤´ (string-capitalize \"cool example\" :start 5) ;; =\u003e \"cool Example\" (string-capitalize \"cool example\" :end 5) ;; =\u003e \"Cool example\" (defparameter *my-string* (string \"BIG\")) ;; =\u003e *MY-STRING* (defparameter *my-downcase-string* (nstring-downcase *my-string*)) ;; =\u003e *MY-DOWNCASE-STRING* *my-downcase-string* ;; =\u003e \"big\" *my-string* ;; =\u003e \"big\" warning å¯¹äº string-upcase,string-downcase å’Œ string-capitalize,string æ˜¯æ²¡æœ‰è¢«ä¿®æ”¹çš„ã€‚ä½†æ˜¯å¦‚æœåœ¨stringä¸­æ²¡æœ‰ä»»ä½•å­—ç¬¦éœ€è¦è½¬æ¢ï¼Œé‚£ä¹ˆè¿”å›å€¼æœ‰å¯èƒ½æ˜¯æºstring æˆ–è€… æºstringçš„å‰¯æœ¬ tips åœ¨CLä¸­ nå¼€å¤´çš„å‡½æ•°ä¸€èˆ¬æ˜¯destructiveçš„ ","date":"2022-10-04","objectID":"/strings/:9:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"ä½¿ç”¨formatå‡½æ•°æ§åˆ¶ To lower case: (format t \"~(~a~)\" \"HELLO WORLD\") ;; =\u003e hello world Capitalize every word: (format t \"~:(~a~)\" \"HELLO WORLD\") ;; =\u003e Hello World Capitalize the first word: (format t \"~@(~a~)\" \"hello world\") ;; =\u003e Hello world To upper case (format t \"~@:(~a~)\" \"hello world\") ;; =\u003e HELLO WORLD ","date":"2022-10-04","objectID":"/strings/:9:1","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"å°†å­—ç¬¦ä¸²å·¦å³çš„ç©ºæ ¼æˆªæ‰ å…¶å®ä¸å•å•å¯ä»¥æˆªæ‰ç©ºæ ¼ï¼Œè¿˜å¯ä»¥ä¸¢å¼ƒä¸€äº›ä¸éœ€è¦çš„å­—ç¬¦ã€‚string-trim,string-left-trim,string-right-trim è¿”å›ä¸€ä¸ªå­ä¸²ï¼Œå­ä¸²ä¸åŒ…å«ç¬¬ä¸€ä¸ªå‚æ•°ä¸­çš„å­—ç¬¦ã€‚ (string-trim \" \" \" trim me \") ;; =\u003e \"trim me\" (string-trim \" et\" \" trim me \") ;; =\u003e \"rim m\" (string-left-trim \" et\" \" trim me \") ;; =\u003e \"rim me \" (string-right-trim \" et\" \" trim me \") ;; =\u003e \" trim m\" (string-right-trim '(#\\Space #\\e #\\t) \" trim me \") ;; = \u003e\" trim m\" (string-right-trim '(#\\Space #\\e #\\t #\\m) \" trim me \") ","date":"2022-10-04","objectID":"/strings/:10:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"åœ¨symbol å’Œ å­—ç¬¦ä¸²ä¹‹é—´è½¬æ¢ intern å°†stringè½¬åŒ–æˆsymbol (in-package \"COMMON-LISP-USER\") ;; =\u003e #\u003cThe COMMON-LISP-USER package, 35/44 internal, 0/9 external\u003e (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL ;; =\u003e:INTERNAL (export 'MY-SYMBOL) ;; =\u003e T (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL ;; =\u003e :EXTERNAL (intern \"My-Symbol\") ;; =\u003e |My-Symbol| ;; =\u003e NIL (intern \"MY-SYMBOL\" \"KEYWORD\") ;; =\u003e :MY-SYMBOL ;; =\u003e NIL (intern \"MY-SYMBOL\" \"KEYWORD\") ;; =\u003e :MY-SYMBOL ;; =\u003e :EXTERNAL symbol-name å’Œ string å°†symbol è½¬æ¢æˆ string (symbol-name 'MY-SYMBOL) ;; =\u003e \"MY-SYMBOL\" (symbol-name 'my-symbol) ;; =\u003e \"MY-SYMBOL\" (symbol-name '|my-symbol|) ;; =\u003e \"my-symbol\" (string 'howdy) ;; =\u003e \"HOWDY\" ","date":"2022-10-04","objectID":"/strings/:11:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"åœ¨string å’Œ characterä¹‹é—´è½¬æ¢ coerce å°†string(é•¿åº¦ä¸º1)è½¬æ¢æˆcharacter. (coerce \"a\" 'character) ;; =\u003e #\\a (coerce (subseq \"cool\" 2 3) 'character) ;; =\u003e #\\o coerce å°†å­—ç¬¦ä¸²è½¬æ¢ä¸­å­—ç¬¦list (coerce \"cool\" 'list) ;; =\u003e (#\\c #\\o #\\o #\\l) coerce å°†å­—ç¬¦listè½¬æ¢æˆstring (coerce '(#\\h #\\e #\\y) 'string) ;; =\u003e \"hey\" coerce å°†array è½¬æ¢æˆstring (defparameter *my-array* (make-array 5 :initial-element #\\x)) ;; =\u003e *MY-ARRAY* *my-array* ;; =\u003e #(#\\x #\\x #\\x #\\x #\\x) (coerce *my-array* 'string) ;; =\u003e \"xxxxx\" ","date":"2022-10-04","objectID":"/strings/:12:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"åœ¨stringä¸­å¯»æ‰¾ä¸€ä¸ªå…ƒç´  ä½¿ç”¨find,position å’Œä»–ä»¬çš„-ifåç¼€çš„å‡½æ•° æŸ¥æ‰¾stringä¸­çš„character (find #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e #\\t (find #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e #\\T (find #\\z \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e NIL (find-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;;=\u003e #\\1 (find-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :from-end t) ;; =\u003e #\\0 (position #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e 17 (position #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e 0 (position-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;; =\u003e 37 (position-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :from-end t) ;; =\u003e 43 ä½¿ç”¨countæ—å‡½æ•°è®¡ç®—å­—ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•° (count #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e 2 (count #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e 3 (count-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;; =\u003e 6 (count-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :start 38) ;; =\u003e 5 ","date":"2022-10-04","objectID":"/strings/:13:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"åœ¨å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾ä¸€ä¸ªå­ä¸² (search \"we\" \"If we can't be free we can at least be cheap\") ;; =\u003e 3 (search \"we\" \"If we can't be free we can at least be cheap\" :from-end t) ;; =\u003e 20 (search \"we\" \"If we can't be free we can at least be cheap\" :start2 4) ;; =\u003e 20 (search \"we\" \"If we can't be free we can at least be cheap\" :end2 5 :from-end t) ;; =\u003e 3 (search \"FREE\" \"If we can't be free we can at least be cheap\") ;; =\u003e NIL (search \"FREE\" \"If we can't be free we can at least be cheap\" :test #'char-equal) ;; =\u003e 15 ","date":"2022-10-04","objectID":"/strings/:14:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"å°†string è½¬æ¢æˆnumber to integer ä¼šè¿”å›ä¸¤ä¸ªå€¼ï¼Œä¸€ä¸ªæ˜¯è¢«è½¬æ¢åçš„å€¼ï¼Œå¦ä¸€ä¸ªæ˜¯è½¬æ¢åœæ­¢çš„ä½ç½® (parse-integer \"42\") ;; =\u003e 42 ;; =\u003e 2 (parse-integer \"42\" :start 1) ;; =\u003e 2 ;; =\u003e 2 (parse-integer \"42\" :end 1) ;; =\u003e 4 ;; =\u003e 1 (parse-integer \"42\" :radix 8) ;; =\u003e 34 ;; =\u003e2 (parse-integer \" 42 \") ;; =\u003e 42 ;; =\u003e 3 (parse-integer \" 42 is forty-two\" :junk-allowed t) ;; =\u003e 42 ;; =\u003e 3 (parse-integer \" 42 is forty-two\") Error in function PARSE-INTEGER: There's junk in this string: \" 42 is forty-two\". è½¬æ¢æˆä»»æ„number: read-from-string (read-from-string \"#X23\") ;; =\u003e 35,4 (read-from-string \"4.5\") ;; =\u003e 4.5,3 (read-from-string \"6/8\") ;; =\u003e 3/4,3 (read-from-string \"#C(6/8 1)\") ;; =\u003e #C(3/4 1),9 (read-from-string \"1.2e2\") ;; =\u003e 120.00001,5 (read-from-string \"symbol\") ;; SYMBOL.6 (defparameter *foo* 42) ;; =\u003e *FOO* (read-from-string \"#.(setq *foo* \\\"gotcha\\\")\") ;; =\u003e \"gotcha\",23 *foo* ;; =\u003e \"gotcha\" ","date":"2022-10-04","objectID":"/strings/:15:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"è½¬æ¢æˆfloat parse-float åº“æä¾›è½¬æ¢æˆfloatçš„å‡½æ•° (ql:quickload \"parse-float\") (parse-float:parse-float \"1.2e2\") ;; =\u003e 120.00001,5 ","date":"2022-10-04","objectID":"/strings/:16:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"number è½¬ string (write-to-string 250) ;; =\u003e \"250\" (write-to-string 250.02) ;; =\u003e \"250.02\" (write-to-string 250 :base 5) ;; =\u003e \"2000\" (write-to-string (/ 1 3)) ;; =\u003e \"1/3\" ","date":"2022-10-04","objectID":"/strings/:17:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"å­—ç¬¦ä¸²æ¯”è¾ƒ equal å’Œ equalp éƒ½å¯ä»¥æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸åŒï¼Œä½†æ˜¯equalæ˜¯å¤§å°å†™æ•æ„Ÿçš„ï¼Œè€Œequalpä¸æ˜¯ã€‚è¿˜æœ‰ä¸€äº›stringä¸“ç”¨çš„å‡½æ•°ã€‚ (string= \"Marx\" \"Marx\") ;; =\u003e T (string= \"Marx\" \"marx\") ;; =\u003e NIL (string-equal \"Marx\" \"marx\") ;; =\u003e T (string\u003c \"Groucho\" \"Zeppo\") ;; =\u003e 0 (string\u003c \"groucho\" \"Zeppo\") ;; =\u003e NIL (string-lessp \"groucho\" \"Zeppo\") ;; =\u003e 0 (mismatch \"Harpo Marx\" \"Zeppo Marx\" :from-end t :test #'char=) ;; =\u003e 3 ","date":"2022-10-04","objectID":"/strings/:18:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"String formatting see https://lispcookbook.github.io/cl-cookbook/strings.html#string-formatting ","date":"2022-10-04","objectID":"/strings/:19:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"æ•è·å“ªäº›ä¸œè¥¿è¢«æ‰“å°è¿›äº†stream åœ¨(with-output-to-string (mystream) â€¦) ä¸­ä»»ä½•æ‰“å°è¿›streamä¸­çš„å†…å®¹éƒ½ä¼šè¢«æ•è· (defun greet (name \u0026key (stream t)) ;; by default, print to standard output. (format stream \"hello ~a\" name)) (let ((output (with-output-to-string (stream) (greet \"you\" :stream stream)))) (format t \"Output is: '~a'. It is indeed a ~a, aka a string.~\u0026\" output (type-of output))) ;; Output is: 'hello you'. It is indeed a (SIMPLE-ARRAY CHARACTER (9)), aka a string. ;; NIL ","date":"2022-10-04","objectID":"/strings/:20:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"åˆ é™¤æ ‡ç‚¹ç¬¦å· ä½¿ç”¨(str:remove-punctuation s) æˆ–è€… (str:no-case s) (str:remove-punctuation \"HEY! What's up ??\") ;; \"HEY What s up\" (str:no-case \"HEY! What's up ??\") ;; \"hey what s up\" ","date":"2022-10-04","objectID":"/strings/:21:0","tags":["common-lisp"],"title":"Common-Lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"common lisp number æ•°å€¼","date":"2022-10-04","objectID":"/numbers/","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"integer types CL æä¾›ä¸€ä¸ªtrue integerç±»å‹ï¼Œå«bignum,åªå—å†…å­˜æ§åˆ¶ã€‚ ä¸ºäº†æ•ˆç‡è€ƒè™‘ï¼Œintegers å¯ä»¥è¢«é™åˆ¶æˆfixnum typeã€‚integers çš„èŒƒå›´å¯ä»¥è¿™æ ·æŸ¥çœ‹ most-positive-fixnum 4611686018427387903 most-negative-fixnum -4611686018427387904 integer ç›¸å…³çš„å‡½æ•°æœ‰ isqrt, è¿”å›å°äºä¸”æœ€æ¥è¿‘äºæŒ‡å®šæ•°çš„å¹³æ–¹æ ¹ (isqrt 10) ;; =\u003e 3 (isqurt 4) ;; =\u003e 2 gcd è¿”å›æœ€å¤§çš„å…¬åˆ†æ¯ lcm è¿”å›æœ€å°çš„å…¬å€æ•° CLè¿˜æä¾›äº†è¡¨ç¤º16è¿›åˆ¶å’Œå…¶ä»–è¿›åˆ¶çš„æ–¹æ³• #xFF ;; =\u003e 255 #2r1010 ;; =\u003e 10 #4r33 ;; =\u003e 15 #8r11 ;; =\u003e 9 #16rFF ;; =\u003e 255 #36rz ;; =\u003e 35 ","date":"2022-10-04","objectID":"/numbers/:1:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"æœ‰ç†æ•° ratio ç±»å‹ç”±ä¸¤ä¸ªbignumsç»„æˆ * (/ (1+ (expt 2 100)) (expt 2 100)) 1267650600228229401496703205377/1267650600228229401496703205376 ratio æ˜¯ rational çš„å­ç±»å‹ ","date":"2022-10-04","objectID":"/numbers/:2:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"æµ®ç‚¹ç±»å‹ CL æä¾›ç²¾åº¦ç”±å°åˆ°å¤§æ’åˆ—çš„short-float, single-float, double-float, and long-float ç±»å‹ å¸¸é‡short-float-epsilon, single-float-epsilon, double-float-epsilon and long-float-epsilon è¡¨ç¤ºäº†æµ®ç‚¹ç±»å‹çš„ç²¾åº¦ ","date":"2022-10-04","objectID":"/numbers/:3:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"floating point literals (æµ®ç‚¹å­—é¢é‡) *read-default-float-format*æ§åˆ¶äº†æµ®ç‚¹æ•°è¯»å–çš„é»˜è®¤ç±»å‹ï¼Œé»˜è®¤æ˜¯single-float,å¦‚æœä½ æƒ³è¯»å…¥åŒç²¾åº¦çš„æµ®ç‚¹æ•°ï¼Œä½ éœ€è¦d0åç¼€ (type-of 1.24) ;; =\u003e SINGLE-FLOAT (type-of 1.24d0) ;; =\u003e DOUBLE-FLOAT Other suffixes are s (short), f (single float), d (double float), l (long float) and e (default; usually single float). é»˜è®¤çš„type æ˜¯å¯ä»¥ä¿®æ”¹çš„ (setq *read-default-float-format* 'double-float) (type-of 1.24) ;; =\u003e DOUBLE-FLOAT warning å’Œå…¶ä»–è¯­è¨€ä¸åŒçš„æ˜¯ï¼Œåœ¨åè¿›åˆ¶åé¢åŠ å°æ•°ç‚¹å¹¶ä¸èƒ½å°†è¯¥æ•°è¡¨ç¤ºæˆæµ®ç‚¹æ•° (type-of 10.) ;; =\u003e (INTEGER 0 4611686018427387903) (type-of 10.0) ;; =\u003e SINGLE-FLOAT ","date":"2022-10-04","objectID":"/numbers/:3:1","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"Float point errors è¿™ä¸ªé”™è¯¯ä¸€èˆ¬å‘ç”Ÿåœ¨å°æ•°ç‚¹æº¢å‡ºçš„æ—¶å€™ (exp 1000) ;; Evaluation aborted on #\u003cFLOATING-POINT-OVERFLOW {10041720B3}\u003e. è¿™ä¸ªé”™è¯¯å¯ä»¥è¢«æ•è·å’Œè§£å†³ï¼Œæˆ–è€…ä»–çš„è¡Œä¸ºå¯ä»¥è¢«æ”¹å˜ (sb-int:set-floating-point-modes :traps '(:INVALID :DIVIDE-BY-ZERO)) (exp 1000) ;; =\u003e #.SB-EXT:SINGLE-FLOAT-POSITIVE-INFINITY (/ 1 (exp 1000)) ;; =\u003e 0.0 ç°åœ¨ä¸ä¼šæŠ¥ä»»ä½•çš„é”™è¯¯ åœ¨sbclä¸­ï¼Œfloat-point çš„æ¨¡å¼å¯ä»¥è¢«æ£€æŸ¥ (sb-int:get-floating-point-modes) ;; =\u003e (:TRAPS (:OVERFLOW :INVALID :DIVIDE-BY-ZERO) :ROUNDING-MODE :NEAREST ;; :CURRENT-EXCEPTIONS NIL :ACCRUED-EXCEPTIONS NIL :FAST-MODE NIL) ","date":"2022-10-04","objectID":"/numbers/:3:2","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"é«˜ç²¾åº¦è®¡ç®— quicklisp ä¸­æœ‰ä¸€ä¸ªcomputable-realsåº“ç”¨äºé«˜ç²¾åº¦è®¡ç®— (ql:quickload :computable-reals) (use-package :computable-reals) (sqrt-r 2) ;; =\u003e +1.41421356237309504880... (sin-r (/r +pi-r+ 2)) ;; =\u003e +1.00000000000000000000... ","date":"2022-10-04","objectID":"/numbers/:3:3","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"å¤æ•° see https://lispcookbook.github.io/cl-cookbook/numbers.html#complex-types ","date":"2022-10-04","objectID":"/numbers/:4:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"Rounding floating-point and rational numbers ceiling,floor,round å’Œ truncate å¯ä»¥å°†floatæ•°è½¬æ¢æˆinteger. see https://lispcookbook.github.io/cl-cookbook/numbers.html#reading-numbers-from-strings ","date":"2022-10-04","objectID":"/numbers/:5:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"æ¯”è¾ƒæ•°å­— è¿™ä¸ªçœŸçš„æ²¡å•¥è¦å°†çš„ï¼Œé™¤äº†lispä½¿ç”¨å‰ç¼€è¡¨è¾¾å¼ã€‚ ç›´æ¥çœ‹common lisp cookbookå§ see https://lispcookbook.github.io/cl-cookbook/numbers.html#comparing-numbers ","date":"2022-10-04","objectID":"/numbers/:6:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"éšæœºæ•° random å‡½æ•°ç”¨æ¥ç”Ÿæˆéšæœºæ•° (random 10) ;; =\u003e 7 (type-of (random 10)) ;; =\u003e (INTEGER 0 4611686018427387903) (type-of (random 10.0)) ;; =\u003e SINGLE-FLOAT (type-of (random 10d0)) ;; =\u003e DOUBLE-FLOAT éšæœºç§å­è¢«å­˜æ”¾åœ¨*random-state*ä¸­ ä½¿ç”¨make-random-stateå¯ä»¥ç”Ÿæˆæ–°çš„éšæœºçŠ¶æ€ å¦‚æœæƒ³æ—¶å€™ç›¸åŒçš„éšæœºé›†åˆå¤šæ¬¡ï¼Œå¯ä»¥ä½¿ç”¨(make-random-state nil) (dotimes (i 3) (let ((*random-state* (make-random-state nil))) (format t \"~a~%\" (loop for i from 0 below 10 collecting (random 10))))) (8 3 9 2 1 8 0 0 4 1) (8 3 9 2 1 8 0 0 4 1) (8 3 9 2 1 8 0 0 4 1) ","date":"2022-10-04","objectID":"/numbers/:7:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"æŒ‰ä½æ“ä½œ è¿™ä¸ªåœ°æ–¹common lisp cookbook å†™çš„å¾ˆå¥½ see https://lispcookbook.github.io/cl-cookbook/numbers.html#bit-wise-operation ","date":"2022-10-04","objectID":"/numbers/:8:0","tags":["common-lisp"],"title":"Common-Lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"æœ‰å…³common lisp çš„å¾ªç¯ï¼Œå’Œä¸€äº›å°æŠ€å·§","date":"2022-10-04","objectID":"/loop_and_iteration/","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Introduction: loop,iterate,for,mapcar,series ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:0","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"loop loop æ˜¯ä¸€ä¸ªå†…ç½®çš„ç”¨æ¥è¿­ä»£çš„å®, å®ƒæœ€ç®€å•çš„å½¢å¼æ˜¯(loop (print â€œhelloâ€)): è¿™ä¸ªè¯­å¥ä¼šæ— é™æ‰“å°\"hello\" ä¸€ä¸ªç®€å•çš„è¿­ä»£Listçš„ä¾‹å­ (loop for x in '(1 2 3) do (print x)) è¿™ä¸ªä¾‹å­ä¼šè¿”å›Nilä½†æ˜¯ä¼šæ‰“å°ä»–åº”è¯¥æ‰“å°çš„ å¦‚æœä½ éœ€è¦å°†ç»“æœæ”¶é›†æˆä¸€ä¸ªlistä½¿ç”¨collect (loop for x in '(1 2 3) collect (* x 10)) loop è¡¨è¾¾å¼æœ‰å››ä¸ªéƒ¨åˆ† è®¾ç½®è¦è¢«è¿­ä»£çš„å˜é‡ ç»“æŸè¿­ä»£çš„æ¡ä»¶è¡¨è¾¾å¼ æ¯æ¬¡è¿­ä»£è¦åšçš„äº‹æƒ… æ¯æ¬¡é€€å‡ºæ—¶è¦åšçš„äº‹æƒ… é™¤æ­¤ä¹‹å¤–,loopè¡¨è¾¾å¼è¿˜èƒ½è¿”å›ä¸€ä¸ªå€¼ æ­£å¸¸æ¥è¯´ï¼Œæˆ‘ä»¬å¾ˆå°‘ä½¿ç”¨æ‰€æœ‰çš„éƒ¨åˆ†ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥éšæ„ç»„åˆä»–ä»¬ ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:1","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"iterate iterate æ˜¯ä¸€ä¸ªå¾ˆæµè¡Œçš„è¿­ä»£å®ï¼Œè¦æ¯”loopæ›´å®¹æ˜“æ‡‚ï¼Œä½†æ˜¯æ‹“å±•æ€§è¦å·®ä¸€äº›ã€‚iterateå¹¶ä¸æ˜¯å†…ç½®çš„ï¼Œè¦å…ˆå¯¼å…¥aã€‚ (ql:quickload \"iterate\") (ues-package :iterate) iterateçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ (iter (for in from 1 to 5) (collect (* i i))) warning å¦‚æœåŒæ—¶ä½¿ç”¨iterate å’Œ loop ä¼šæœ‰å‘½åå†²çª ä½¿ç”¨display-iterate-clauseså¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ (display-iterate-clauses '(for)) ;; FOR PREVIOUS \u0026OPTIONAL INITIALLY BACK Previous value of a variable ;; FOR FIRST THEN Set var on first, and then on subsequent iterations ;; ... ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:2","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"for foræ˜¯ä¸€ä¸ªå¯æ‹“å±•çš„è¿­ä»£å®ï¼Œé€šå¸¸è¦æ¯”loopçŸ­ã€‚ forçš„æœ€å¤§å¥½å¤„å°±æ˜¯ï¼Œå¯ä»¥ç”¨åœ¨ä»»ä½•æ•°æ®ç±»å‹ä¸Š(lists,vectors,hash-tablesâ€¦) (for:for ((x over \u003cyour data structure\u003e)) (print ...)) foræ˜¯ä¸€ä¸ªç¬¬ä¸‰æ–¹åº“ï¼Œéœ€è¦å…ˆquickload (ql:quickload \"for\") ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:3","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"mapæ— åé¢è¿˜æœ‰å¾ˆå¤šmapcar å’Œ mapè¿™æ ·çš„ä¾‹å­ã€‚map æ—è¿˜æœ‰mapcon,mapcan,maplist,mapc å’Œ mapl. (mapcar (lambda (it) (+ it 10)) '(1 2 3)) ;; =\u003e (11 12 13) map æ›´åŠ é€šç”¨ ä»–å¯ä»¥æ¥å—List å’Œ vectors ä½œä¸ºå‚æ•°ï¼Œéœ€è¦åœ¨ç¬¬ä¸€ä¸ªå‚æ•°æŒ‡å®šç»“æœç±»å‹ (map 'vector (lambda (it) (+ it 10)) '(1 2 3)) ;; #(11 12 13) (map 'list (lambda (it) (+ it 10)) #(1 2 3)) ;; (11 12 13) (map 'string (lambda (it) (code-char it)) '#(97 98 99)) ;; \"abc\" ç®€å†™lambdaå‡½æ•° æ˜¯ä¸æ˜¯è§‰å¾—å†™lambdaå¤ªçƒ¦ï¼Œ å…¶å®æœ‰ä¸€äº›åº“å¯ä»¥æä¾›ç®€å†™lambdaå‡½æ•°æ–¹æ³•ä½ å¯ä»¥å»è¿™é‡Œçœ‹çœ‹ç®€å†™lambdaçš„åº“æœ‰å“ªäº›lambda shorthand libraries è¿™é‡Œç»™å‡ºä¸€ä¸ªcl-punchçš„ä¾‹å­ (mapcar ^(* _ 10) '(1 2 3)) ;; =\u003e (10 20 30) ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:4","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"series æœ€å ä½ å¯èƒ½ä¼šå–œæ¬¢series,ä¸€ä¸ªåº“é€šè¿‡ç»“åˆsequences,streams,å’Œloop æ¥æè¿°è‡ªå·±. Series è¡¨è¾¾å¼çœ‹èµ·æ¥å°±åƒæ˜¯åœ¨æ“ä½œåºåˆ—ï¼Œä½†æ˜¯å¯ä»¥è·å¾—ç›¸æ¯”loop æ›´é«˜çš„æ•ˆç‡ã€‚ Seriesç¬¬ä¸€æ¬¡å‡ºç°åœ¨ â€œCommon Lisp the Languageâ€ (collect (mapping ((x (scan-range :from 1 :upto 5))) (* x x))) ;; =\u003e (1 4 9 16 25) Generators The Way I Want Them Generated Library è¿™æ˜¯ä¸€ä¸ªlazy sequences åº“ï¼Œå’Œseriesç±»ä¼¼ï¼Œæ™¯è§‚ä»–å¾ˆå¹´è½»ï¼Œåˆ‡ä¸å®Œå…¨ï¼Œä½†æ˜¯ä»–æœ‰å¾ˆå¤šç°ä»£åŒ–çš„API æ¯”å¦‚take,filter,for,fold å¹¶ä¸”æ˜“ç”¨ range :from 20) ;; #\u003cGTWIWTG::GENERATOR! {1001A90CA3}\u003e (take 4 (range :from 20)) ;; (20 21 22 23) ","date":"2022-10-04","objectID":"/loop_and_iteration/:1:5","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"å°å¦™æ‹› ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:0","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Looping forever,return (loop (print \"hello\")) return ç”¨æ¥è¿”å›ç»“æœ (loop for i in '(1 2 3) when (\u003e i 1) return i) ;; =\u003e 2 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:1","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"å›ºå®šå¾ªç¯næ¬¡ dotimes (dotimes (n 3) (print n)) è¿™é‡Œdotimesåªä¼šè¿”å›Nil æœ‰ä¸¤ç§æ–¹æ³•è¿”å›ä¸€ä¸ªå€¼ è®¾ç½®resultåœ¨lambda list ä¸­ (dotimes (n 3 :done) print(n)) ;; =\u003e ;; 0 ;; 1 ;; 2 ;; :DONE ä½¿ç”¨return (dotimes (i 3) (if (\u003e i 1) (return :early-exit!) (print i))) ;; =\u003e ;; 0 ;; 1 ;; :EARLY-EXIT! loopâ€¦repeat (loop repeat 10 do (format t \"Hello!~%\")) æ‰“å°10æ¬¡hello è¿”å›nil (loop repeat 10 collect (random 10)) ;; =\u003e (5 1 3 5 4 0 7 4 9 1) ä½¿ç”¨collect ä¼šè¿”å›ä¸€ä¸ªlist Series (iterate ((n (scan-range :below 10))) (print n)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:2","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"å¾ªç¯æ— é™æ¬¡ï¼Œåœ¨ä¸€ä¸ªå¾ªç¯listä¸Šå¾ªç¯ å‰é¢æåˆ°äº†ä¸€ä¸ªæ— é™å¾ªç¯çš„æ–¹æ³•ï¼Œä½†æ˜¯æˆ‘ä»¬å¦‚ä½•åœ¨ä¸€ä¸ªlistä¸Šæ— é™å¾ªç¯å‘¢ æˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªå¾ªç¯list (loop with list-a = '(1 2 3) with infinite-list = (setf (cdr (last list-a)) list-a) for item in infinite-list repeat 8 collect item) æ„é€ å¾ªç¯åˆ—è¡¨æœ‰ä¸€ä¸ªéå¸¸ç®€å•çš„æ–¹æ³•ä½¿ç”¨#=è¯­æ³• (defparameter list-a '#1=(1 2 3 . #1#)) (setf print-circle t) list-a å¦‚æœä½ åªæƒ³å†ä¸¤ä¸ªå€¼ä¹‹é—´äº¤æ›¿åœ°å¸¦ï¼Œä½¿ç”¨forâ€¦then (loop repeat 4 for up = t then (not up) do (print up)) T NIL T NIL ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:3","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Iterate çš„for å¾ªç¯ å¯¹äºlist å’Œ vectors: (iter (for item in '(1 2 3)) (print item)) (iter (for i in-vector #(1 2 3)) (print i)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:4","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"åœ¨ä¸€ä¸ªlistä¸Šè¿›è¡Œå¾ªç¯ dolist (dolist (item '(1 2 3)) (print item)) loop ä½¿ç”¨in (loop for x in '(a b c) do (print x)) ;; A ;; B ;; C ;; NIL (loop for x in '(a b c) collect x) ;; (A B C) ä½¿ç”¨on æˆ‘ä»¬åœ¨cdrä¸Šè¿­ä»£ (loop for i on '(1 2 3) do (print i)) ;; (1 2 3) ;; (2 3) ;; (3) mapcar (mapcar (lambda (x) (print (* x 10))) '(1 2 3)) 10 20 30 (10 20 30) mapcar ä¼šå°†lambdaå‡½æ•°çš„è¿”å›å€¼ç»„åˆæˆä¸€ä¸ªListè¿”å› ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:5","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"åœ¨ä¸€ä¸ªvectorä¸Šå¾ªç¯ loop:across (loop for i across #(1 2 3) do (print i)) Series (iterate ((i (scan #(123)))) (print i)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:6","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"åœ¨ä¸€ä¸ªhash-tableä¸Šå¾ªç¯ å…ˆåˆ›å»ºä¸€ä¸ªhasht-table: (defparameter h (make-hash-table)) (setf (gethash 'a h) 1) (setf (gethash 'b h) 2) loop åœ¨keyä¸Šå¾ªç¯ (loop for k being the hash-key of h do(print k)) ;; b ;; a åœ¨valueä¸Šå¾ªç¯ (loop for k being the hash-key using (hash-value v) of h do (format t \"~a ~a~%\" k v)) ;; b 2 ;; a 1 maphash maphash çš„lambdaå‡½æ•°æ—¶ä¸€ä¸ªæ‹¥æœ‰ä¸¤ä¸ªå‚æ•°çš„å‡½æ•°ä¸¤ä¸ªå‚æ•°åˆ†åˆ«æ˜¯key,value (maphash (lambda (key val)) (format t \"key: ~a val: ~a~\u0026\" key val) h) ;; key: A val:1 ;; key: B val:2 ;; NIL dohash dohash æ˜¯ç¬¬ä¸‰æ–¹åº“trivial-doçš„ä¸€ä¸ªmacro,ç±»ä¼¼dolist (dohash (key value h) (format t \"key: ~A, value: ~A ~%\" key value)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:7","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"å¹¶è¡Œçš„åœ¨ä¸¤ä¸ªlistä¸Šå¾ªç¯ loop (loop for x in '(a b c) for y in '(1 2 3) collect (list x y)) ;; ((A 1) (B 2) (C 3)) å¦‚æœæƒ³è¿”å›ä¸€ä¸ªå¹³æ•´è¿‡çš„list(flat list),ä½¿ç”¨nconcing æ›¿ä»£collect: (loop for x in '(a b c) for y in '(1 2 3) nconcing (list x y)) ;; (A 1 B 2 C 3) å¦‚æœä¸¤ä¸ªlistçš„é•¿åº¦ä¸åŒï¼Œä¼šåœ¨çŸ­çš„ç»“æŸçš„æ—¶å€™é€€å‡ºå¾ªç¯ (loop for x in '(a b c) for y in '(1 2 3 4 5) collect (list x y)) ;; ((A 1) (B 2) (C 3)) æˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ªå¤§çš„listä¸Šå¾ªç¯ï¼Œå¹¶ä¸”æ‰‹åŠ¨çš„é€šè¿‡indexè®¿é—®å°ä¸€ç‚¹çš„Listçš„å…ƒç´ ,ä½†æ˜¯è¿™æ ·çš„æ•ˆç‡æ˜¯éå¸¸ä½çš„ï¼Œæˆ‘ä»¬å¯ä»¥è®©loopè‡ªåŠ¨æ‹“å±•çŸ­çš„list (loop for y in '(1 2 3 4 5) for x-list = '(a b c) then (cdr x-list) for x = (or (car x-list) 'z) collect (list x y)) ;; ((A 1) (B 2) (C 3) (Z 4) (Z 5)) åœ¨è¿™ä¸ªä»£ç æ®µä¸­ï¼Œfor â€¦ = â€¦ then (cdr â€¦) åœ¨æ¯ä¸€æ¬¡çš„å¾ªç¯ä¸­éƒ½ä¼šç¼©çŸ­ä¸€æ¬¡list. ä»–çš„å€¼ä¸€å¼€å§‹æ˜¯â€™(a b c) ç„¶åæ˜¯ â€˜(b c) ç„¶å â€˜(c) æœ€å nil mapcar (mapcar (lambda (x y) (list x y)) '(a b c) '(1 2 3)) ;; ((A 1) (B 2) (C 3)) æˆ–è€…æ›´ç®€å•: (mapcar #'list '(a b c) '(1 2 3)) ;; ((A 1) (B 2) (C 3)) è¿”å›ä¸€ä¸ªflat list: (mapcan (lambda (x y) (list x y)) '(a b c)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:8","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"åµŒå¥—å¾ªç¯(Nested loops) loop (loop for x from 1 to 3 collect (loop for y from 1 to x collect y)) ;;((1) (1 2) (1 2 3)) å¦‚æœè¦è¿”å›ä¸€ä¸ªflat list,ä½¿ç”¨nconcing æ›¿æ¢ç¬¬ä¸€ä¸ªcollect ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:9","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"è®¡ç®—ä¸€ä¸ªä¸­é—´å€¼ ä½¿ç”¨= ä¸ forç»“åˆ (loop for x from 1 to 3 for y = (* x 10) collect y) ;; (10 20 30) å¦‚æœä½¿ç”¨with,é‚£ä¹ˆåªä¼šè®¡ç®—ä¸€æ¬¡ (loop for x from 1 to 3 for y = (* x 10) with z = x collect (list x y z)) ;; ((1 10 1) (2 20 1) (3 30 1)) HyperSpec å¯¹ with çš„å®šä¹‰æ—¶è¿™æ ·çš„ with-clause::= with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}* æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å†=å‰é¢æŒ‡æ˜ç±»å‹ å¹¶ä¸”ç”¨and ä¸²èµ·æ¥ (loop for x from 1 to 3 for y integer = (* x 10) with z integer = x collect (list x y z)) (loop for x upto 3 with foo = :foo and bar = :bar collect list (x foo bar)) æˆ‘ä»¬ä¹Ÿå¯ä»¥ç»™for ä¸€ä¸ª then è®©ä»–æ²¡æ¬¡è¿­ä»£éƒ½æ‰§è¡Œä¸€æ¬¡ (loop repeat 3 for intermediate = 10 then (incf intermediate) do (print intermediate)) 10 11 12 è¿™é‡Œæ˜¯ä¸€ä¸ªåœ¨boolå€¼ä¹‹é—´ä¸æ–­åˆ‡æ¢çš„ä¾‹å­ (loop repeat 4 for up = t then (not up) do (print up)) T NIL T NIL ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:10","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"å¾ªç¯è®¡æ•°å™¨ loop å¯¹ä¸€ä¸ªListè¿›è¡Œè¿­ä»£çš„åŒæ—¶è¿›è¡Œè®¡æ•°ã€‚listçš„é•¿åº¦å†³å®šäº†è¿­ä»£åˆé€‚ç»“æŸã€‚ (loop for x in '(a b c d e) for y from 1 when (\u003e y 1) do (format t \", \") do (format t \"~A\" x)) A,B,C,D,E NIL ä¹Ÿå¯ä»¥ç”¨ifè¯­å¥ (loop for x in '(a b c d e) for y from 1 if (\u003e y 1) do (format t \", ~A\" x) else do (format t \"~A\" x)) A,B,C,D,E NIL ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:11","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"å‡é™åºï¼Œlimits loop å‡åº fromâ€¦ toâ€¦: include the last (loop for i from 0 to 10 do (print i)) ;; 0 1 2 3 4 5 6 7 8 9 10 fromâ€¦ belowâ€¦: not include the last (loop for i from 0 below 10 do (print i)) ;; 0 1 2 3 4 5 6 7 8 9 é™åº fromâ€¦ downtoâ€¦: include (loop for i from 10 downto 0 do (print i)) ;; 10 9 8 7 6 5 4 3 2 1 0 fromâ€¦ aboveâ€¦: not include (loop for i from 10 above 0 do (print i)) ;; 10 9 8 7 6 5 4 3 2 1 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:12","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"æ­¥é•¿ loop loop ä½¿ç”¨by: (loop for i from 1 to 10 by 2 do (print i)) å¦‚æœbyåé¢è·Ÿçš„æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼é‚£ä¹ˆåªä¼šæ‰§è¡Œä¸€æ¬¡ ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:13","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Loop å’Œæ¡ä»¶ loop ä½¿ç”¨if, else å’Œ finally: (loop repeat 10 for x = (random 100) if (evenp x) collect x into evens else collect x into odds finally (return (values evens odds))) (42 82 24 92 92) (55 89 59 13 49) å¦‚æœè¦ç»“åˆå¤šä¸ªè¯­å¥ï¼Œé‚£ä¹ˆifçš„bodyéœ€è¦andå…³é”®å­—(and do, and count) (loop repeat 10 for x = (random 100) if (evenp x) collect x into evens and do (format t \"~a is even!~%\" x) else collect x into odds and count t into n-odds finally (return (values evens odds n-odds))) 46 is even! 8 is even! 76 is even! 58 is even! 0 is even! (46 8 76 58 0) (7 45 43 15 69) 5 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:14","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"ç”¨ä¸€ä¸ªè¯­å¥ä½œä¸ºloopçš„å¼€å§‹(initially) (loop initially (format t \"~a \" 'loop-begin) for x below 3 do (format t \"~a \" x)) ;;LOOP-BEGIN 0 1 2 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:15","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"ç”¨ä¸€ä¸ªtestï¼ˆuntil,whileï¼‰æ¥ç»“æŸå¾ªç¯ loop until (loop for x in '(1 2 3 4 5) until (\u003e x 3) collect x) ;; (1 2 3) while (loop for x in '(1 2 3 4 5) while (\u003c x 4) collect x) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:16","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"å¾ªç¯å‘½å å’Œ æå‰é€€å‡º loop loop named foo è¯­æ³•å…è®¸ä½ åˆ›å»ºä¸€ä¸ªèƒ½å¤Ÿæå‰é€€å‡ºçš„å¾ªç¯ã€‚ä½¿ç”¨return-form,å³å¯é€€å‡ºå·²ç»å‘½åçš„å¾ªç¯ï¼Œç”šè‡³å¯ä»¥é€€å‡ºåµŒå¥—çš„å¾ªç¯ã€‚ (loop named loop-1 for x from 0 to 10 by 2 do (loop for y from 0 to 100 by (1+ (random 3)) when (\u003c x y) do (return-from loop-1 (values x y)))) 0 2 æœ‰çš„æ—¶å€™ä½ æƒ³è¦æå‰é€€å‡ºï¼Œä½†æ˜¯ä¸€å®šè¦æ‰§è¡Œä¸€äº›è¯­å¥ï¼Œä½ å¯ä»¥ä½¿ç”¨loop-finish (loop for x from 0 to 100 do (print x) when (\u003e= x 3) return x finally (print :done)) ;; 0 ;; 1 ;; 2 ;; 3 ;; 3 (loop for x from 0 to 100 do (print x) when (\u003e= x 3) do (loop-finish) finally (print :done) (return x)) ;; 0 ;; 1 ;; 2 ;; 3 ;; :DONE ;; 3 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:17","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Loop thereis never always thereis (loop for x in '(foo 2) thereis (numberp x)) T never (loop for x in '(foo 2) never (numberp x)) NIL always (loop for x in '(foo 2) always (numberp x)) NIL ä»–ä»¬å’Œsome,notany,everyå¯¹åº”ï¼š (some #'numberp '(foo 2)) (notany #'numberp '(foo 2)) (every #'numberp '(foo 2)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:18","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Count (loop for i from 1 to 3 count (oddp i)) ;; 2 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:19","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Summation (loop for i from 1 to 3 sum (* i i )) ;; 14 å°†æ±‚å’Œçš„ç»“æœæ”¾å…¥å˜é‡ä¸­ (loop for i from 1 to 3 sum (* i i) into total do (print i) finally (print total)) 1 2 3 14 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:20","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"Max and Min (loop for i from 1 to 3 maximize (mod i 3)) ;; 2 ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:21","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"è§£æ„, å¯¹ list è¿›è¡Œdotted pairs aka æ¨¡å¼åŒ¹é… (loop for (a b) in '((x 1) (y 2) (z 3)) collect (list b a)) ;; ((1 X) (2 Y) (3 Z)) (loop for (x . y) in '((1 . a) (2 . b) (3 . c)) collect y) ;; (A B C) ä½¿ç”¨nilå¿½ç•¥ (loop for (a nil) in '((x 1) (y 2) (z 3)) collect a) ;; (X Y Z) ä¸¤ä¸ªä¸¤ä¸ªçš„éå† (loop for (key value) on '(a 2 b 2 c 3) by #'cddr collect (list key (* 2 value))) ;;((A 2) (B 4) (C 6)) ","date":"2022-10-04","objectID":"/loop_and_iteration/:2:22","tags":["common-lisp"],"title":"Common-Lisp loop and iteration","uri":"/loop_and_iteration/"},{"categories":["lisp"],"content":"common lisp å®šä¹‰ å’Œ è°ƒç”¨","date":"2022-10-04","objectID":"/function/","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"å®šä¹‰ä¸€ä¸ªå‡½æ•° å¯ä»¥ä½¿ç”¨defunc å…³é”®å­—å®šä¹‰ä¸€ä¸ªæœ‰åå­—çš„å‡½æ•°: (defun \u003cname\u003e (list of arguments) \"docstring\" (function body)) ç”¨å­¦è¯­è¨€å¿…å­¦çš„æ‰“å°hello world! æ¥ä¸¾ä¾‹ (defun hello-world () ;; define a function named hello-world (format t \"hello world!\")) ;; print hello world! and return nil è°ƒç”¨ (hello-world) ;; \"hello world!\" \u003c-- output printed by `foramt' function ;; nil \u003c-- return value return by format why docstring common lisp å¯ä»¥å†å‡½æ•°ä½“å¼€å§‹ä¹‹å‰ æ”¹å†™ docstring ä¸ºå‡½æ•°æ·»åŠ æ–‡æ¡£ lispä¹ æƒ¯ä½¿ç”¨è¿™ç§æ–¹å¼æ¥ç»™å‡½æ•°å†™ä¸€äº›å¸®åŠ©æ–‡æ¡£ï¼Œç±»ä¼¼readmeè¿™ç§è‡ªè¿°æ–‡ä»¶ docstring æ˜¯å¯¹å‡½æ•°çš„æè¿° about the return value common lisp çš„å‡½æ•°é»˜è®¤ä¼šreturn æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ å†è¿™é‡Œå°±æ˜¯ (format t \"hello world!\") çš„è¿”å›å€¼ä¹Ÿå°±æ˜¯nil ","date":"2022-10-04","objectID":"/function/:1:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"å‡½æ•°è¿”å›å€¼ ","date":"2022-10-04","objectID":"/function/:2:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"required arguments å‡½æ•°çš„å¿…è¦å‚æ•° å…ˆçœ‹è¿™ä¸ªå‡½æ•°å®šä¹‰ (defun hello (name) ;;name å°±æ˜¯å¿…è¦å‚æ•° \"say hello to `name'.\" (format t \"hello ~a !~\u0026\" name) ;; è¿™é‡Œç›´æ¥ä½¿ç”¨nameå‚æ•° ) ç›´æ¥è°ƒç”¨ (hello \"me\") ;; hello me! \u003c-- printed by `format' ;; Nil \u003c-- return value format çš„æ ¼å¼æ§åˆ¶ç¬¦ common lisp format ç±»ä¼¼cè¯­è¨€çš„printfã€‚ä½†æ˜¯common lispçš„æ ¼å¼æ§åˆ¶ç¬¦æ˜¯ä»¥ ~ ä¸ºå¼€å¤´çš„ è€Œä¸”å­—ç¬¦çš„æ„ä¹‰ä¹Ÿä¸åŒ æ¯”å¦‚Cè¯­è¨€ä¸­ \\n ä»£è¡¨æ¢è¡Œ è€Œformatä¸­ ~\u0026å°±ä»£è¡¨æ¢è¡Œç¬¦ã€‚ ","date":"2022-10-04","objectID":"/function/:2:1","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"Optional arguments å‡½æ•°çš„å¯é€‰å‚æ•°: \u0026optional å¯é€‰å‚æ•°æ˜¯å®šä¹‰å† \u0026optional å…³é”®å­—åé¢ã€‚å¹¶ä¸”è¦ä¿æŒæœ‰åºï¼Œå¿…é¡»ä¸€ä¸ªè·Ÿç€ä¸€ä¸ªå‡ºç°ã€‚è¿™é‡Œæœ‰ç‚¹æ‡µé€¼å§ã€‚åºŸè¯ä¸å¤šè¯´ï¼Œç›´æ¥ä¸Šä¾‹å­ã€‚ (defun hello (name \u0026optional age gender) (format t \"name: ~a age ~a gender ~a ~\u0026\" name age gender) ) è¿™æ¡å‡½æ•°å®šä¹‰ä¸­ name æ˜¯å¿…è¦å‡½æ•°ï¼Œage å’Œ genderæ˜¯å¯é€‰å‚æ•°ã€‚nameæ˜¯å¿…å¡«çš„ï¼Œå°±æ˜¯ä½ åœ¨è°ƒç”¨è¿™ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œnameæ˜¯å¿…é¡»çš„ã€‚è€Œ age å’Œ gender ä½ å¯ä»¥é€‰æ‹©æä¾›æˆ–è€…çœç•¥ã€‚ä½†æ˜¯å½“ä½ æƒ³æä¾› gender è¿™ä¸ªå‚æ•°çš„æ—¶å€™ï¼Œä½ å¿…é¡»ä¹Ÿè¦æä¾› age è¿™ä¸ªå‚æ•°ã€‚ä¸ä¸¥è°¨çš„è¯´ï¼Œä¸€ä¸ªå¯é€‰å‚æ•°è¦æƒ³å‡ºç°ï¼Œå°±å¿…é¡»å»ºç«‹åœ¨ä»–å‰é¢çš„ä¸€ä¸ªå¯å˜å‚æ•°å·²ç»æä¾›çš„æƒ…å†µä¸‹ã€‚ (hello \"me\") ;; supply required argument name. avoid optional arguments age and gender (hello \"me\" 7) ;; supply required argument name, optional argument age and void gender (hello \"me\" 7 \"female\") ;; supply name age and gender (hello \"me\" \"female\") ;; wrong for practiceã€‚ You may use hello in this way grammaly but female won`t supplied to the gender arguments å¦‚æœå¯é€‰å‚æ•°å†è°ƒç”¨çš„æ—¶å€™æ²¡æœ‰ç»‘å®šå€¼ é‚£å€¼å°±ä¸º nil (hello \"me\") ;; name: me age NIL gender NIL ","date":"2022-10-04","objectID":"/function/:2:2","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"Named paramenters å…·åå‚æ•°: \u0026key æœ‰æ—¶å€™è®°ä½å‚æ•°çš„é¡ºåºéå¸¸ä¸æ–¹ä¾¿ï¼Œlisp æä¾›äº†ä½¿ç”¨å‚æ•°åæ¥æä¾›å‚æ•°çš„æ–¹å¼. åœ¨\u0026key åé¢è·Ÿä¸Šå‚æ•°åå³å¯å®šä¹‰å…·åå‚æ•° (defun hello (name \u0026key happy) \"if `happy' is `t,print a smiley\" (format t \"hello ~a\" name) (when happy (format t \":) ~\u0026\"))) è°ƒç”¨çš„æ—¶å€™ç”¨ :name value è¿™æ ·çš„å½¢å¼æŒ‡å®šå‚æ•°,å®šä¹‰äº†å…·åå‚æ•°ä½†æ˜¯è°ƒç”¨çš„æ—¶å€™ä¸æŒ‡å®švalue é‚£å…·åå‚æ•°çš„value ä¼šä¸ºnil (hello \"me\") ;; ignore the happy paramenter,happy will be set to nil defaultly (hello \"me\" :happy t) ;; bind happy to t (hello \"me\" :happy nil) ;; bind happy to nil (hello \"me\" :happy) ;; wrong! this form is definitely wrong lispä¸­çš„ t and nil lisp ä¸­ç”¨ t ä»£è¡¨true nil ä»£è¡¨false å’Œ ç©º æœ‰å…³å‡½æ•°å‚æ•°æ•°é‡çš„æƒ³æ³• å…·åå‚æ•°æ˜¯ä¸ºäº†è§£å†³è®°ä½å‚æ•°çš„é¡ºåºä¸æ–¹ä¾¿è€Œè¯ç”Ÿçš„ï¼Œä½†æ˜¯å¦‚æœå‡½æ•°çš„å‚æ•°è¿‡å¤šçš„è¯ï¼Œä¼šå¯¼è‡´å‡½æ•°çš„è¡Œä¸ºä¼šå˜å¾—å¤æ‚å¤šæ ·ã€‚clean code ä¸­å¹¶ä¸é¼“åŠ±å‡½æ•°å‚æ•°çš„æ•°é‡è¶…è¿‡3ä¸ª ä½ ä¹Ÿå¯ä»¥å®šä¹‰å¤šä¸ªå…·åå‚æ•° (defun hello (name \u0026key happy lisper cookbook-contributor-p) ...) ä½¿ç”¨ç¤ºä¾‹ (hello \"me\" :lisper t) (hello \"me\" :lisper t :happy t) (hello \"me\" :cookbook-contributor-p t :happy t) keys can be variable ç±»ä¼¼ :happy è¿™æ ·çš„ç¬¦å·å…¶å®å¯ä»¥ä½œä¸ºä¸€ä¸ªå˜é‡çš„å€¼å°±åƒè¿™æ ·ã€‚ (let ((key :happy) ;; bind :happy to key (val t)) ;; bind t to val (hello \"me\" key val)) ;; quote key and val let å¯ä»¥å£°æ˜ä¸€äº›åªèƒ½åœ¨letä»£ç å¿«ä¸­ä½¿ç”¨çš„å˜é‡è¿™ä¸ªåé¢ä¼šç»†è¯´ ","date":"2022-10-04","objectID":"/function/:2:3","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"æ··åˆå¯é€‰å’Œå…·åå‚æ•° å…ˆçœ‹ä¸€ä¸ªä¾‹å­ (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) å¦‚æœä½ ç›´æ¥è¿™ä¹ˆå®šä¹‰å‡½æ•°ï¼Œlispçš„è§£é‡Šå™¨ä¼šæŠ¥warning ; in: DEFUN HELLO ; (SB-INT:NAMED-LAMBDA HELLO ; (\u0026OPTIONAL NAME \u0026KEY HAPPY) ; (BLOCK HELLO (FORMAT T \"hello ~a \" NAME) (WHEN HAPPY (FORMAT T \":)~\u0026\")))) ; ; caught STYLE-WARNING: ; \u0026OPTIONAL and \u0026KEY found in the same lambda list: (\u0026OPTIONAL (NAME \"John\") \u0026KEY ; HAPPY) ; ; compilation unit finished ; caught 1 STYLE-WARNING condition è™½ç„¶ä¹Ÿèƒ½è°ƒç”¨ (hello \"me\" :happy t) ;; hello me :) ;;nil è¿™ç§æƒ…å†µä¸èƒ½ç›´æ¥è·³è¿‡optionalçš„å‚æ•° ç›´æ¥æŒ‡å®škey å‚æ•° è¿˜æ˜¯ä¸Šé¢è¿™ä¸ªå‡½æ•° (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) å¦‚æœä½ å°è¯•çœç•¥name ç›´æ¥æŒ‡å®š :happy å°±ä¼šæŠ¥é”™ (hello :happy t) ;; odd number of \u0026KEY arguments å› ä¸ºoptional çš„å‚æ•°å¿…é¡»æ˜¯æœ‰åºå‡ºç°çš„ï¼Œå¦‚æœå‰é¢çš„å‚æ•°æœªå‡ºç°ï¼Œå°±ä¸èƒ½ç›´æ¥æŒ‡å®šåé¢çš„å‚æ•°ã€‚ä½†æ˜¯å½“æŒ‡å®šå®Œæ‰€æœ‰çš„optionalå‚æ•°åï¼Œä½ å°±å¯ä»¥æŒ‰ç…§keyå‚æ•°çš„è§„åˆ™å»æŒ‡å®škeyå‚æ•° çœ‹è¿™ä¸ªå‡½æ•°å®šä¹‰(ä¸€ä¸ªä¸æ°å½“çš„ä¾‹å­) (defun hello (\u0026optional name \u0026key happy age) (format t \"hello ~a \" name) (when happy (format t \":)~\u0026\"))) (hello \"me\" :age 1) è¿™é‡Œç›´æ¥å¿½ç•¥happy å…³é”®å­— æŒ‡å®šage ","date":"2022-10-04","objectID":"/function/:2:4","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"key parameters çš„é»˜è®¤å€¼ å¯ä»¥ä½¿ç”¨ä¸€å¯¹åŒ…å«é”®å€¼çš„æ‹¬å·æ¥æŒ‡å®šé»˜è®¤å€¼ (happy t) (defun hello (name \u0026key (happy t))) è¿™æ ·happy çš„é»˜è®¤å€¼å°±è¢«è®¾æˆäº†t ","date":"2022-10-04","objectID":"/function/:2:5","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"å¦‚ä½•ç¡®å®šå…·åå‚æ•°(key parameter) æ˜¯å¦è¢«æŒ‡å®š å‰é¢æœ‰æåˆ°è¿‡ï¼Œå…·åå‚æ•°å¦‚æœä¸æŒ‡å®šï¼Œå°±ä¼šé»˜è®¤ä¸ºNILã€‚é‚£é—®é¢˜å°±æ˜¯ï¼Œå¦‚ä½•çŸ¥é“å…·åå‚æ•°çš„è°ƒç”¨è€…æ˜¯å¦æ•…æ„æŒ‡å®šè¿™ä¸ªå‚æ•°ä¸ºNILå‘¢ã€‚å› ä¸ºå‚æ•°ä¸ºNILå¯èƒ½ä¼šæœ‰è‡ªå·±ç‰¹æ®Šçš„æ„ä¹‰ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­æ˜¯å¦æ˜¯è°ƒç”¨è€…æ•…æ„è®¾ä¸ºNIL. æˆ‘ä»¬ä½¿ç”¨äºŒå…ƒç»„ tuple è®¾ç½®é»˜è®¤å€¼ \u0026key (:happy t) æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‰å…ƒç»„ tripleæ¥è§£å†³å‚æ•°çŸ¥å¦è¢«æ•…æ„æŒ‡å®šä¸ºNIL \u0026key (:happy t happy-p) (defun hello (name \u0026key (happy nil happy-p)) (format t \"Key supplied? ~a~\u0026\" happy-p) (format t \"hello ~a \" name) (when happy-p (if happy (format t \":)\") (format t \":(\")))) (hello \"me\" :happy t) ;; Ky supplied? T ;; hllo me :) ä»è¿”å›çš„ç»“æœå¯ä»¥çœ‹åˆ° å¦‚æœæŒ‡å®šäº†:happy é‚£ä¹ˆhappy-p ä¼šè¢«è‡ªåŠ¨è®¾ç½®ä¸º t å³è¢«æŒ‡å®šçŠ¶æ€ lisp ä¸­æœ‰å…³æ–­è¨€å‘½åçš„convenstion(ä¼ ç»Ÿ) lisp ä¸­ä¹ æƒ¯å¯¹ç”¨æ¥åšåˆ¤æ–­çš„å‡½æ•°æˆ–å˜é‡åé¢åŠ ä¸€ä¸ªp æ¯”å¦‚ stringp :ç”¨æ¥åˆ¤æ–­æ˜¯å¦ä¸ºå­—ç¬¦ä¸²çš„å‡½æ•° listp : ç”¨æ¥åˆ¤æ–­æ˜¯å¦ä¸ºåˆ—è¡¨ç±»å‹çš„å‡½æ•° pæ˜¯predicateçš„ç¼©å†™ æ„ä¸ºæ–­è¨€ ","date":"2022-10-04","objectID":"/function/:2:6","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"å¯å˜æ•°é‡å‚æ•°: \u0026rest çš„æ—¶å€™ï¼Œä½ ä¼šæƒ³è¦å®šä¹‰ä¸€äº›å‡½æ•°ï¼Œå¯ä»¥æ¥å—å¾ˆå¤šä¸ªå‚æ•°ï¼Œä½†æ˜¯å…·ä½“å¤šå°‘ä¸ªï¼Œä½ ä¹Ÿä¸æ¸…æ¥šã€‚æ¯”å¦‚ä½ æƒ³å®šä¹‰ä¸ªå‡½æ•°æŠŠæ‰€æœ‰çš„å‚æ•°éƒ½ç›¸åŠ è¿›è¡Œæ±‚å’Œã€‚ (defun sum (arg1 arg2 arg3 ... to arg100....)) è¿™æ ·å¤ªç´¯äº†ï¼Œä½ ä¸å¯èƒ½ä¸€ä¸ªä¸€ä¸ªçš„æ•²ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ · (defun hello (\u0026rest numbers) (apply #'+ numbers)) è°ƒç”¨ (hello 1 2 3 4) ;; 10 \u003c-- returned by hello apply å‡½æ•° apply çš„ç¬¬ä¸€ä¸ªå‚æ•°æ¥æ”¶ä¸€ä¸ªæ‹¥æœ‰ä¸¤ä¸ªå‚æ•°çš„å›è°ƒå‡½æ•° ç¬¬äºŒä¸ªå‚æ•°æ¥å—ä¸€ä¸ªåˆ—è¡¨ï¼ˆè¿™é‡Œä¸ºäº†æ–¹ä¾¿ç†è§£ä»£ç è¿™ä¹ˆè¯´ï¼Œå…¶å®è¿™æ˜¯ä¸ä¸¥è°¨çš„ï¼‰ å°±åƒè¿™æ · (apply #'func '(arg1 arg2 arg3)) arg1 arg2 arg3 å°†ä¼šä½œä¸ºfunc çš„å‚æ•°ä¼ é€’ç»™func å¹¶è¿›è¡Œè¿ç®—. ä¹Ÿå°±æ˜¯è¯´ applyçš„æ“ä½œæ˜¯å°† list å±•å¼€æˆä¸€ä¸ªä¸ªå‚æ•°å¹¶ä¼ ç»™funcã€‚ æ¯”å¦‚(apply #+ â€˜(1 2 3 4)) å’Œ (+ 1 2 3 4) æ˜¯ç­‰ä»·çš„ã€‚ åˆ—è¡¨ â€˜(1 2 3 4) è¢«å±•å¼€æˆ 1 2 3 4 ä¼ é€’ç»™äº†func ","date":"2022-10-04","objectID":"/function/:2:7","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"å…è®¸é¢å¤–çš„key: \u0026allow-other-keys å…ˆçœ‹ä¸‹ä¸‹é¢çš„ä¾‹å­ (defun hello (name \u0026key happy) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; Error: unknown keyword argument å†çœ‹çœ‹è¿™ä¸ª (defun hello (name \u0026key happy \u0026allow-other-keys) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; hello me è¿™é‡Œæˆ‘ä»¬å¹¶æ²¡æœ‰ç»™å‡º :lisper è¿™ä¸ªå…³é”®å­—çš„å®šä¹‰ ä½†æ˜¯å‡½æ•°ä»ç„¶å…è®¸æˆ‘ä»¬è¿™ä¹ˆè°ƒç”¨è€Œä¸æ˜¯ç›´æ¥æŠ¥é”™ ã€Šcommon lisp cook bookã€‹ ä¸­ç»™å‡ºè¿‡ä¸€ä¸ªå®ç”¨çš„æ¡ˆä¾‹ (defun open-supersede (f \u0026rest other-keys \u0026key \u0026allow-other-keys) (print other-keys) (apply #'open f :if-exists :supersede other-keys)) è¿™ä¸ªå‡½æ•°çš„å®šä¹‰è¦æ±‚å¿…é¡»æœ‰ä¸€ä¸ªfå‚æ•°ï¼Œä»¥åŠä»»æ„æ•°é‡çš„other-keys å…¶å® \u0026key ä»¥åŠ\u0026allow-other-keys è¢«å¿½ç•¥äº†åªåšæç¤ºç”¨ï¼ˆå‘Šè¯‰è°ƒç”¨è€…å¯ä»¥æ¥å—å…¶ä»–å…·åå‚æ•°ï¼‰ã€‚å› ä¸ºæœ‰\u0026rest è¿™ä¸ªæ ‡å¿—ç¬¦åœ¨ é™¤äº†få¤– å‚æ•°éƒ½ä¼šä¼ åˆ°other-keysé‡Œé¢ã€‚æ‰€ä»¥\u0026key \u0026allow-other-keyså°±å¤±å»äº†è¯­æ³•ä¸Šçš„æ„ä¹‰ã€‚èµ·ç åœ¨ç¼–è¯‘å™¨çœ‹æ¥ï¼Œä»–æ˜¯æ— æ„ä¹‰çš„ã€‚ ä½†æ˜¯å¦‚æœä½ ä¸æŒ‰ç…§å‡½æ•°ç­¾åæŒ‡ç¤ºçš„æ–¹å¼è°ƒç”¨ï¼Œå†…å±‚çš„å‡½æ•°å°±å¾ˆæœ‰å¯èƒ½æŠ¥é”™ï¼Œæ‰€ä»¥å³ä½¿\u0026key \u0026allow-other-keysè¢«ç¼–è¯‘å™¨å¿½ç•¥(è¿™ç§å‡½æ•°åœ¨å®šä¹‰æ—¶ï¼Œç”šè‡³å¯ä»¥å¿½ç•¥\u0026key \u0026allow-other-keyså…³é”®å­—ï¼ŒåŠŸèƒ½å¹¶ä¸ä¼šå› ä¸ºæ²¡æœ‰ä»–ä»¬è€Œå—å½±å“)ï¼Œä½ ä¹Ÿåº”è¯¥æŒ‰ç…§ç­¾åå»è°ƒç”¨å‡½æ•°ã€‚å› ä¸ºå†…å±‚çš„å‡½æ•°éœ€è¦ä¾èµ–è¿™ä¸ªç­¾åè§„åˆ™ã€‚ æ¥çœ‹è¿™ä¸ªå‡½æ•°è°ƒç”¨ (open-supersede \"test.log\" :if-does-not-exist :create) ;;(:IF-DOES-NOT-EXIST :CREATE) \u003c\u003c-- ç”±(print other-keys)æ‰“å° å¯ä»¥çœ‹åˆ°å…·åå‚æ•°éƒ½è¢«ä¼ ç»™äº†\u0026rest å¿…è¦çš„å‡½æ•°æ–‡æ¡£ åœ¨å†™è¿™ç§å‡½æ•°çš„æ—¶å€™ï¼Œåº”è¯¥å†™ä¸Šdocstring å› ä¸ºå‡½æ•°ç­¾åå·²ç»ä¸èƒ½å¾ˆå¥½çš„æè¿°å‡½æ•°äº†ï¼Œæˆ‘ä»¬åº”è¯¥åŠ ä¸Šdocstringæ¥æè¿°å‡½æ•°ï¼Œä¸è¦è®©è°ƒç”¨è€…ç–‘æƒ‘ã€‚ ","date":"2022-10-04","objectID":"/function/:2:8","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"å‡½æ•°è¿”å›å€¼ common lisp çš„è¿”å›å€¼é»˜è®¤æ˜¯å‡½æ•°çš„æœ€åä¸€ä¸ªæ‰§è¡Œè¯­å¥ ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨(return-from \u003cfunction name\u003e \u003cname\u003e \u003cvalue\u003e) æ˜¾ç¤ºçš„ä»å…·ä½“å‡½æ•°å†…è¿”å›ã€‚æ³¨æ„è¿™é‡Œæ˜¯ç›´æ¥ä»\u003cfunction name\u003e æŒ‡å®šçš„å‡½æ•°ä¸­è¿”å›,ä¸ä»…ä»…æ˜¯ä»å½“å‰è¿è¡Œçš„å‡½æ•°ä¸­è¿”å›ï¼Œä¹Ÿæœ‰å¯èƒ½ç›´æ¥ä»å¤–å±‚å‡½æ•°è¿”å›ã€‚ å¤šæ•°æ—¶å€™æˆ‘ä»¬å¹¶ä¸ä½¿ç”¨return-from ","date":"2022-10-04","objectID":"/function/:3:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"å¤šè¿”å›å€¼ï¼švalues,multiple-value-bind and nth-value æˆ‘ä»¬ä½¿ç”¨valuesæ¥æ„é€ ä¸€ä¸ªå¤šè¿”å›å€¼ (defun foo (a b c) (values a b c)) å› ä¸ºå‡½æ•°çš„æœ€åä¸€æ¡è¯­å¥çš„ç»“æœä¼šè¢«è¿”å›ï¼Œæ‰€ä»¥valuesæ„é€ çš„å¤šè¿”å›å€¼ä¼šè¢«ç›´æ¥è¿”å›ç»™ä¸Šå±‚ (setf res (foo :a :b :c)) ;; :A \u003c\u003c-- res ä¸º:A è¿™é‡Œresä¸º:Aè€Œä¸æ˜¯ :A :B :C æ˜¯å› ä¸ºè¿™é‡Œçš„è¿”å›å€¼æ¥å—è€…åªæœ‰res æ‰€ä»¥åªæœ‰ç¬¬ä¸€ä¸ª:A è¢«æ¥å— :B :C éƒ½è¢«è‡ªåŠ¨å¿½ç•¥æ‰äº†. æ¥å—å¤šè¿”å›å€¼å¾—æ–¹æ³•ä¸ºmultiple-value-bindã€‚ multiple-value-bind ä½¿ç”¨multiple-value-bindæ¥è§£æ„å¤šè¿”å›å€¼ã€‚ (multiple-value-bind (res1 res2 res3) (foo :a :b :c) (format t \"res1 is ~a, res2 is ~a, res3 is ~a ~\u0026\" res1 res2 res3)) ;res1 is A, res2 is B res3 is C ;nil é€šç”¨æ ¼å¼ (multiple-value-bind (var-1 .. var-n) expr body) multiple-value-bindç»‘å®šçš„å˜é‡æ˜¯å±€éƒ¨çš„ ä½¿ç”¨multiple-value-bindçš„å˜é‡å†å®ƒå¤–é¢æ˜¯è®¿é—®ä¸åˆ°çš„, ä¹Ÿå°±æ˜¯è¯´ä¸Šé¢çš„ä¾‹å­ä¸­ res1 åªèƒ½å†(multipe-value-bind)çš„å†…éƒ¨ä½¿ç”¨ã€‚è€Œæ— æ³•å†å¤–éƒ¨ä½¿ç”¨ nth-value nth-value æ˜¯å¯ä»¥ç›´æ¥æ‹¿åˆ°æŒ‡å®šç´¢å¼•çš„è¿”å›å€¼ (nth-value 0 (values :a :b :c)) ;; =\u003e :A (nth-value 2 (values :a :b :c)) ;; =\u003e :C (nth-value 9 (values :a :b :c)) ;; =\u003e NIL ä½†æ˜¯å¦‚æœå°† nth-value ç”¨åœ¨Listä¸Šï¼Œç»“æœå°±ä¸ä¸€æ ·äº† (nth-value 0 '(:a :b :c)) ;; =\u003e (:A :B :C) (nth-value 1 '(:a :b :c)) ;; =\u003e NIL Note (values) å°†ä¸ä¼šè¿”å›ä»»ä½•å€¼ multiple-value-list multiple-value-list å°†è¿”å›å€¼æ„é€ æˆlist (multiple-value-list (values 1 2 3)) ;; (1 2 3) ç›¸åçš„æ“ä½œæœ‰å°†list æ„é€ æˆå¤šè¿”å›å€¼ (value-list '(1 2 3)) ","date":"2022-10-04","objectID":"/function/:3:1","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"åŒ¿åå‡½æ•° lambda ä½¿ç”¨lambdaå‡½æ•°åˆ›å»ºåŒ¿åå‡½æ•° (lambda (x) (print x)) æˆ‘ä»¬å¯ä»¥ç”¨funcall æˆ–è€… apply æ¥è°ƒç”¨åŒ¿åå‡½æ•° å¦‚æœä¸€ä¸ªæœªè¢«å¼•ç”¨çš„æ‹¬å·è¡¨è¾¾å¼å†…éƒ¨ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªåŒ¿åå‡½æ•°å°±ä¼šè¢«è°ƒç”¨ ((lambda (x) (print x)) \"hello\") å¼•ç”¨ lispä¸­ å¼•ç”¨æ˜¯æŒ‡ä»¥â€™ä¸ºå¼€å¤´çš„è¡¨è¾¾å¼æˆ–ç¬¦å·ã€‚â€˜å°†ä¿æŠ¤è¡¨è¾¾å¼æˆ–ç¬¦å·ç»´æŒå…¶æœ¬èº«ã€‚ æ¯”å¦‚(func arg) è¿™ç§å½¢å¼çš„è¡¨è¾¾å¼å°†ä¼šè‡ªåŠ¨è¢«å½“åšå‡½æ•°æ‰§è¡Œ,æœ‰äº›æƒ…å†µæˆ‘ä»¬å¹¶ä¸æƒ³è®©ä»–æ‰§è¡Œï¼ˆæ¯”å¦‚ä¼ ä¸€ä¸ªlist ç»™å‡½æ•°åšå‚æ•°çš„æ—¶å€™çš„æ—¶å€™ï¼‰ (defun hello (arg)) (hello (1 2 3)) ;; illegal function call è¿™é‡Œ(1 2 3) å°†ä¼šè¢«æ±‚å€¼ å¹¶ä¸ä¼šçœŸçš„ä¼ ä¸€ä¸ª(1 2 3) ç»™argä¸”ä¼šæŠ¥ illegal function call è¿™æ ·çš„é”™è¯¯ã€‚å› ä¸ºæ²¡æœ‰è¢«â€™ ä¿æŠ¤çš„å‡½æ•°ä¼šè¢«è‡ªåŠ¨å½“æˆå‡½æ•°å¹¶ä¸”è¿ç®—ã€‚ æ‰€ä»¥æ­£ç¡®çš„å½¢å¼åº”è¯¥æ˜¯ (defun hello (arg)) (hello '(1 2 3)) â€˜å°±æ˜¯ä¿æŠ¤è¡¨è¾¾å¼æˆ–å˜é‡ç»´æŒå…¶æœ¬èº« ","date":"2022-10-04","objectID":"/function/:4:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"ä½¿ç”¨funcall å’Œ apply è°ƒç”¨å‡½æ•° funcall å’Œ apply ç±»ä¼¼ï¼Œéƒ½æ˜¯å°†å‚æ•°è§„æ•´æˆæ­£ç¡®çš„å½¢å¼ç„¶åä¼ ç»™å›è°ƒå‡½æ•° (funcall #'func arg1 arg2 .. argn) ;; ^^ å›è°ƒ è¦ä¼ ç»™funcçš„å‚æ•° ä¸åŒç‚¹åœ¨äºï¼Œ funcall ä¸ä¼šè‡ªåŠ¨å±•å¼€list åˆ—è¡¨ è€Œapply å¯ä»¥å°†åˆ—è¡¨å±•å¼€æˆä¸€ä¸ªä¸ªå‚æ•°ä¼ ç»™å›è°ƒfunc (funcall #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) ä¼šåŸå°ä¸åŠ¨çš„ä¼ ç»™func (apply #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) ä¼šè¢«å±•å¼€æˆ arg3 arg4 æœ€åçš„å½¢å¼å°±æ˜¯ (apply #'func arg1 arg2 arg3 arg4) ","date":"2022-10-04","objectID":"/function/:4:1","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"ä½¿ç”¨ single quote â€™ è¿˜æ˜¯ sharpsign-quote #â€™ æ¥å¼•ç”¨å‡½æ•°? single quote â€™ å’Œ sharpsign-quote #â€˜çš„ä¸åŒåœ¨äº #â€™ ä½¿ç”¨çš„æ˜¯è¯æ³•ä½œç”¨åŸŸ(lexical scope) ä¼šæ›´å®‰å…¨ç‚¹ (defun foo (x) (* x 100)) (flet ((foo (x) (1+ x))) (funcall #'foo 1)) ;; =\u003e 2, as expected ;; ;; But: (flet ((foo (x) (1+ x))) (funcall 'foo 1)) ;; =\u003e 100 lexical scope è¯æ³•ä½œç”¨åŸŸçš„æ„æ€æ˜¯ï¼Œå½“æ‰¾ä¸€ä¸ªå˜é‡æˆ–å‡½æ•°çš„æ—¶å€™ï¼ˆå‡½æ•°æ­¤æ—¶ä½œä¸ºå€¼è¿›è¡Œä¼ é€’ï¼‰ä¼šé»˜è®¤å»å®šä¹‰çš„åœ°æ–¹å»æ‰¾è€Œä¸æ˜¯å†å‡½æ•°è¿è¡Œçš„ç¯å¢ƒä¸­å»æ‰¾ã€‚ ä¸Šé¢çš„foo ä¸€ä¸ªæ˜¯åœ¨å¤–é¢å£°æ˜çš„ ä¸€ä¸ªæ˜¯ä½¿ç”¨flet ä¿æŠ¤èµ·æ¥çš„foo å¯¹äºfuncall æ¥è¯´ #â€™ä¼šå»æ‰¾flet å‡ºæ¥çš„foo å› ä¸ºè¯æ³•ä½œç”¨åŸŸè¦æ±‚åœ¨å®šä¹‰çš„åœ°æ–¹å»æ‰¾éœ€è¦çš„å‡½æ•°ã€‚ single quote â€™ ä½¿ç”¨çš„æ˜¯åŠ¨æ€ä½œç”¨åŸŸ ä¼šé»˜è®¤å»è¿è¡Œç¯å¢ƒä¸­æ‰¾æ‰€ä»¥ å³ä½¿ç¬¬äºŒä¸ªflet ä¹Ÿå£°æ˜äº† foo ä½†æ˜¯funcall çš„æ—¶å€™è¿˜æ˜¯å»åˆ°å¤–å±‚å¯»æ‰¾foo #â€™ å…¶å®å°±æ˜¯(function â€¦ )çš„è¯­æ³•ç³– (function +) ;; #\u003cFUNCTION +\u003e (flet ((foo (x) (1+ x))) (print (function foo)) (funcall (function foo) 1)) ;; #\u003cFUNCTION (FLET FOO) {1001C0ACFB}\u003e ;; 2 ","date":"2022-10-04","objectID":"/function/:4:2","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"é«˜çº§å‡½æ•° èƒ½å¤Ÿè¿”å›å‡½æ•°çš„å‡½æ•° (functions that return functions) (defun adder (n) (lambda (x) (+ x n))) è¿™æ ·å°±å®šä¹‰äº†ä¸€ä¸ªèƒ½å¤Ÿè¿”å›ä¸€ä¸ªå‡½æ•°å¯¹è±¡çš„adderå‡½æ•° è¦æƒ³è°ƒç”¨è¿™ä¸ªå‡½æ•°å¯¹è±¡æˆ‘ä»¬éœ€è¦funcall æˆ–è€… apply (adder 5) ;; #\u003cCLOSURE (LAMBDA (X) :IN ADDER) {100994ACDB}\u003e (funcall (adder 5) 3) ;; 8 å¦‚æœä½ æƒ³ä»¥æ­£å¸¸çš„æ€ç»´å»è°ƒç”¨è¿™ä¸ªå‡½æ•°å¯¹è±¡ï¼Œä¼šæŠ¥é”™ ((adder 3) 5) ;;In: (ADDER 3) 5 ;;((ADDER 3) 5) ;;Error: Illegal function call. åœ¨common lisp ä¸­ å¯¹äºå˜é‡å’Œæ–¹æ³• ä»–ä»¬æœ‰ä¸åŒçš„å‘½åç©ºé—´ã€‚ æ¯”å¦‚ä¸€ä¸ªå˜é‡å’Œä¸€ä¸ªå‡½æ•°å¯ä»¥æœ‰åŒä¸€ä¸ªåå­—, è¿™å–å†³äºä»–è¢«è¿ç®—çš„ç¯å¢ƒ ;; The symbol foo is bound to nothing: CL-USER\u003e (boundp 'foo) NIL CL-USER\u003e (fboundp 'foo) NIL ;; We create a variable: CL-USER\u003e (defparameter foo 42) FOO * foo 42 ;; Now foo is \"bound\": CL-USER\u003e (boundp 'foo) T ;; but still not as a function: CL-USER\u003e (fboundp 'foo) NIL ;; So let's define a function: CL-USER\u003e (defun foo (x) (* x x)) FOO ;; Now the symbol foo is bound as a function too: CL-USER\u003e (fboundp 'foo) T ;; Get the function: CL-USER\u003e (function foo) #\u003cFUNCTION FOO\u003e ;; and the shorthand notation: * #'foo #\u003cFUNCTION FOO\u003e ;; We call it: (funcall (function adder) 5) #\u003cCLOSURE (lambda (X) :IN ADDER) {100991761B}\u003e ;; and call the lambda: (funcall (funcall (function adder) 5) 3) 8 å¯ä»¥è®¤ä¸ºï¼Œæ¯ä¸ªsymbol åœ¨CL(common lisp)ä¸­å¤šæœ‰å¤šä¸ªcell(ç©ºé—´)å­˜å‚¨ä¸åŒçš„ä¿¡æ¯ï¼Œæ¯”å¦‚æœ‰çš„è¡¨ç¤ºä¸€ä¸ªvalue-cell ä½ å¯ä»¥ç”¨boundp æ¥æµ‹è¯•æ˜¯å¦ç»‘å®šäº†ä¸€ä¸ªvalue. ä½ å¯ä»¥ä½¿ç”¨symbol-valueè®¿é—®value-cell. è¿˜æœ‰å…¶ä»–cell æ¯”å¦‚function-cell å¯ä»¥ä¿å­˜symbol çš„function. ä½ å¯ä»¥ç”¨fboundpæ¥æµ‹è¯•ï¼Œä½¿ç”¨symbol-function æ¥è®¿é—®è¿™ä¸ªfunction. å¦‚æœsymbol è¢«è¿ç®—ï¼Œé‚£å®ƒå°±è¢«å½“åšæ˜¯ä¸€ä¸ªvariable å¹¶ä¸”ä»–çš„value-cellå°†è¢«è¿”å›ã€‚å¦‚æœæ˜¯ç¬¦åˆå½¢å¼ï¼Œå³cons,è¢«æ±‚å€¼å¹¶ä¸”ä»–çš„caræ˜¯ä¸€ä¸ªsymbolï¼Œé‚£ä¹ˆä½¿ç”¨è¿™ä¸ªsymbolçš„function-cell. æ‰€ä»¥ä¸Šé¢çš„((addr 3) 5)çš„è°ƒç”¨ä¼šæŠ¥é”™ã€‚å› ä¸º(addr 3) æ—¢ä¸æ˜¯ç¬¦å· ä¹Ÿä¸æ˜¯lambdaè¡¨è¾¾å¼. ;;; continued from above CL-USER\u003e (fboundp '*my-fun*) NIL CL-USER\u003e (setf (symbol-function '*my-fun*) (adder 3)) #\u003cCLOSURE (lambda (X) :IN ADDER) {10099A5EFB}\u003e CL-USER\u003e (fboundp '*my-fun*) T CL-USER\u003e (*my-fun* 5) 8 ","date":"2022-10-04","objectID":"/function/:5:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"Closures é—­åŒ… Closures å…è®¸æ•è·è¯æ³•ç»‘å®šçš„å€¼ (let ((limit 3) (counter -1)) (defun my-counter() (if (\u003c counter limit) (incf counter) (setf counter 0)))) (my-counter) 0 (my-counter) 1 (my-counter) 2 (my-counter) 3 (my-counter) 0 lexical è¿™é‡Œå¯ä»¥çœ‹è§ï¼Œcounter å’Œ limit æ˜¯åœ¨letåå°±å·²ç»å­˜åœ¨çš„å€¼ã€‚my-counter ä¼šå»æ‰¾è¢«letçš„limit å’Œ counter. letå°±æ˜¯å°†letå®šä¹‰çš„å€¼ä¸ä¸‹é¢çš„å‡½æ•°ä½“(body)åšç»‘å®šã€‚ è¿˜å¯ä»¥è¿™æ · (defun repeater (n) (let ((counter -1)) (lambda () (if (\u003c counter n) (incf counter) (setf counter 0))))) (defparameter *my-repeater* (repeater 3)) (defparameter *my-repeater2* (repeater 2)) (funcall *my-repeater*) 0 (funcall *my-repeater*) 1 (funcall *my-repeater*) 2 (funcall *my-repeater2*) 0 (funcall *my-repeater*) 3 (funcall *my-repeater*) 0 è¿™é‡Œå¯ä»¥çœ‹åˆ°my-repeater å’Œmy-repeaterä¹‹é—´æ˜¯ç›¸äº’éš”ç¦»çš„ å„è‡ªæ‹¥æœ‰è‡ªå·±çš„counter. è¿™æ˜¯å› ä¸ºrepeater è¢«æ‰§è¡Œäº†ä¸¤æ¬¡è€Œ lambda è¡¨è¾¾å¼è¢«å®šä¹‰äº†ä¸¤æ¬¡ï¼Œè€Œè¢«letåŒ…è£¹çš„å‡½æ•°ä¼šå»å…¶å®šä¹‰çš„ç¯å¢ƒä¸­å¯»æ‰¾å€¼ï¼Œæ‰€ä»¥ä¸¤è€…çš„counteræ˜¯éš”ç¦»çš„ã€‚ ","date":"2022-10-04","objectID":"/function/:6:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"TODO setf functions ","date":"2022-10-04","objectID":"/function/:7:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"æŸ¯é‡ŒåŒ– currying ç»´åŸºç™¾ç§‘ä¸Šçš„è§£é‡Šæ˜¯ï¼ŒæŠŠæ¥å—å¤šä¸ªå‚æ•°çš„å‡½æ•°è½¬æ¢æˆæ¥å—ä¸€ä¸ªå•ä¸€å‚æ•°çš„å‡½æ•° (defun curry (function \u0026rest args) (lambda (\u0026rest more-args) (apply function (append args more-args)))) è¿™ä¸ªå‡½æ•°å†ç¬¬ä¸€æ¬¡è°ƒç”¨çš„æ—¶å€™ä¼šè¿”å›lambdaå‡½æ•° (funcall (curry #'+ 3) 5) ;;8 ","date":"2022-10-04","objectID":"/function/:8:0","tags":["common-lisp"],"title":"Common-Lisp function","uri":"/function/"},{"categories":["lisp"],"content":"common lisp çš„ä¸€äº›åŸºæœ¬æ•°æ®ç»“æ„","date":"2022-10-04","objectID":"/data_structure/","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Lists ","date":"2022-10-04","objectID":"/data_structure/:1:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Building lists. Cons cells,list list(åˆ—è¡¨) ä¹Ÿæ˜¯ä¸€ä¸ª sequence(åºåˆ—). list ç”±consç»„æˆã€‚ cons æœ‰ä¸¤ä¸ªcell ä¸€ä¸ªå« â€œcarâ€ ä¸€ä¸ª å« â€œcdrâ€ æˆ‘ä»¬å¯ä»¥åƒè¿™æ ·æ„å»ºä¸€ä¸ªç®€å•çš„list (cons 1 2) ;;=\u003e (1 . 2) ;; è¿™æ˜¯ä¸€ä¸ªdotted pair è¡¨ç¤ºä¸€ä¸ªcons å®ƒçš„åº•å±‚ç»“æ„å¯ä»¥æŠ½è±¡æˆè¿™æ · [o|o]--- 2 | 1 å¦‚æœç¬¬ä¸€ä¸ªconsçš„cdr æ˜¯å¦ä¸€ä¸ªcons å¹¶ä¸”æœ€åä¸€ä¸ªcons çš„cdr æ˜¯nil ,é‚£ä¹ˆæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªlist (cons 1 (cons 2 nil)) ;; =\u003e (1 2) åº•å±‚ç»“æ„æ˜¯è¿™æ ·çš„ [o|o]---[o|/] ^ ^ 1 2 ä¸ºä»€ä¹ˆä¸æ˜¯dotted pair lisp printer é‡åˆ°è¿™ç§ç»“æ„çš„æ—¶å€™ä¼šè‡ªåŠ¨å°†é€—å·çœç•¥ã€‚ä½†æ˜¯listè¿˜æ˜¯ç”±ä¸€ä¸ªä¸ªdotted pairç»„æˆçš„ã€‚ æ›´ç®€å•çš„ å¯ä»¥ç”¨list å‡½æ•°æ¥æ„å»ºlist (list 1 2) ;; =\u003e (1 2) æˆ–è€…ä½¿ç”¨ä¸€ä¸ªå¼•ç”¨ç¬¦å·' '(1 2) ;; =\u003e (1 2) ","date":"2022-10-04","objectID":"/data_structure/:1:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Circular lists å¾ªç¯åˆ—è¡¨ cons çš„ä¸¤ä¸ªcell å¯ä»¥ cå­˜æ”¾ä»»ä½•å€¼ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥å­˜æ”¾è‡ªå·±ï¼Œæˆ–è€…åˆ—è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ çš„cdrå­˜å‚¨åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ .è¿™ä¸ªæ—¶å€™å°±æ„æˆäº†å¾ªç¯åˆ—è¡¨ã€‚ å¼•æ–‡æœ€åä¸€ä¸ªå…ƒç´ çš„cdr å­˜çš„æ˜¯åˆ—è¡¨çš„å¼€å§‹ã€‚ åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬è¦å°†*print-circle* è®¾ä¸ºtå‘Šè¯‰printer ä¸è¦æ— é™ç­”åº”å¾ªç¯åˆ—è¡¨ã€‚ (setf *print-circle* t) é¦–å…ˆå®šä¹‰ä¸€ä¸ªèƒ½æ„é€ å¾ªç¯åˆ—è¡¨çš„å‡½æ•° (defun circular! (items) \"Modifies the last cdr of list ITEMS, returning a circular list\" (setf (cdr (last items)) items)) (circular! (list 1 2 3)) (fifth (circular! (list 1 2 3))) ;; =\u003e 2 å¯¹äºå¾ªç¯åˆ—è¡¨list-lengthå°†ä¼šè¿”å›nil reader ä¹Ÿå¯ä»¥æ„å»ºä¸€ä¸ªå¾ªç¯åˆ—è¡¨ï¼Œä½¿ç”¨sharpsign equal-sign notation. ä¸€ä¸ªobject(å¯¹è±¡) å¯ä»¥ä»¥#n=ä½œä¸ºå‰ç¼€ï¼Œnæ˜¯ä¸€ä¸ªæ— ç¬¦å·åè¿›åˆ¶æ•´æ•°ã€‚å¯ä»¥ç”¨#n#å»å¼•ç”¨å·²ç»å®šä¹‰çš„å¯¹è±¡ '#42=(1 2 3 . #42#) ;; =\u003e #1=(1 2 3 . #1#) ","date":"2022-10-04","objectID":"/data_structure/:1:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"car/cdr or first/rest (and secondâ€¦ to tenth) (car (cons 1 2)) ;; return the car cell of a cons. here return 1 (cdr (cons 1 2)) ;; return the cdr cell of a cons.here return 2 (first '(1 2 3 4 5)) ;; return the car of first. here return 1 (second '(1 2 3 4 5)) ;; return the car of second. here return 2 (third '(1 2 3 4 5)) ;; return the car of third. here return 3 . . . (tenth '(1 2 3 4 5 6 7 8 9 10)) ;; return the car of tenth. here return 10 (rest '(rest)) ;; return (2 3) rest return cdr of the first cons setf å¯ä»¥ç”¨æ¥ç»™åˆ—è¡¨ä¸­çš„å…ƒç´ èµ‹å€¼ (defparameter ll '(1 2 3 4)) (setf (first ll) 2) ll ;; now ll is (2 2 3 4) ","date":"2022-10-04","objectID":"/data_structure/:1:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"last,butlast,nbutlast(\u0026optional n) (last '(1 2 3)) ;; return last of cons of (1 2 3). here return (3) ;; =\u003e (3) (car (last '(1 2 3))) ;; or (first (last ...)) ;; =\u003e 3 (butlast '(1 2 3));; return the list except the last ;; =\u003e (1 2) ","date":"2022-10-04","objectID":"/data_structure/:1:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"reverse,nreverse å€’åº reverse å’Œ nreverse éƒ½è¿”å›ä¸€ä¸ªæ–°çš„åºåˆ—(sequence) nreverse æ˜¯æ¯ç­æ€§çš„(destructive)ã€‚å‰ç¼€ n ä»£è¡¨ non-consing,ä»£è¡¨ä»–æ˜¯ç›´æ¥åœ¨åŸæœ‰Listä¸Šè¿›è¡Œä¿®æ”¹ã€‚ (defparameter mylist '(1 2 3)) ;; =\u003e (1 2 3) (reverse mylist) ;; =\u003e (3 2 1) mylist ;; =\u003e (1 2 3) (nreverse mylist) ;; =\u003e (3 2 1) mylist ;; =\u003e (1) in SBCL but implementation dependent. destructive å¦‚æœä¸€ä¸ªå‡½æ•°ä¼šä¿®æ”¹ä»–çš„ä»–çš„æ“ä½œå…ƒç´  æˆ‘ä»¬å°±è¯´ä»–æ˜¯destructiveçš„ ","date":"2022-10-04","objectID":"/data_structure/:1:5","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"append append ä¼šå°†ä¸¤ä¸ªliståˆå¹¶æˆä¸€ä¸ªlist (append (list 1 2) (list 3 4)) ;; =\u003e (1 2 3 4) append çš„å‘ append è¿”å›çš„Listä¼šå…±äº«åŸæœ‰çš„listçš„cons æ‰€ä»¥åœ¨å…¶è¿”å›çš„listè¿›è¡Œä¿®æ”¹ï¼Œä¹Ÿä¼šå½±å“åŸæœ‰çš„list ","date":"2022-10-04","objectID":"/data_structure/:1:6","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"push (item,place) push æ˜¯destructiveçš„ ä»–ä¼šå°†æ–°çš„å…ƒç´ æ’å…¥listçš„æœ€å‰é¢ (defparameter mylist '(1 2 3)) (push 0 mylist) ;;=\u003e (0 1 2 3) mylist ;;=\u003e (0 1 2 3) (defparameter x â€™(a (b c) d)) ;; =\u003e (A (B C) D) (push 5 (cadr x)) ;; =\u003e (5 B C) x ;; =\u003e (A (5 B C) D) CL æ²¡æœ‰é»˜è®¤çš„å°¾æ’å‡½æ•°ï¼Œå¦‚æœæƒ³è¦å°¾æ’ä½ å¯ä»¥å…ˆå°†list è¿›è¡Œ reverse æˆ–è€…ä½¿ç”¨åˆ«çš„æ•°æ®ç»“æ„ ","date":"2022-10-04","objectID":"/data_structure/:1:7","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"pop pop æ˜¯ desctructive å’Œ push ç›¸å¯¹ push ä¼šå¾€é‡Œé¢æ’å…¥ è€Œpopä¼šå°†æœ€å‰é¢çš„å…ƒç´ è¿”å›å¹¶åˆ é™¤ ","date":"2022-10-04","objectID":"/data_structure/:1:8","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"nthcdr (index ,list) è¿”å›ç¬¬nä¸ªcons çš„ cdrã€‚ (defparameter mylist '(1 2 3)) (nthcdr 1 mylist) ;; =\u003e (2) ","date":"2022-10-04","objectID":"/data_structure/:1:9","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"å¤åˆçš„car å’Œ cdr æˆ‘ä»¬å¯ä»¥å¤åˆ a å’Œ d æ¥åšä¸€äº›æ–¹ä¾¿çš„æ“ä½œã€‚æ¯”å¦‚cadr å°±æ˜¯ è¿”å› the car of cdr caar å°±æ˜¯è¿”å› the car of car è¿™äº›æ“ä½œé€šå¸¸åœ¨åµŒå¥—listä¸­æœ‰äº›æ„ä¹‰ (caar (list 1 2 3));; ==\u003e error (caar (list (list 1 2) 3)) ;; ==\u003e 1 (cadr (list (list 1 2) (list 3 4))) ;; ==\u003e (3 4) (caadr (list (list 1 2) (list 3 4))) ;; == \u003e 3 ","date":"2022-10-04","objectID":"/data_structure/:1:10","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"destructuring-bind (parameter*,list) è¿™ä¸ªå‡½æ•°å°†Listä¸­çš„å…ƒç´ ä¸å‚æ•°ç»‘å®šï¼Œæˆ‘ä»¬å¯ä»¥ææ„tree,plists (destructuring-bind (x y z) (list 1 2 3) (list :x x :y y :z z)) ;; =\u003e (:X 1 :Y 2 :Z 3) å†…éƒ¨çš„sublistä¹Ÿå¯ä»¥ç»‘å®š (destructuring-bind (x (y1 y2) z) (list 1 (list 2 20) 3) (list :x x :y1 y1 :y2 y2 :z z)) ;; =\u003e (:X 1 :Y1 2 :Y2 20 :Z 3) parameter list è¿˜å¯ä»¥ç”¨\u0026optional,\u0026rest å’Œ \u0026key (destructuring-bind (x (y1 \u0026optional y2) z) (list 1 (list 2) 3) (list :x x :y1 y1 :y2 y2 :z z)) ;; =\u003e (:X 1 :Y1 2 :Y2 NIL :Z 3) (destructuring-bind (\u0026key x y z) (list :z 1 :y 2 :x 3) (list :x x :y y :z z)) ;; =\u003e (:X 3 :Y 2 :Z 1) \u0026whole parameter ä¼šè¢«ç»‘å®šåˆ°æ•´ä¸ªlist. ä»–å¿…é¡»å†ç¬¬ä¸€ä¸ª å…¶ä½™çš„å‚æ•°å¿…é¡»åœ¨å®ƒåé¢ (destructuring-bind (\u0026whole whole-list \u0026key x y z) (list :z 1 :y 2 :x 3) (list :x x :y y :z z :whole whole-list)) ;; =\u003e (:X 3 :Y 2 :Z 1 :WHOLE (:Z 1 :Y 2 :X 3)) ","date":"2022-10-04","objectID":"/data_structure/:1:11","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"null,listp æ–­è¨€ null å’Œ not ç›¸åŒï¼Œä½†æ˜¯çœ‹èµ·æ¥æ›´å¥½ ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªåˆ—è¡¨æ˜¯å¦ä¸ºç©º listp åˆ¤æ–­ä¸€ä¸ªå¯¹è±¡æ˜¯å¦æ˜¯ä¸€ä¸ªcons cell ","date":"2022-10-04","objectID":"/data_structure/:1:12","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"ldiff,tailp,list*,make-list,fill,revappend,nreconc,consp,atom åªä»‹ç»å‡ ä¸ªå¸¸ç”¨çš„ï¼Œå…¶ä½™çš„å¯ä»¥å»æŸ¥æ–‡æ¡£ï¼ˆå¤ªå¤šäº†ï¼Œä¸æƒ³å†™ï¼ˆå°å£°bbï¼‰ å¾ˆå¤šå…¶å®ä¸å¸¸ç”¨ï¼Œå°±ä¸å†™äº†ï¼‰ make-list æ„é€ ä¸€ä¸ªlist (make-list 3 :initial-element \"ta\") ;; =\u003e (\"ta\" \"ta\" \"ta\") fill ç”¨æŒ‡å®šå¯¹è±¡å¡«å……list (make-list 3) ;; =\u003e (NIL NIL NIL) (fill * \"hello\") ;; =\u003e (\"hello\" \"hello\" \"hello\") tailp ç”¨æ¥åˆ¤æ–­æ˜¯å¦æœ‰å…±äº«çš„åˆ—è¡¨ç»“æ„ï¼Œä¹Ÿå°±æ˜¯æ˜¯å¦æœ‰ç›¸åŒçš„cons cell(use EQL for predicate),è€Œä¸ä»…ä»…æ˜¯cons cellçš„å†…å®¹ (tailp t '(1 2 3 4 . t)) ;; =\u003e T (tailp nil '(1 2 3 4 . nil)) ;; =\u003e T (tailp nil '(1 2 3 4)) ;; =\u003e T (tailp #1=\"e\" '(1 2 3 4 . #1#)) ;; =\u003e T (defparameter *tail* (list 3 4 5)) (defparameter *larger* (list* 1 2 *tail*)) (defparameter *replica* (copy-list *larger*)) (tailp *tail* *replica*) ;; ==\u003e nil (tailp *tail* *larger*) ;; ==\u003e t ","date":"2022-10-04","objectID":"/data_structure/:1:13","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"member (elt,list) è¿”å›ä»¥eltå¼€å§‹çš„å‰©ä¸‹çš„å…ƒç´  é»˜è®¤ä½¿ç”¨eqlä½œä¸ºæ¯”è¾ƒå‡½æ•° æ¥å—:test :test-not :key(functions or symbols) (member 2 '(1 2 3)) ","date":"2022-10-04","objectID":"/data_structure/:1:14","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"æ›¿æ¢treeä¸­çš„å¯¹è±¡:subst,sublis subst å’Œ subst-if åœ¨treeä¸­æŸ¥æ‰¾æ‰€æœ‰å’Œelementç›¸åŒçš„å…ƒç´  å¹¶ ç”¨å¦ä¸€ä¸ªelement æ›¿æ¢ (å¯ä»¥ç”¨:test æŒ‡å®šåˆ¤æ–­ç›¸åŒçš„å‡½æ•°) (subst 'one 1 '(1 2 3)) ;; =\u003e (one 2 3) (subst '(1 . one) '(1 . 1) '((1 . 1) (2 . 2) (3 . 3)) :test #'equal) ;; ((1 . ONE) (2 . 2) (3 . 3)) sublis ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªlist(æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª dot list),æ¯ä¸ªdot list æœ‰2ä¸ªå…ƒç´ (x . y) è¡¨ç¤ºå°† x æ›¿æ¢ ä¸º y sublis æ¥å—:test å’Œ :key å‚æ•° :test æ˜¯ä¸€ä¸ªæ¥å—key å’Œ subtreeä¸ºå‚æ•°çš„å‡½æ•° (sublis '((t . \"foo\")) (\"one\" 2 (\"three\" (4 5))) :key #'stringp) ;; (\"foo\" 2 (\"foo\" (4 5))) ","date":"2022-10-04","objectID":"/data_structure/:1:15","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Sequences åºåˆ— lists vectors strings éƒ½æ˜¯åºåˆ— å¤§å¤šæ•°å’Œåºåˆ—æœ‰å…³çš„å‡½æ•°éƒ½æ¥å—keyword å‚æ•°ã€‚æ‰€æœ‰keyword å‚æ•°éƒ½æ˜¯å¯é€‰çš„ï¼Œå¹¶ä¸”å¯ä»¥ä»¥ä»»æ„é¡ºåºå‡ºç° :testå‚æ•°é»˜è®¤ä½¿ç”¨eql (å¯¹äºstrings æ¥è¯´ ç”¨:equal) :key å‚æ•°å¯ä»¥æ¥å—nil å’Œ å•å‚æ•°çš„å‡½æ•°ï¼ˆè¿™ä¸ªå‡½æ•°å£°æ˜äº†æˆ‘ä»¬å…·ä½“è¦æ€ä¹ˆçœ‹å¾…åºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼‰ (defparameter my-alist (list (cons 'foo \"foo\") (cons 'bar \"bar\"))) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) (find 'bar my-alist) ;; =\u003e NIL (find 'bar my-alist :key 'car) ","date":"2022-10-04","objectID":"/data_structure/:2:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"æ–­è¨€: every , someâ€¦. every çš„ä½œç”¨æ˜¯åˆ¤æ–­åˆ—è¡¨ä¸­çš„å…ƒç´ æ˜¯å¦éƒ½æ»¡è¶³æŸä¸ªæ¡ä»¶ (éƒ½æ»¡è¶³å°±è¿”å›çœŸ) (defparameter foo '(1 2 3)) (every #'evenp foo) ;; =\u003e NIL some åˆ™åªéœ€è¦ä¸€äº›å…ƒç´ æ»¡è¶³æ¡ä»¶å³å¯ (ä¸€äº›æ»¡è¶³å°±è¿”å›çœŸ) (defparameter foo '(1 2 3)) (every #'evenp foo) ;; =\u003e NIL notany åªè¦ä¸æ˜¯æ‰€æœ‰éƒ½æ»¡è¶³å°±è¿”å›çœŸ ","date":"2022-10-04","objectID":"/data_structure/:2:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"å¸¸ç”¨å‡½æ•° alexandriaåº“ ã€Šcommon lisp cookbookã€‹ä¸­ä¸€ç›´æåˆ°æœ‰ä¸€ä¸ª\"alexandria\"çš„åº“é‡Œé¢æœ‰å¾ˆå¤šéå¸¸å®ç”¨çš„å‡½æ•°ï¼Œæ˜¯å¯¹common lisp çš„ä¸€ç§æ‰©å……ï¼Œå¯ä»¥å»çœ‹ä¸€çœ‹ length(sequence) è¿”å›åºåˆ—çš„é•¿åº¦ elt(sequence,index) find by index count (foo sequence) è¿”å› sequenceä¸­ å‡ºç°fooçš„æ¬¡æ•° å¯æ¥å—:from-end,:start,:end ç›¸å…³çš„è¿˜æœ‰count-if,count-not(test-function sequence) subseq (sequence start,[end]) è¿”å›å­åºåˆ—å·¦é—­å³å¼€[start,end): (subseq (list 1 2 3) 0) ;; (1 2 3) (subseq (list 1 2 3) 1 2) ;; (2) endä¸èƒ½å¤§äº( + (length sequence) 1) å› ä¸ºè¿™æ ·ä¼šè¶Šç•Œ: (defparameter my-list '(1 2 3 4)) (subseq my-list 0 (+ length(my-list) 1)) ;; =\u003e Error: the bounding indices 0 and 5 are bad for a sequence of length 3. å¦‚æœæœå¯èƒ½è¶Šç•Œï¼Œç”¨alexandria-2:subseq*: (alexandria-2:subseq* (list 1 2 3) 0 99) subseq æ˜¯\"setf\" able çš„ ä½†æ˜¯åªæœ‰å½“æ–°çš„åºåˆ—çš„é•¿åº¦å’Œè¦è¢«æ›¿æ¢çš„åºåˆ—é•¿åº¦ä¸€è‡´çš„æ—¶å€™æ‰ä¼šç”Ÿæ•ˆ (defparameter my-list '(1 2 3 4)) ;; =\u003e(1 2 3 4) (setf (subseq my-list 0 2) '(2 3)) my-list ;; =\u003e (2 2 3 4) sort,stable-sort(sequence,test[,key function]) è¿™ä¸¤ä¸ªå‡½æ•°æ—¶destructiveçš„ï¼Œæ‰€ä»¥åœ¨æ’åºå‰ï¼Œå¯èƒ½ä¼šä¼˜å…ˆä½¿ç”¨copy-seq æ‹·è´ä¸€ä»½å‡ºæ¥ (sort (copy-seq seq) :test #'string\u003c) å°±åƒåå­—ä¸­è¯´çš„ä¸€æ · sortæ˜¯ä¸ç¨³å®šçš„è€Œstable-sortæ˜¯ç¨³å®šçš„ find,position(foo,sequence) - get index also find-if,find-if-not,position-if,position-if-not(test sequence) (find 20 '(10 20 30)) ;; 20 (position 20 '(10 20 30)) ;; 1 search and mismatch (sequence-a, sequence-b) search ä¼šåœ¨sequence-b ä¸­å¯»æ‰¾å’Œsequence-a ä¸€æ ·çš„subsequenceã€‚ä»–ä¼šè¿”å›sequence-a åœ¨ sequence-b ä¸­çš„ä½ç½®ï¼Œå¦‚æœæ²¡æ‰¾åˆ°å°±æ˜¯nil. å‚æ•°æœ‰ from-end,end1,end2 ä»¥åŠä¸Šé¢æåˆ°çš„test å’Œ key (search '(20 30) '(10 20 30 40)) ;; 1 (search '(\"b\" \"c\") '(\"a\" \"b\" \"c\")) ;; nil (search '(\"b\" \"c\") '(\"a\" \"b\" \"c\") :test #'equal) ;;1 (search \"bc\" \"abc\") ;;1 mismatch è¿”å›ä¸¤ä¸ªåºåˆ—å¼€å§‹ä¸ä¸€æ ·çš„åœ°æ–¹ (mismatch '(10 20 99) '(10 20 30)) ;; 2 (mismatch \"hellolisper\" \"helloworld\") ;; 5 (mismatch \"same\" \"same\") ;; NIL (mismatch \"foo\" \"bar\") ;; 0 substitute,nsubstitute[if,if-not] è¿”å›ä¸€ä¸ªåŒç±»å‹çš„åºåˆ—ï¼Œè¿™ä¸ªåºåˆ—å°†ä¼šç”¨æ–°çš„å…ƒç´ æ›¿ä»£å°±çš„å…ƒç´  (substitute #\\o #\\x \"hellx\") ;; =\u003e \"hello\" (substitute :a :x '(:a :x :x)) ;; =\u003e (:A :A :A) (substitute \"a\" \"x\" '(\"a\" \"x\" \"x\") :test #'string=) ;; =\u003e (\"a\" \"a\" \"a\") replace (sequence-a,sequence-b,\u0026key start1,end1) ç ´åæ€§çš„ç”¨sequence-b ä¸­çš„å…ƒç´ æ›¿æ¢sequence-aä¸­çš„å…ƒç´  å®Œæ•´çš„å‡½æ•°ç­¾å: (replace sequence1 sequence2 \u0026rest args \u0026key (start1 0) (end1 nil) (start2 0)(end2 nil)) (replace \"xxx\" \"foo\") \"foo\" (replace \"xxx\" \"foo\" :start1 1) \"xfo\" (replace \"xxx\" \"foo\" :start1 1 :start2 1) \"xoo\" (replace \"xxx\" \"foo\" :start1 1 :start2 1 :end2 2) \"xox\" remove,delete(foo sequence) è¿”å›ä¸€ä¸ªä¸åŒ…å«fooçš„æ–°sequence æ¥å—:start/end å’Œ :countå‚æ•° (remove \"foo\" '(\"foo\" \"bar\" \"foo\") :test 'equal) ;; =\u003e (\"bar\") remove-duplicates,delete-duplicates(sequence) å»é‡æ“ä½œ deleteä¸remove ä¸åŒçš„åœ°æ–¹åœ¨äº deleteä¼šç›´æ¥æ“ä½œåŸå§‹çš„sequence æ¥å— from-end test test-not start end key (remove-duplicates '(:foo :foo :bar)) (:FOO :BAR) (remove-duplicates '(\"foo\" \"foo\" \"bar\")) (\"foo\" \"foo\" \"bar\") (remove-duplicates '(\"foo\" \"foo\" \"bar\") :test #'string-equal) (\"foo\" \"bar\") mapping (map,mapcar,remove-if[-not],â€¦) mapcar åªèƒ½ç”¨äºlist è€Œmap é€‚ç”¨äºvector list ä½†æ˜¯ç”±äºmap å¯ä»¥ç”¨äºå¤šç§ç»“æ„ æ‰€ä»¥è¦æŒ‡å®šè¿”å›å€¼ç±»å‹å®å‚ã€‚(map â€™list function vector) mapcar å¯ä»¥æ¥å—å¤šä¸ªlist æ˜ å°„æ“ä½œä¼šåœ¨æœ€çŸ­çš„listè¢«æ“ä½œå®Œæ˜¯ä¸­æ–­ (defparameter foo '(1 2 3)) (map 'list (lambda (it) (* 10 it)) foo) reduce (function,sequence). é¦–å…ˆä¼šå°†functionä½œç”¨äºåˆ—è¡¨ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªå…ƒç´ ï¼Œç„¶åå°†functionä½œç”¨äºè¿™ä¸ªç»“æœä¸ä¸‹ä¸€ä¸ªå…ƒç´ ç›´åˆ°å¤„ç†å®Œæ‰€æœ‰å…ƒç´  å¦‚æœæŒ‡å®šäº†ç‰¹æ®Šå‚æ•°:initial-value. é¦–å…ˆå°±ä¸ä¼šå°†functionä½œç”¨äºåˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªå…ƒç´ ï¼Œè€Œæ˜¯é¦–å…ˆå°†functionä½œç”¨äº:initial-value å’Œç¬¬ä¸€ä¸ªå€¼ (reduce '- '(1 2 3 4)) ;; =\u003e -8 (reduce '- '(1 2 3 4) :initial-value 100) ;; =\u003e 90 Creating lists with variables ç”±äºquote â€™ ä¼šä¿æŠ¤è¡¨è¾¾å¼ä¸è¢«æ±‚å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—ç”¨listæ¥æ–°å»ºåˆ—è¡¨ï¼Œä½†æ˜¯list å‡½æ•°æ‰€æœ‰çš„å‚æ•°éƒ½ä¼šå…ˆè¢«æ±‚å€¼ç„¶åå†æ„é€ æˆåˆ—è¡¨. å¦‚æœåªæ˜¯æƒ³ç‰¹å®šçš„å˜é‡è¢«æ±‚èŒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨backquote ` æ¥æ„é€ List å…ˆæ¥ä¸ªæ­£å¸¸çš„quote (defparameter *var* \"bar\") ;; First try: '(\"foo\" *var* \"baz\") ;; no backquote ;; =\u003e (\"foo\" *VAR* \"baz\") ;; nope å†æ¥ä¸ªbackquote `(\"foo\" ,*var* \"baz\") ;; backquote, comma ;; =\u003e (\"foo\" \"bar\" \"baz\") ;; good åœ¨backquote åé¢ ä»¥comma , å¼€å¤´çš„å˜é‡ä¼šè¢«æ­£å¸¸æ±‚å€¼ å¦‚æœå˜é‡æ˜¯ä¸€ä¸ªlistçš„è¯ (defparameter *var* '(\"bar\" \"baz\")) ;;First try: `(\"foo\" ,*var*) ;; =\u003e (\"foo\" (\"bar\" \"baz\")) ;; nested list `(\"foo\" ,@*var*) ;; =\u003e (\"foo\" \"bar\" \"baz\") ","date":"2022-10-04","objectID":"/data_structure/:2:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"é›†åˆæ“ä½œSet é¦–å…ˆï¼Œä¸€ä¸ªé›†åˆä¸ä¼šåŒ…å«ä¸¤ä¸ªåŒæ ·çš„å…ƒç´ ï¼Œå¹¶ä¸”é›†åˆå†…éƒ¨æ˜¯æ— éœ€çš„. å¤§å¤šæ•°å‡½æ•°éƒ½æœ‰å¾ªç¯åˆ©ç”¨å·²ç»æœ‰çš„å˜é‡çš„å‡½æ•°ç‰ˆæœ¬(ç ´åæ€§çš„) åŒºåˆ«äºæ­£å¸¸çš„ ä»–ä»¬ä»¥\"n\"å¼€å¤´. ä»–ä»¬éƒ½å¯ä»¥æ¥å—:key å’Œ :test å‚æ•° intersection listçš„äº¤é›† (defparameter list-a '(0 1 2 3)) (defparameter list-b '(0 2 4)) (intersection list-a list-b) ;; =\u003e (2 0) set-difference ä½œå·® (set-difference list-a list-b) ;; =\u003e (3 1) (set-difference list-b list-a) ;; =\u003e (4) union å¹¶é›† (union list-a list-b) ;; =\u003e (3 1 0 2 4) ;; order can be different in your lisp è¡¥é›† set-exclusive-or (set-exclusive-or list-a list-b) ;; =\u003e (4 3 1) adjoin æ·»åŠ  ä¼šè¿”å›æ–°çš„é›†åˆï¼ŒåŸæœ‰é›†åˆä¸ä¼šè¢«ä¿®æ”¹ (adjoin 3 list-a) ;; =\u003e (0 1 2 3) (adjoin 5 list-a) ;; =\u003e (5 0 1 2 3) ;; \u003c-- element added in front. list-a ;; =\u003e (0 1 2 3) ;; \u003c-- original list unmodified. subsetp æ˜¯å¦ä¸ºå­é›† (subsetp '(1 2 3) list-a) ;; =\u003e T (subsetp '(1 1 1) list-a) ;; =\u003e T (subsetp '(3 2 1) list-a) ;; =\u003e T (subsetp '(0 3) list-a) ;; =\u003e T ","date":"2022-10-04","objectID":"/data_structure/:2:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Fset-immutable data structure ä¹Ÿå¯ä»¥å»quicklisp çœ‹çœ‹FSetåº“ ","date":"2022-10-04","objectID":"/data_structure/:2:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"array å’Œ vector Arrays çš„è®¿é—®æ—¶é—´å¤æ‚åº¦æ˜¯å¸¸æ•°æ—¶é—´çš„ ä»–ä»¬å¯ä»¥æ˜¯fixed æˆ–è€… adjustableçš„ã€‚ ä¸€ä¸ªsimple array æ—¢ä¸èƒ½è¢«displaced(ç½®æ¢) ä¹Ÿä¸èƒ½è¢«adjust(è°ƒæ•´) æ›´ä¸ä¼šæœ‰fill-pointer é™¤éæˆ‘ä»¬ç”¨:displaced-to, :adjust-array,:fill-pointer æŒ‡å®š, Vector ä¸åŒäº arrayçš„åœ°æ–¹åœ¨äº ä»–çš„ç»´åº¦åªèƒ½å›ºå®šå†1ç»´ vector ä¹Ÿæ˜¯ä¸€ä¸ªåºåˆ—(sequence) ","date":"2022-10-04","objectID":"/data_structure/:3:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"åˆ›å»ºå’Œè°ƒæ•´array make-array(sizes-list :adjustable :initial-element ) common lisp è‡³å°‘å¯ä»¥æŒ‡å®š7ä¸ªç»´åº¦ï¼Œä¹°ä¸ªç»´åº¦å¯ä»¥è‡³å°‘å®¹çº³1023ä¸ªå…ƒç´ ï¼Œå¦‚æœæä¾›äº†:initial-element é‚£ä¹ˆè¿™ä¸ªå€¼ä¼šä½œä¸ºåˆå§‹å€¼ (make-array '(2 3) :initial-element nil) adjust-array(array,sizes-list :element-type : initial-element) adjust-array ç”¨äºè°ƒæ•´å‡½æ•°çš„ç»´åº¦ ","date":"2022-10-04","objectID":"/data_structure/:3:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"è®¿é—® : aref (array i [jâ€¦]) aref (array i j k â€¦) å–æŒ‡å®šç´¢å¼•ä¸Šçš„å…ƒç´  row-major-aref(array i) å’Œ (aref i i i â€¦.) ç›¸åŒ ç”¨æ¥å»ä¸»è½´ä¸Šçš„å…ƒç´  è¿”å›çš„ç»“æœéƒ½å¯ä»¥è¢«setf èµ‹å€¼ (defparameter myarray (make-array '(2 2 2) :initial-element 1)) myarray ;; =\u003e #3A(((1 1) (1 1)) ((1 1) (1 1))) (aref myarray 0 0 0) ;; =\u003e 1 (setf (aref myarray 0 0 0) 9) ;; =\u003e 9 (row-major-aref myarray 0) ;; =\u003e 9 ","date":"2022-10-04","objectID":"/data_structure/:3:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"sizes array-total-size(array): è¿”å›array ä¸­ä¸€å…±æœ‰å¤šå°‘ä¸ªå…ƒç´  array-dimensions(array): è¿”å›arrayæ¯ä¸€ç»´çš„é•¿åº¦ array-dimension(array i): è¿”å›ç¬¬iç»´çš„é•¿åº¦ array-rank: è¿”å›å‡½æ•°ä¸€å…±æœ‰å¤šå°‘ç»´ (defparameter myarray (make-array '(2 2 2))) ;; =\u003e MYARRAY myarray ;; =\u003e #3A(((0 0) (0 0)) ((0 0) (0 0))) (array-rank myarray) ;; =\u003e 3 (array-dimensions myarray) ;; =\u003e (2 2 2) (array-dimension myarray 0) ;; =\u003e 2 (array-total-size myarray) ;; =\u003e 8 ","date":"2022-10-04","objectID":"/data_structure/:3:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Vector åˆ›å»ºvector å¯ä»¥ä½¿ç”¨vector æˆ–è€…è¯»å–å® #(). ä»–ä¼šè¿”å›ä¸€ä¸ªsimple vector (vector 1 2 3) ;; =\u003e #(1 2 3) #(1 2 3) ;; =\u003e #(1 2 3) vector-push (foo vector): å°†fill-pointer æŒ‡å‘çš„å…ƒç´ æ›¿æ¢æˆfoo vector-push-extend (foo vector [extension-num])t: ä¸vector-pushç›¸ä¼¼ï¼Œä½†æ˜¯å¦‚æœfill-pointeræ¯”è¾ƒå¤§ï¼Œä»–ä¼šæ‹“å±•æ•°ç»„ vector-pop (vector): è¿”å›fill-pointer æŒ‡å‘çš„å…ƒç´  å¹¶åˆ é™¤ fill-pointer (vector). setfable.: è¿”å›arrayçš„fill-pointer and see also the sequence functions. fill-pointer fill-pointer å°±æ˜¯vector-pushè¦pushçš„indexä½ç½®ï¼ˆæˆ–è€…vector-push-extendï¼‰.ä¹Ÿå«å¡«å……å¥æŸ„ã€‚å¦‚æœä¸€ä¸ªå…ƒç´ ä»–çš„indexå¤§äºè¿™ä¸ªfill-pointer é‚£ä¹ˆä»–å°±æ˜¯activeçš„ å¦‚æœå°äºfill-pointer å°±æ˜¯inactiveçš„ ","date":"2022-10-04","objectID":"/data_structure/:3:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Hash Table ","date":"2022-10-04","objectID":"/data_structure/:4:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"åˆ›å»ºä¸€ä¸ªhash table make-hash-table åˆ›å»ºä¸€ä¸ªhash tableã€‚make-hash-table æ²¡æœ‰å¿…è¦å‚æ•°ã€‚:test å‚æ•°æŒ‡å®šç”¨æ¥åˆ¤æ–­keyæ˜¯å¦ç›¸åŒçš„å‡½æ•° Note see shorter notations in the Serapeum or Rutils libraries. For example, Serapeum has dict, and Rutils a #h reader macro. ","date":"2022-10-04","objectID":"/data_structure/:4:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"è·å–hash table ä¸­çš„å…ƒç´  gethash æ¥å—ä¸¤ä¸ªå¿…è¦å‚æ•° ä¸€ä¸ªè¦è·å–çš„å…ƒç´ çš„key ä¸€ä¸ªhash table. å®ƒè¿”å›keyç»‘å®šçš„value å’Œ ä¸€ä¸ªbool å€¼è¡¨ç¤ºæ˜¯å¦åœ¨hash tableä¸­æ‰¾åˆ°è¿™ä¸ªå€¼. å®ƒè¿˜æœ‰ä¸€ä¸ªå¯é€‰å‚æ•°default è¡¨ç¤ºæ‰¾ä¸åˆ°æ—¶çš„é»˜è®¤å€¼ (defparameter my-table (make-hash-table)) (gethash 'bar my-table 'default-value) ;; =\u003e default-value,NIL è·å– hashtableä¸­æ‰€æœ‰çš„value or key (ql:quickload \"alexandria\") (alexandria:hash-table-keys my-table) ","date":"2022-10-04","objectID":"/data_structure/:4:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"å‘hash table æ·»åŠ ä¸€ä¸ªå…ƒç´  å¯ä»¥ä½¿ç”¨gethash+setf å‘hash table ä¸­æ·»åŠ å…ƒç´  CL-USER\u003e (defparameter *my-hash* (make-hash-table)) *MY-HASH* CL-USER\u003e (setf (gethash 'one-entry *my-hash*) \"one\") \"one\" CL-USER\u003e (setf (gethash 'another-entry *my-hash*) 2/4) 1/2 CL-USER\u003e (gethash 'one-entry *my-hash*) \"one\" T CL-USER\u003e (gethash 'another-entry *my-hash*) 1/2 T ","date":"2022-10-04","objectID":"/data_structure/:4:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"åˆ¤æ–­hash table ä¸­æŸä¸ªkeyæ˜¯å¦å­˜åœ¨ gethash çš„ç¬¬ä¸€ä¸ªè¿”å›å€¼ä¼šè¿”å›å¯¹åº”keyç»‘å®šçš„value ä½†æ˜¯æœ‰çš„æ—¶å€™æˆ‘ä»¬å¯èƒ½ä¼šåˆ»æ„è®©è¿™ä¸ªvalue ä¸º nilã€‚ æ‰€ä»¥ä½¿ç”¨ç¬¬ä¸€ä¸ªè¿”å›å€¼æ˜¯ä¸å¯é çš„ã€‚ç¬¬äºŒä¸ªè¿”å›å€¼ä¼šæ˜ç¡®å‘Šè¯‰æˆ‘ä»¬è¿™ä¸ªé”®å€¼å¯¹æ˜¯å¦å­˜åœ¨ï¼Œæ‰€ä»¥åˆ¤æ–­æ˜¯å¦å­˜åœ¨å¯ä»¥è¿™æ ·ã€‚ (if (nth-value 1 (gethash 'bar my-table)) \"Key exists\" \"Key does not exist\") ","date":"2022-10-04","objectID":"/data_structure/:4:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"ä»hash table ä¸­åˆ é™¤ remhash (remove-hashçš„ç¼©å†™) ä¸“é—¨ç”¨æ¥åˆ é™¤ä¸€ä¸ªå“ˆå¸Œè¡¨æ¡ç›®ã€‚å½“hash tableä¸­æœ‰è¿™ä¸ªæ¡ç›®çš„æ—¶å€™ è¿”å›T å¦åˆ™å°±è¿”å› NIL (defparameter *my-hash* (make-hash-table)) ;; ==\u003e ,*MY-HASH* (setf (gethash 'first-key *my-hash*) 'one) ;; =\u003e ONE (gethash 'first-key *my-hash*) ;; =\u003e ONE,T (remhash 'first-key *my-hash*) ;; =\u003eT (gethash 'first-key *my-hash*) ;; =\u003e NIL,NIL CL-USER\u003e (gethash 'no-entry *my-hash*) ;; =\u003e NIL,NIL CL-USER\u003e (remhash 'no-entry *my-hash*) ;; =\u003e NIL CL-USER\u003e (gethash 'no-entry *my-hash*) ;; =\u003e NIL,NIL ","date":"2022-10-04","objectID":"/data_structure/:4:5","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"clear a hash table ä½¿ç”¨clrhash æ¸…ç©ºä¸€ä¸ªhash table (defparameter my-hash (make-hash-table)) (setf (gethash 'first-key my-hash) 'one) (setf (gethash 'second-key my-hash) 'two) my-hash ;; =\u003e #\u003chash-table :TEST eql :COUNT 2 {10097BF4E3}\u003e (clrhash my-hash) ;; =\u003e #\u003chash-table :TEST eql :COUNT 0 {10097BF4E3}\u003e (gethash 'first-key myhash) ;; =\u003e NIL,NIL (gethash 'second-key myhash) ;; =\u003e NIL,NIL ","date":"2022-10-04","objectID":"/data_structure/:4:6","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"éå†hash table ä½¿ç”¨maphash éå† (defparameter my-hash (make-hash-table)) (setf (gethash 'first-key *my-hash*) 'one) (setf (gethash 'second-key *my-hash*) 'two) (setf (gethash 'third-key *my-hash*) nil) (setf (gethash nil *my-hash*) 'nil-value) (defun print-hash-entry (key value) (format t \"The value associated with the key ~S is ~S~%\" key value)) (maphash #'print-hash-entry *my-hash*) ;; =\u003e The value associated with the key FIRST-KEY is ONE ;; =\u003e The value associated with the key SECOND-KEY is TWO ;; =\u003e The value associated with the key THIRD-KEY is NIL ;; =\u003e The value associated with the key NIL is NIL-VALUE ä½¿ç”¨with-hash-table-iterator with-hash-table-iterator æ˜¯ä¸€ä¸ªå® ä»–ä¼šä¸ºhash-table åˆ›å»ºè¿­ä»£å™¨ï¼Œæ¯æ¬¡è¿­ä»£ä¼šè¿”å›ä¸‰ä¸ªè¿”å›å€¼ ç¬¬ä¸€ä¸ªè¿”å›å€¼è¿”å›æ˜¯å¦æœ‰è¿™ä¸ªentry ç¬¬äºŒä¸ªè¿”å›å€¼è¿”å›key ç¬¬ä¸‰ä¸ªè¿”å›å€¼è¿”å›value å¦‚æœéå†åˆ°äº†æœ€åï¼Œåªä¼šè¿”å›ä¸€ä¸ªnil (with-hash-table-iterator (my-iterator my-hash) (loop (multiple-value-bind (entry-p key value) (my-iterator) (if entry-p (print-hash-entry key value) (return))))) ;; =\u003e The value associated with the key FIRST-KEY is ONE ;; =\u003e The value associated with the key SECOND-KEY is TWO ;; =\u003e The value associated with the key THIRD-KEY is NIL ;; =\u003e The value associated with the key NIL is NIL-VALUE ;; =\u003e NIL éå†keys æˆ–è€… values å¦‚æœåªæƒ³éå†keys æˆ–è€… values å¯ä»¥ä½¿ç”¨Alexandriaçš„maphash-keys å’Œ maphash-values ","date":"2022-10-04","objectID":"/data_structure/:4:7","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"è®¡ç®—hash table ä¸­çš„entry æ•°é‡ å¯ä»¥ä½¿ç”¨hash-table-count (defparameter *my-hash* (make-hash-table)) (hash-table-count *my-hash*) ;; =\u003e 0 (setf (gethash 'first *my-hash*) 1) (setf (gethash 'second *my-hash*) 2) (setf (gethash 'third *my-hash*) 3) (hash-table-count *my-hash*) (setf (gethash 'second *my-hash*) 'two) (hash-table-count *my-hash*) ;; =\u003e 3 (clrhash *my-hash*) (hash-table-count *my-hash*) ","date":"2022-10-04","objectID":"/data_structure/:4:8","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"çº¿ç¨‹å®‰å…¨çš„hash table common lisp çš„æ ‡å‡†ä¸­ï¼Œhash-tableä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä½†æ˜¯åœ¨SBCLä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç»™make-hash-tableä¼ ä¸€ä¸ª :synchronized å‚æ•°æ¥æ„é€ ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„hash table (defparameter *my-hash* (make-hash-table :synchronized t)) ä½†æ˜¯åœ¨ä¿®æ”¹æ—¶ï¼Œéœ€è¦ä½¿ç”¨sb-ext:with-locked-hash-tableå°†æ“ä½œä¿æŠ¤èµ·æ¥ (sb-ext:with-locked-hash-table (my-hash) (setf (gethash :a my-hash) :new-value)) cl-gserver library cl-gserver å®ç°äº†ä¸€å¥—actors/agent system å¯ä»¥ç®€åŒ–å¤šçº¿ç¨‹å˜æˆçš„å›°éš¾ ","date":"2022-10-04","objectID":"/data_structure/:4:9","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Alist (associated list) ä¸€ä¸ªassociation list å°±æ˜¯ä¸€ä¸ªå­˜æ”¾cons cells çš„list (defparameter *my-alist* (list (cons 'foo \"foo\") (cons 'bar \"bar\"))) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) å†…éƒ¨æ„é€ å°±åƒè¿™æ · [o|o]---[o|/] | | | [o|o]---\"bar\" | | | BAR | [o|o]---\"foo\" | FOO ","date":"2022-10-04","objectID":"/data_structure/:5:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"æ„é€  Construct ç¬¬ä¸€ç§æ–¹æ³• (setf *my-alist* '((:foo . \"foo\") (:bar . \"bar\"))) ç¬¬äºŒç§æ–¹æ³•æ˜¯ä½¿ç”¨pairlis (pairlis '(:foo :bar) '(\"foo\" \"bar\")) ;; =\u003e ((:BAR . \"bar\") (:FOO . \"foo\")) Alist å°±æ˜¯ä¸€ä¸ªlist æ‰€ä»¥ä¸€ä¸ªkeyå¯ä»¥ç»‘å®šå¤šä¸ªå€¼ (setf *alist-with-duplicate-keys* '((:a . 1) (:a . 2) (:b . 3) (:a . 4) (:c . 5))) ","date":"2022-10-04","objectID":"/data_structure/:5:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"è®¿é—® Access è¦è·å–ä¸€ä¸ªkey æˆ‘ä»¬ä½¿ç”¨assoc (å¯ä»¥æŒ‡å®š :test å¦‚æœkeyçš„ç±»å‹ä¸ºstringsé»˜è®¤ç”¨ equal) å®ƒä¼šè¿”å›æ•´ä¸ªcons cell, æ‰€ä»¥å¯ä»¥é…åˆcdr æˆ–è€…second è·å–å¯¹åº”çš„å€¼ã€‚Alexandria è¿˜æä¾›äº†assoc-value list key è¿™ä¸ªå‡½æ•°æ›´åŠ çš„æ–¹ä¾¿ (alexandria:assoc-value my-alist :foo) ;; =\u003e :foo , (:foo . \"foo\") assoc-if(predicate alist) æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³predicateçš„cons cell (setf alist '((1 . :a) (2 . :b) (3 . :c))) (assoc-if #'evenp alist) rassoc æŒ‰å€¼æŸ¥æ‰¾ (setf alist '((1 . :a) (2 . :b) (4 . :d) )) (rassoc :a alist) ;; =\u003e (1 . :a) å»é‡ ä½¿ç”¨remove-if-not è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯è¿”å›ä¸€ä¸ªåªåŒ…å«ä¸æ»¡è¶³predicateçš„åˆ—è¡¨ (remove-if-not #'(lambda (entry) (eq :a entry)) alist-with-duplicate-keys :key #'car) ","date":"2022-10-04","objectID":"/data_structure/:5:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"æ’å…¥å’Œåˆ é™¤ push æ’å…¥ä¸€ä¸ªentry (push (cons 'team \"team\") my-alist) ;; =\u003e ((TEAM . \"team\") (FOO . \"foo\") (BAR . \"bar\")) åˆ é™¤remove pop ç­‰ remove éœ€è¦æŒ‡å®škey å…³é”®å­— å‘Šè¯‰remove æ€ä¹ˆè¯»å–entry (remove 'team my-alist) ;; =\u003e ((TEAM . \"team\") (FOO . \"foo\") (BAR . \"bar\")) ;; didn't remove anything (remove 'team my-alist :key 'car) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) ;; returns a copy ","date":"2022-10-04","objectID":"/data_structure/:5:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"æ›´æ–°entries replace a value *my-alist* ;; =\u003e '((:FOO . \"foo\") (:BAR . \"bar\")) (assoc :foo *my-alist*) ;; =\u003e (:FOO . \"foo\") (setf (cdr (assoc :foo *my-alist*)) \"new-value\") ;; =\u003e \"new-value\" *my-alist* ;; =\u003e '((:foo . \"new-value\") (:BAR . \"bar\")) replace a key *my-alist* ;; =\u003e '((:FOO . \"foo\") (:BAR . \"bar\"))) (setf (car (assoc :bar *my-alist*)) :new-key) ;; =\u003e :NEW-KEY *my-alist* ;; =\u003e '((:FOO . \"foo\") (:NEW-KEY . \"bar\"))) ","date":"2022-10-04","objectID":"/data_structure/:5:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Plist (property list) plist æ˜¯ä¸€ä¸ªç®€å•åœ°list å†…éƒ¨åˆ key ,value äº¤é”™ç»„æˆã€‚ä»–çš„keyæ˜¯ä¸€ä¸ªsymbol (defparameter my-plist (list 'foo \"foo\" 'bar \"bar\")) åº•å±‚ç»“æ„å°±åƒè¿™æ · [o|o]---[o|o]---[o|o]---[o|/] | | | | FOO \"foo\" BAR \"bar\" æˆ‘ä»¬å¯ä»¥ä½¿ç”¨getf (list elt)æ¥è·å–ä¸€ä¸ªå…ƒç´ ï¼ˆè¿”å›valueï¼‰ (defparameter my-plist (list 'foo \"foo\" 'bar \"bar\")) ;; =\u003e (FOO \"foo\" BAR \"bar\") (setf (getf my-plist 'foo) \"foo!!!\") ;; =\u003e \"foo!!!\" remf ç”¨æ¥åˆ é™¤ä¸€ä¸ªå…ƒç´  (remf my-plist 'foo) ;; =\u003e (BAR \"bar\") ","date":"2022-10-04","objectID":"/data_structure/:6:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Structures ç»“æ„ä½“ structures å¯ä»¥å°†æ•°æ®å­˜å‚¨åœ¨å…·åçš„slotsä¸­ï¼Œå¹¶ä¸”æ”¯æŒå•ç»§æ‰¿ã€‚ CLOS (Common Lisp Object System)æä¾›ä¸€ä¸ªæ›´çµæ´»çš„Classes. ä½†æ˜¯structures å¯ä»¥æä¾›æ›´å¥½çš„æ€§èƒ½ ","date":"2022-10-04","objectID":"/data_structure/:7:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"å®šä¹‰ ä½¿ç”¨defstruct (defstruct person id name age) åœ¨åˆ›å»ºæ—¶ slots é»˜è®¤å€¼ä¸ºnil è¦æƒ³è‡ªå®šä¹‰é»˜è®¤å€¼ (defstruct person id (name \"john doe\") age) ä¹Ÿå¯ä»¥æŒ‡å®šé»˜è®¤ç±»å‹ (defstruct person id (name \"john doe\" :type string) age) ","date":"2022-10-04","objectID":"/data_structure/:7:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"åˆ›å»º ä½¿ç”¨make-\u003cstructure-name\u003e, å¯¹äºä¸Šé¢çš„person ä½¿ç”¨make-person (defparameter me (make-person)) ;; =\u003e ME me ;;=\u003e #S(PERSON :ID NIL :NAME \"john doe\" :AGE NIL) ä¹Ÿå¯ä»¥ä½¿ç”¨å…³é”®å­—æŒ‡å®šå‚æ•°å€¼ (defparameter me (make-person :name 123)) è¿˜å¯ä»¥è‡ªå®šä¹‰æ„é€ å‡½æ•°ï¼Œä½†æ˜¯ä¸€æ—¦è‡ªå®šä¹‰äº†æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆé»˜è®¤æ„é€ å‡½æ•°å°±å°†ä¸å‘å†è¢«ä½¿ç”¨ (defstruct (person (:constructor create-person (id name age))) id name age) ","date":"2022-10-04","objectID":"/data_structure/:7:2","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"è®¿é—®slotçš„å€¼ structureè¢«å®šä¹‰åï¼Œä¼šè‡ªåŠ¨å®šä¹‰ \u003cname-of-the-struct\u003e-+slot-nameè¿™æ ·çš„å‡½æ•° (person-name me) ","date":"2022-10-04","objectID":"/data_structure/:7:3","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"è®¾ç½®slotçš„å€¼ ä½¿ç”¨setfæ¥è®¾ç½®å€¼ (setf (person-name me) \"Cookbook author\") ","date":"2022-10-04","objectID":"/data_structure/:7:4","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"åˆ¤æ–­ç±»å‹ å°±åƒé»˜è®¤æ„é€ ï¼Œé»˜è®¤ä¹Ÿä¼šç”Ÿæˆæ–­è¨€å‡½æ•°æ¥åˆ¤æ–­ç±»å‹ (person-p me) ","date":"2022-10-04","objectID":"/data_structure/:7:5","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"é™åˆ¶ åœ¨å®šä¹‰æ”¹å˜åï¼Œå®ä¾‹å¹¶ä¸ä¼šæ›´æ–° (defstruct person id (name \"john doe\" :type string) email) attempt to redefine the STRUCTURE-OBJECT class PERSON incompatibly with the current definition [Condition of type SIMPLE-ERROR] Restarts: 0: [CONTINUE] Use the new definition of PERSON, invalidating already-loaded code and instances. 1: [RECKLESSLY-CONTINUE] Use the new definition of PERSON as if it were compatible, allowing old accessors to use new instances and allowing new accessors to use old instances. 2: [CLOBBER-IT] (deprecated synonym for RECKLESSLY-CONTINUE) 3: [RETRY] Retry SLIME REPL evaluation request. 4: [*ABORT] Return to SLIME's top level. 5: [ABORT] abort thread (#\u003cTHREAD \"repl-thread\" RUNNING {1002A0FFA3}\u003e) CLOS CLOSæ˜¯æ²¡æœ‰è¿™ç§é™åˆ¶çš„ åé¢ä¼šä»‹ç»åˆ° ","date":"2022-10-04","objectID":"/data_structure/:7:6","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Tree tree-equal,copy-tree. ä¼šè‡ªé¡¶å‘ä¸‹é€’å½’è¿›å…¥cons cell çš„car å’Œ cdr ","date":"2022-10-04","objectID":"/data_structure/:8:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"Sycamore purely functional weight-balanced binary trees https://github.com/ndantam/sycamore Features: Fast, purely functional weight-balanced binary trees. Leaf nodes are simple-vectors, greatly reducing tree height. Interfaces for tree Sets and Maps (dictionaries). Ropes Purely functional pairing heaps Purely functional amortized queue. ","date":"2022-10-04","objectID":"/data_structure/:8:1","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"æ§åˆ¶æ‰“å°å¤šå°‘æ•°æ® \\*print-length\\*, \\*print-level\\*) print-length å’Œ print-levelé»˜è®¤éƒ½ä¸ºnil é»˜è®¤ï¼Œå¦‚æœä½ æœ‰ä¸€ä¸ªéå¸¸é•¿çš„list, é‚£ä¹ˆåœ¨REPLä¸­æ‰“å°å°±ä¼šéå¸¸çš„é•¿ã€‚ä½¿ç”¨print-length æ§åˆ¶æ‰“å°å…ƒç´ çš„æœ€å¤§æ•°é‡ (setf *print-length* 2) (list :A :B :C :D :E) ;; (:A :B ...) print-levelç”¨æ¥æ§åˆ¶æ‰“å°çš„æ·±åº¦ (let ((*print-level* 2)) (print '(:a (:b (:c (:d :e)))))) ;; (:A (:B #)) \u003c= *print-level* in action ;; (:A (:B (:C (:D :E)))) \u003c= the list is returned, the let binding is not in effect anymore. ","date":"2022-10-04","objectID":"/data_structure/:9:0","tags":["common-lisp"],"title":"Common-Lisp data_structure","uri":"/data_structure/"},{"categories":["lisp"],"content":"common lisp I/O æ“ä½œ","date":"2022-10-04","objectID":"/input_output/","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"æµ å’Œå¾ˆå¤šæµè¡Œçš„è¯­è¨€ä¸€æ ·ï¼Œæµç”¨æ¥æ§åˆ¶æ•°æ®çš„è¯»å–å’Œå†™å…¥ã€‚ è¾“å…¥çš„ç¼ºçœæ˜¯*standard-input*,è¾“å‡ºçš„ç¼ºçœæ˜¯*standard-output*,è¿™ä¸¤ä¸ªæ˜¯æ ‡å‡†çš„è¾“å…¥è¾“å‡ºæµã€‚ ","date":"2022-10-04","objectID":"/input_output/:1:0","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"pathname pathname æŒ‡å®šäº†ä¸€ä¸ªæ–‡ä»¶çš„å¯ä»¥ç›´æ¥æ–¹å¼ï¼Œè·¯å¾„åŒ…å«ï¼šhostã€deviceã€directoryã€nameã€typeå’Œversionã€‚make-pathname å‡½æ•°ä¸“é—¨ç”¨æ¥æ„é€ ä¸€ä¸ªpathnameã€‚ (setf path (make-pathname :name \"myfile\")) ;; #P\"myfile ","date":"2022-10-04","objectID":"/input_output/:1:1","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"open å¼€å¯æ–‡ä»¶çš„æœ€åŸºæœ¬çš„å‡½æ•°æ—¶open, éœ€è¦ä¸€ä¸ªpathname, å’Œä¸€äº›é€‰æ‹©æ€§çš„å…³é”®å­—å‚æ•°ã€‚å¼€å¯æˆåŠŸåï¼Œä¼šåˆ›å»ºä¸€ä¸ªæ–‡ä»¶çš„æµã€‚ å‚æ•° :direction ç”¨æ¥æ§åˆ¶æµçš„æ–¹å‘å¯ä»¥ æŒ‡å®š :input è¡¨ç¤ºåªè¾“å…¥, :output è¡¨ç¤ºåªè¾“å‡º, :io è¡¨ç¤ºæ—¢å¯ä»¥è¾“å…¥ä¹Ÿå¯ä»¥è¾“å‡ºã€‚ å‚æ•° :if-exists è¯´æ˜å½“æ–‡ä»¶å·²ç»å­˜åœ¨æ—¶è¯¥æ€ä¹ˆåšï¼›é€šå¸¸ä¸:supersedeé…åˆä½¿ç”¨è¡¨ç¤ºå¦‚æœå­˜åœ¨å°±å–ä»£å®ƒ (setf str (open path :direction :output :if-exists :supersede)) ;; \u003cStream C017E6\u003e ","date":"2022-10-04","objectID":"/input_output/:1:2","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"å¯¹æµè¿›è¡Œæ“ä½œ è¾“å‡º æ‰“å¼€ä¸€ä¸ªå¯ä»¥è¾“å‡ºçš„æ–‡ä»¶ (setf str (open path :direction :output :if-exists :supersede)) æœ€ç®€å•çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨format å‡½æ•°å°†å†…å®¹è¾“å‡ºåˆ°æµä¸­ (format str \"Something~%\") ;; NIL æ­¤æ—¶æ–‡ä»¶ä¸­å¯èƒ½æœ‰Somethingè¿™ä¸ªå†…å®¹ã€‚ä¹Ÿå¯èƒ½æ²¡æœ‰ã€‚å› ä¸ºæµå¹¶ä¸ä¼šé©¬ä¸Šå°†å†…å®¹å†™å…¥æ–‡ä»¶ã€‚æˆ‘ä»¬å¯ä»¥ç›´æ¥close è¿™æ ·å†…å®¹å°±ä¼šç«‹åˆ»è¿›å…¥æ–‡ä»¶ä¸­ã€‚ (close str) ;; NIL warning è¾“å‡ºå®Œåï¼Œè®°å¾—å…³é—­æ–‡ä»¶ã€‚å› ä¸ºæµä¸ä¿è¯å†™å…¥æµçš„å†…å®¹ä¼šç«‹åˆ»ä¿å­˜åˆ°æ–‡ä»¶ä¸­ è¾“å…¥ æ‰“å¼€ä¸€ä¸ªå¯ä»¥è¾“å…¥çš„æ–‡ä»¶ (setf str (open path :direction :input)) å¯ä»¥ä½¿ç”¨read-line è¯»å–ä¸€è¡Œæ–‡å­— with-open-file å¤§éƒ¨åˆ†æ—¶é—´ï¼Œæˆ‘ä»¬ä¸ä½¿ç”¨openå’Œcloseæ¥æ“ä½œæ–‡ä»¶çš„I/Oã€‚with-open-fileå®æ›´æ–¹ä¾¿ã€‚ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªåˆ—è¡¨(stream-valueï¼Œ path ,parameters-to-open-func), ç¬¬äºŒä¸ªå‚æ•°æ˜¯è¦æ‰§è¡Œçš„ä»£ç ä¸»é¢˜ã€‚å½“ä»£ç ä¸»ä½“æ‰§è¡Œå®Œæ¯•åï¼Œè¿™ä¸ªæµå°±ä¼šè¢«è‡ªåŠ¨å…³é—­ï¼Œæ‰€ä»¥æ“ä½œè‡ªç„¶è¢«ä¿å­˜åœ¨æ–‡ä»¶ä¸­ã€‚ (with-open-file (str path :direction :output :if-exists :supersede) (format str \"Something~%\")) ","date":"2022-10-04","objectID":"/input_output/:1:3","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"æµçš„è¾“å…¥å‡½æ•° æµçš„è¾“å…¥æœ‰ä¸¤ä¸ªå¸¸ç”¨å‡½æ•°read-lineå’Œread. read-line read-line è¯»å–ä¸€è¡Œï¼Œå¹¶ç”¨å­—ç¬¦ä¸²è¿”å›ã€‚é»˜è®¤ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å– (progn (format t \"Please enter you name: \") (read-line)) read-lineæ¥å—4ä¸ªå¯é€‰å‚æ•° (read-line stream errp 'return-value-if-errp-is-nil) è¿™é‡Œerrp è¡¨ç¤ºåœ¨é‡åˆ°end-of-fileæ—¶æ˜¯å¦äº§ç”Ÿé”™è¯¯ return-value-if-errp-is-nilè¡¨ç¤ºè‹¥errpä¸ºnilåº”è¯¥è¿”å›ä»€ä¹ˆ (defun pseudo-cat (file) (with-open-file (str file :direction :input) (do ((line (read-line str nil 'eof) (read-line str nil 'eof))) ((eql line 'eof)) (format t \"~A~%\" line)))) read å¦‚æœæƒ³æŠŠreadè§£ææˆlispå¯¹è±¡ ä½¿ç”¨read. readä¸€æ¬¡è¯»å–ä¸€ä¸ªè¡¨è¾¾å¼ã€‚åœ¨è¡¨è¾¾å¼ç»“æŸæ—¶åœæ­¢è¯»å–ã€‚è¯»å–çš„å†…å®¹å¿…é¡»æ˜¯åˆæ³•çš„Lispè¯­æ³•ã€‚ ","date":"2022-10-04","objectID":"/input_output/:2:0","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"æµçš„è¾“å‡ºå‡½æ•° æµæœ‰ä¸‰ä¸ªæœ€åŸºæœ¬çš„è¾“å‡ºå‡½æ•°prin1, princ, terpri prin1å’Œ princ çš„å·®åˆ«åœ¨äºprin1 ç»™ç¨‹åºäº§ç”Ÿè¾“å‡ºï¼Œè€Œprinc ç»™äººç±»äº§ç”Ÿè¾“å‡ºã€‚ä¹Ÿå°±æ˜¯è¯´prin1äº§ç”Ÿçš„è¾“å‡ºæ˜¯ç¨‹åºå¯è¯»çš„ï¼Œè€Œprinc äº§ç”Ÿçš„è¾“å‡ºæ›´æ¥è¿‘äººçš„è¯»å–ç›´è§‰ã€‚ (prin1 \"Hello\") ;; \"Heool\" (princ \"Hello\") ;; Hello terpriåªä¼šæ‰“å°å‡ºä¸€ä¸ªæ–°è¡Œ format formatç±»ä¼¼cè¯­è¨€çš„printf å’Œå…¶ä»–è¯­è¨€ä¸­çš„æ ¼å¼åŒ–è¾“å‡ºå‡½æ•°ã€‚formatä¸»è¦çš„å¤æ‚åœ¨äºæ ¼å¼åŒ–æ§åˆ¶ï¼Œå¯ä»¥åœ¨ä½¿ç”¨çš„æ—¶å€™æŸ¥é˜…æ–‡æ¡£ï¼Œè¿™é‡Œå°±ä¸èµ˜è¿°äº†ã€‚ ","date":"2022-10-04","objectID":"/input_output/:3:0","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"å®å­—ç¬¦(Macro Characters) å®å­—ç¬¦æ˜¯è·å¾—readç‰¹åˆ«å¾…é‡çš„å­—ç¬¦ï¼Œä¸€ä¸ªå®å­—ç¬¦æˆ–è€…å®å­—ç¬¦ç»„åˆä¹Ÿå«åšread-macro(è¯»å–å®)ã€‚Common Lispé¢„å®šä¹‰çš„è¯»å–å®å¾ˆå¤šéƒ½æ˜¯ç¼©å†™ã€‚æ¯”å¦‚quoteçš„è¯»å–å®æ˜¯â€™ â€˜a ä¼šè¢«å±•å¼€æˆ (quote a) ","date":"2022-10-04","objectID":"/input_output/:4:0","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"dispatching æ´¾å‘è¯»å–å®éƒ½å·²#ä½œä¸ºæ´¾å‘å­—ç¬¦ï¼Œæ¯”å¦‚#â€˜æ˜¯(function â€¦)çš„ç¼©å†™ï¼ŒåŒæ · â€˜æ˜¯ (quote â€¦)çš„ç¼©å†™ã€‚#(â€¦)äº§ç”Ÿä¸€ä¸ªvector, #nA(â€¦)äº§ç”Ÿæ•°ç»„ï¼›#\\äº§ç”Ÿä¸€ä¸ªå­—ç¬¦; #S(n â€¦)äº§ç”Ÿä¸€ä¸ªç»“æ„ã€‚ ","date":"2022-10-04","objectID":"/input_output/:4:1","tags":["common-lisp"],"title":"Common-Lisp Input-Output","uri":"/input_output/"},{"categories":["lisp"],"content":"  \"Common Lisp Object Systemä½¿ç”¨\"\n  ","date":"2022-10-04","objectID":"/fundamental_clos/","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"CLOS is the â€œCommon Lisp Object Systemâ€, arguably one of the most powerful object systems available in any language. Some of its features include: it is dynamic, making it a joy to work with in a Lisp REPL. For example, changing a class definition will update the existing objects, given certain rules which we have control upon. it supports multiple dispatch and multiple inheritance, it is different from most object systems in that class and method definitions are not tied together, it has excellent introspection capabilities, it is provided by a meta-object protocol, which provides a standard interface to the CLOS, and can be used to create new object systems. The functionality belonging to this name was added to the Common Lisp language between the publication of Steeleâ€™s first edition of â€œCommon Lisp, the Languageâ€ in 1984 and the formalization of the language as an ANSI standard ten years later. This page aims to give a good understanding of how to use CLOS, but only a brief introduction to the MOP. To learn the subjects in depth, you will need two books: Object-Oriented Programming in Common Lisp: a Programmer`s Guide to CLOS the Art of the Metaobject Protocol ","date":"2022-10-04","objectID":"/fundamental_clos/:0:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Classes and instances å…ˆæ¥ä¸ªç®€å•çš„ä¾‹å­ åŒ…å«classçš„å®šä¹‰ï¼Œå¯¹è±¡çš„åˆ›å»ºï¼Œslotçš„è®¿é—®ï¼Œmethodsçš„æŒ‡å®šï¼Œä»¥åŠç»§æ‰¿ (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper))) ;; =\u003e #\u003cSTANDARD-CLASS PERSON\u003e (defvar p1 (make-instance 'person :name \"me\" )) ;; ^^^^ initarg ;; =\u003e #\u003cPERSON {1006234593}\u003e (name p1) ;;^^^ accessor ;; =\u003e \"me\" (lisper p1) ;; =\u003e nil ;; ^^ initform (slot unbound by default) (setf (lisper p1) t) (defclass child (person) ()) (defclass child (person) ((can-walk-p :accessor can-walk-p :initform t))) ;; #\u003cSTANDARD-CLASS CHILD\u003e (can-walk-p (make-instance 'child)) ;; T ","date":"2022-10-04","objectID":"/fundamental_clos/:1:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Defining classes (defclass) CLOSä¸­å®šä¹‰ä¸€ä¸ªæ–°çš„æ•°æ®ç±»å‹ä½¿ç”¨defclass macro (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper))) è¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªCLOS ç±»å‹ï¼ˆclassï¼‰å«åšperson,person æœ‰ä¸¤ä¸ªslot ä¸€ä¸ªå«åšname ä¸€ä¸ªå«åšlisperã€‚ (class-of p1) #\u003cSTANDARD-CLASS PERSON\u003e (type-of p1) PERSON defclass çš„é€šç”¨å½¢å¼ (defclass \u003cclass-name\u003e (list of super classes) ((slot-1 :slot-option slot-argument) (slot-2,etc)) (:optional-class-option :another-optional-class-option)) æ‰€ä»¥person class å¹¶æ²¡æœ‰æ˜¾å¼çš„ç»§æ‰¿ä»»ä½•class. ä½†æ˜¯ä»–é»˜è®¤ç»§æ‰¿äº†standard-object. æˆ‘ä»¬ä¹Ÿå¯ä»¥å†™ä¸€ä¸ªéå¸¸å°çš„class ä¸ç”¨slot options (defclass point () (x y z)) ç”šè‡³éƒ½ä¸éœ€è¦slot (defclass point()()) ","date":"2022-10-04","objectID":"/fundamental_clos/:2:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"åˆ›å»ºå¯¹è±¡(make-instance) (defvar p1 (make-instance 'person :name \"me\")) æ›´å®ç”¨çš„æ–¹æ³•æ˜¯å®šä¹‰æ„é€ å‡½æ•° (defun make-person (name \u0026key lisper) (make-instance 'person :name name :lisper lisper)) ","date":"2022-10-04","objectID":"/fundamental_clos/:3:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Slots ","date":"2022-10-04","objectID":"/fundamental_clos/:4:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"A function that always works(slot-value) åœ¨ä»»ä½•æ—¶å€™éƒ½å¯ä»¥ç”¨æ¥ç”¨æ¥è®¿é—®slotçš„å‡½æ•°æ—¶ (slot-value \u003cobject\u003e \u003cslot-name\u003e) (defvar pt (make-instance 'point)) (inspect pt) The object is a STANDARD-OBJECT of type POINT. 0. X: \"unbound\" 1. Y: \"unbound\" 2. Z: \"unbound\" è¿™æ ·ä½ å¯ä»¥è·å¾—ä¸€ä¸ªpointå¯¹è±¡ï¼Œä½†æ˜¯ä»–çš„slots é»˜è®¤æ˜¯æ²¡æœ‰ç»‘å®šçš„ï¼Œå°è¯•è®¿é—®ä»–ä»¬ä¼šå¯¼è‡´UNBOUND-SLOT condition (slot-value pt 'x) ;; =\u003e condition: the slot is unbound slot-value æ˜¯å¯ä»¥è¢«setf çš„ (setf (slot-value pt 'x) 1) (slot-value pt 'x) ;; =\u003e 1 ","date":"2022-10-04","objectID":"/fundamental_clos/:4:1","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"åˆå§‹åŒ–å’Œé»˜è®¤å€¼(initarg,initform) :initarg :foo æ˜¯ç”¨æ¥ä¼ ç»™make-instance è®©make-instance ç»™slot è®¾ç½®å€¼çš„å…³é”®å­— (make-instance 'person :name \"me\") :initform \u003cval\u003e æ˜¯å½“æˆ‘ä»¬æ²¡æœ‰æ˜¾å¼æŒ‡å®šinitargæ—¶ï¼Œè®¾ç½®çš„é»˜è®¤å€¼ã€‚åœ¨defclassçš„è¯æ³•ä½œç”¨åŸŸä¸­ (defclass foo () ((a :initarg :a :initform (error \"you didn`t supply an initial value for slot a\")))) (make-instance 'foo) ;; =\u003e enters the debugger ","date":"2022-10-04","objectID":"/fundamental_clos/:4:2","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Getters and Setters (accessor,reader,writer) :accessor foo: accessor æ—¢æ˜¯getter ä¹Ÿæ˜¯ setter. (name p1) ;; =\u003e \"me\" (type-of #'name) STANDARD-GENERIC-FUNCTION reader and writer å°±æ˜¯ä»–ä»¬æè¿°çš„åŠŸèƒ½ï¼Œåªæœ‰:writeræ˜¯setf-ableçš„ å¦‚æœä½ ä¸æŒ‡å®šä»–ä»¬ï¼Œä½ ä»ç„¶å¯ä»¥ä½¿ç”¨slot-value å‘¢å¯ä»¥æŒ‡å®šä¸æ­¢ä¸€ä¸ª:accessor,:reader æˆ–è€… :initarg è¿™é‡Œä»‹ç»ä¸¤ä¸ªmacros è®©è®¿é—®slotæ›´åŠ ç®€æ´ with-slots å¯ä»¥ä¸€æ¬¡è®¿é—®å¤šä¸ªslot-value (with-slots (name lisper) c1 (format t \"got ~a, ~a~\u0026\" name lisper)) or (with-slots ((n name) (l lisper)) c1 (format t \"got ~a, ~a~\u0026\" n l)) with-accessor ä¹Ÿå·®ä¸å¤šï¼Œä½†æ˜¯ä½¿ç”¨çš„accessor (with-accessors ((name name) (lisper lisper)) p1 (format t \"name: ~a, lisper: ~a\" name lisper)) ","date":"2022-10-04","objectID":"/fundamental_clos/:4:3","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Class VS instance slots :allocation ç”¨æ¥è¯´æ˜è¿™ä¸ªslotæ˜¯localçš„è¿˜æ˜¯shared local slot æ˜¯é»˜è®¤çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ä¾‹ä¹‹é—´æ˜¯ä¸å…±äº«çš„ è¿™æ—¶:allocation == :instance shared slot åœ¨å®ä¾‹é—´æ˜¯å…±äº«çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨:allocation :class æ¥è®¾ç½® åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œæ³¨æ„ p2çš„speciesæ§½çš„å€¼æ˜¯å¦‚ä½•å˜åŒ–çš„ï¼Œä»¥åŠæ˜¯å¦‚ä½•å½±å“æ‰€æœ‰classçš„instanceçš„ (defclass person () ((name :initarg :name :accessor name) (species :initform 'homo-sapiens :accessor species :allocation :class))) ;; Note that the slot \"lisper\" was removed in existing instances. (inspect p1) ;; The object is a STANDARD-OBJECT of type PERSON. ;; 0. NAME: \"me\" ;; 1. SPECIES: HOMO-SAPIENS ;; \u003e q (defvar p2 (make-instance 'person)) (species p1) (species p2) ;; HOMO-SAPIENS (setf (species p2) 'homo-numericus) ;; HOMO-NUMERICUS (species p1) ;; HOMO-NUMERICUS (species (make-instance 'person)) ;; HOMO-NUMERICUS (let ((temp (make-instance 'person))) (setf (species temp) 'homo-lisper)) ;; HOMO-LISPER (species (make-instance 'person)) ;; HOMO-LISPER ","date":"2022-10-04","objectID":"/fundamental_clos/:4:4","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Slot documentation ä»»ä½•slot éƒ½å¯ä»¥æ¥å—ä¸€ä¸ª:documentation option ","date":"2022-10-04","objectID":"/fundamental_clos/:4:5","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Slot type :type ç”¨æ¥æ£€æŸ¥slotçš„ç±»å‹ï¼Œä½†æ˜¯åªæœ‰å¾ˆå°‘ä¸€éƒ¨åˆ†çš„å®ç°æ”¯æŒ:type ç±»å‹æ£€æŸ¥ ","date":"2022-10-04","objectID":"/fundamental_clos/:4:6","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"find-class,class-name,class-of (find-class 'point) ;; #\u003cSTANDARD-CLASS POINT 275B78DC\u003e (class-name (find-class 'point)) ;; POINT (class-of my-point) ;; #\u003cSTANDARD-CLASS POINT 275B78DC\u003e (typep my-point (class-of my-point)) ;; T ","date":"2022-10-04","objectID":"/fundamental_clos/:5:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Subclasses å’Œ inheritance child æ˜¯ person çš„å­ç±», æ‰€æœ‰object éƒ½ç»§æ‰¿è‡ªstandard-object and t. æ‰€æœ‰child instance ä¹Ÿæ˜¯ person çš„ instance (type-of cl) ;; child (subtypep (type of cl) 'person) ;; T (ql:quickload \"closer-mop\") ;; ... (closer-mop:subclassp (class-of cl) 'person) ä¸€ä¸ªsubclass ç»§æ‰¿äº†ä»–æ‰€æœ‰çš„ parents` çš„slots, å¹¶ä¸”ï¼Œä»–å¯ä»¥è¦†ç›–çˆ¶ç±»ä»¬çš„ä»»ä½•slot options. child classçš„ä¼˜å…ˆçº§æ˜¯è¿™æ ·çš„ child \u003c- person \u003c-- standard-object \u003c- t æˆ‘ä»¬å¯ä»¥ç”¨closer-mop:class-precedence-list å»æŸ¥çœ‹ (closer-mop:class-precedence-list (class-of c1)) ;; (#\u003cstandard-class child\u003e ;; #\u003cstandard-class person\u003e ;; #\u003cstandard-class standard-object\u003e ;; #\u003csb-pcl::slot-class sb-pcl::slot-object\u003e ;; #\u003csb-pcl:system-class t\u003e) ä½†æ˜¯childçš„ç›´æ¥çˆ¶ç±»åªæ˜¯ (closer-mop:class-direct-superclasses (class-of c1)) ;; (#\u003cstandard-class person\u003e) æˆ‘ä»¬è¿˜å¯ä»¥ç”¨æ›´å¤šçš„æ–¹æ³•æ¥inspect classes,æ¯”å¦‚class-direct-[subclasses, slots, default-initargs] slots ä»¥å¦‚ä¸‹æ–¹å¼ç»“åˆ :accessor and :reader are combined by the union of accessors and readers from all the inherited slots. :initarg: the union of initialization arguments from all the inherited slots. :initform: we get the most specific default initial value form, i.e. the first :initform for that slot in the precedence list. :allocation is not inherited. It is controlled solely by the class being defined and defaults to :instance. ","date":"2022-10-04","objectID":"/fundamental_clos/:6:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Multiple inheritance (defclass baby (child person) ()) ç°ä»£è¯­è¨€ä¸æå€¡å¤šé‡ç»§æ‰¿ ","date":"2022-10-04","objectID":"/fundamental_clos/:7:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Redefining and changing a class è¿™ä¸€èŠ‚ç®€çŸ­çš„åŒ…å«ä¸¤ä¸ªè¯é¢˜ é‡å®šä¹‰å·²ç»å­˜åœ¨çš„class æ”¹å˜å·²ç»ä¸€ä¸ªclass çš„instance è¦é‡å®šä¹‰ä¸€ä¸ªclass,åªéœ€è¦åœ¨æ‰§è¡Œæ¦†æ¬¡defclass, ä»–ä¼šæ›¿æ¢æ‰€æœ‰çš„æ—§çš„å®šä¹‰ï¼ŒåŒ…æ‹¬å®ä¾‹ï¼Œç»§æ‰¿ã€‚ (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper))) (setf pl (make-instance 'person :name \"me\")) changing,adding,removing slotsâ€¦ (lisper p1) ;; NIL (defclass person () ((name :initarg :name :accessor name) (lisper :initform t ;; \u003c-- from nil to t :accessor lisper))) (lisper p1) ;; NIL (of course!) (lisper (make-instance 'person :name \"You\")) ;; T (defclass person () ((name :initarg :name :accessor name) (lisper :initform nil :accessor lisper) (age ;; \u003c-- new slot :initarg :arg :initform 18 ;; \u003c-- default value :accessor age))) (age p1) ;; =\u003e 18. Correct. This is the default initform for this new slot. (slot-value p1 'bwarf) ;; =\u003e \"the slot bwarf is missing from the object #\u003cpersonâ€¦\u003e\" (setf (age p1) 30) (age p1) ;; =\u003e 30 (defclass person () ((name :initarg :name :accessor name))) (slot-value p1 'lisper) ;; =\u003e slot lisper is missing. (lisper p1) ;; =\u003e there is no applicable method for the generic function lisper when called with arguments #(lisper). è¦æ”¹å˜ä¸€ä¸ªå®ä¾‹çš„class, å¯ä»¥ä½¿ç”¨change-class: (change-class p1 'child) ;; we can also set slots of the new class: (change p1 'child :can-walk-p nil) (class-of p1) ;; #\u003cSTANDARD-CLASS CHILD\u003e (can-walk-p p1) ;; T ","date":"2022-10-04","objectID":"/fundamental_clos/:8:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Pretty printing æ¯æ¬¡æˆ‘ä»¬æ‰“å°ä¸€ä¸ªobject æˆ‘ä»¬ä¼šè·å¾—ä¸€ä¸ªè¿™æ ·çš„è¾“å‡º #\u003cPERSON {1006234593}\u003e å¦‚æœæƒ³è¦æ›´å¤šçš„ä¿¡æ¯ï¼Œæ¯”å¦‚ #\u003cPERSON me lisper: t\u003e è¦æƒ³æ›´åŠ å¥½çœ‹çš„æ‰“å°å¯ä»¥æŒ‡å®š class çš„ generic print-object æ–¹æ³• (defmethod print-object ((obj person) stream) (print-unreadable-object (obj stream :type t) (with-accessors ((name name) (lisper lisper)) obj (format stream \"~a, lisper: ~a\" name lisper)))) p1 ;; #\u003cPERSON me, lisper: T\u003e print-unreadable-object æ‰“å°#\u003câ€¦\u003e, è¿™è¡¨æ˜ object çš„readeræ— æ³•å†æ·±å…¥çš„è¯»å–. :type t å‚æ•°è¦æ±‚ç­”åº”object-typeçš„å‰ç¼€ï¼Œä¹Ÿå°±æ˜¯ PERSON. æ²¡æœ‰å®ƒæˆ‘ä»¬ä¼šå¾—åˆ° #\u003cme,lisper: T\u003e æˆ‘ä»¬ä½¿ç”¨äº†with-accessors macro,ä½†æ˜¯å¯¹äºç®€å•çš„æƒ…å†µè¿™æ ·åšå°±å¯ä»¥äº†çš„ (defmethod print-object ((obj person) stream) (print-unreadable-object (obj stream :type t) (format stream \"~a, lisper: ~a\" (name obj) (lisper obj)))) warning å°è¯•è®¿é—®ä¸€ä¸ªæ²¡æœ‰è¢«ç»‘å®šçš„slotä¼šå¯¼è‡´é”™è¯¯ï¼Œæ‰€ä»¥åº”è¯¥å…ˆä½¿ç”¨slot-boundpåˆ¤æ–­ ä¸‹é¢çš„ä»£ç é‡ç°äº†é»˜è®¤çš„æ‰“å°æ–¹å¼ (defmethod print-object ((obj person) stream) (print-unreadable-object (obj stream :type t :identity t))) è¿™é‡Œ:identityä¸ºtæ—¶å°†ä¼šæ‰“å°åœ°å€ ","date":"2022-10-04","objectID":"/fundamental_clos/:9:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Classes of traditional lisp types è¿™èŠ‚ä¸æ˜¯å¾ˆæ˜ç™½è´´å‡ºåŸæ–‡åœ°å€å§ Classes of traditional lisp types ","date":"2022-10-04","objectID":"/fundamental_clos/:10:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Introspection å…¶å®Introspectionå°±æ˜¯å„ç§åˆ¤æ–­CLOS instanceå†…éƒ¨ç»“æ„çš„æ–­è¨€å‡½æ•°ï¼Œå¦‚æœä½ éœ€è¦éå¸¸äº†è§£è¿™äº›å‡½æ•°çš„è¯æ¨èå»çœ‹çœ‹closer-mop åº“å’ŒCLOS \u0026 MOP specifications è¿™é‡Œåˆ—å‡ºä¸€äº›å‡½æ•° closer-mop:class-default-initargs closer-mop:class-direct-default-initargs closer-mop:class-direct-slots closer-mop:class-direct-subclasses closer-mop:class-direct-superclasses closer-mop:class-precedence-list closer-mop:class-slots closer-mop:classp closer-mop:extract-lambda-list closer-mop:extract-specializer-names closer-mop:generic-function-argument-precedence-order closer-mop:generic-function-declarations closer-mop:generic-function-lambda-list closer-mop:generic-function-method-class closer-mop:generic-function-method-combination closer-mop:generic-function-methods closer-mop:generic-function-name closer-mop:method-combination closer-mop:method-function closer-mop:method-generic-function closer-mop:method-lambda-list closer-mop:method-specializers closer-mop:slot-definition closer-mop:slot-definition-allocation closer-mop:slot-definition-initargs closer-mop:slot-definition-initform closer-mop:slot-definition-initfunction closer-mop:slot-definition-location closer-mop:slot-definition-name closer-mop:slot-definition-readers closer-mop:slot-definition-type closer-mop:slot-definition-writers closer-mop:specializer-direct-generic-functions closer-mop:specializer-direct-methods closer-mop:standard-accessor-method ","date":"2022-10-04","objectID":"/fundamental_clos/:11:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"See also ","date":"2022-10-04","objectID":"/fundamental_clos/:12:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"defclass/std: write shorter classes defclass/std æä¾›äº†ä¸€ä¸ªç®€å†™defclassçš„macro é»˜è®¤ä»–ä¼šæä¾›ä¸€ä¸ªinitarg å’Œä¸€ä¸ªç»‘å®šä¸ºnilçš„initform ç»™ä½ çš„slotå®šä¹‰ æ¯”å¦‚ (defclass/std example() ((slot1 slot2 slot3))) ä¼šè¢«å±•å¼€ä¸º (defclass example() ((slot1 :accessor slot1 :initarg :slot1 :initform nil) (slot2 :accessor slot2 :initarg :slot2 :initform nil) (slot3 :accessor slot3 :initarg :slot3 :initform nil))) ä»–å¾ˆæ–¹ä¾¿çµæ´»ï¼Œä½†æ˜¯common lisp ç¤¾åŒºå¾ˆå°‘ä½¿ç”¨ä»–ï¼Œä½ å¯ä»¥è‡ªè¡Œå†³å®šæ˜¯å¦ä½¿ç”¨ä»– ","date":"2022-10-04","objectID":"/fundamental_clos/:12:1","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Methods ","date":"2022-10-04","objectID":"/fundamental_clos/:13:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"å…ˆæ¥ä¸ªæ½œå…¥ ä¹‹å‰æœ‰è¿‡person å’Œ child ç±»çš„å®šä¹‰ (defclass person() ((name :initarg :name :accessor name))) (defclass child (person) ()) (setf p1 (make-instance 'person :name \"me\")) (setf p2 (make-instance 'child :name \"Alice\")) (defmethod greet (obj) (format t \"Are you a person ? You are a ~a.~\u0026\" (type-of obj))) ;; style-warning: Implicitly creating new generic function common-lisp-user::greet. ;; #\u003cSTANDARD-METHOD GREET (t) {1008EE4603}\u003e (greet :anything) ;; Are you a person ? You are a KEYWORD. ;; NIL (greet p1) ;; Are you a person ? You are a PERSON. (defgeneric greet (obj) (:documentation \"say hello\")) ;; STYLE-WARNING: redefining COMMON-LISP-USER::GREET in DEFGENERIC ;; #\u003cSTANDARD-GENERIC-FUNCTION GREET (2)\u003e (defmethod greet ((obj person)) (format t \"Hello ~a !~\u0026\" (name obj))) ;; #\u003cSTANDARD-METHOD GREET (PERSON) {1007C26743}\u003e (greet p1) ;; =\u003e \"Hello me !\" (greet c1) ;; =\u003e \"Hello Alice !\" (defmethod greet ((obj child)) (format t \"ur so cute~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET (CHILD) {1008F3C1C3}\u003e (greet p1) ;; =\u003e \"Hello me !\" (greet c1) ;; =\u003e \"ur so cute\" ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; Method combination: before, after, around. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (defmethod greet :before ((obj person)) (format t \"-- before person~\u0026\")) #\u003cSTANDARD-METHOD GREET :BEFORE (PERSON) {100C94A013}\u003e (greet p1) ;; -- before person ;; Hello me (defmethod greet :before ((obj child)) (format t \"-- before child~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :BEFORE (CHILD) {100AD32A43}\u003e (greet c1) ;; -- before child ;; -- before person ;; ur so cute (defmethod greet :after ((obj person)) (format t \"-- after person~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :AFTER (PERSON) {100CA2E1A3}\u003e (greet p1) ;; -- before person ;; Hello me ;; -- after person (defmethod greet :after ((obj child)) (format t \"-- after child~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :AFTER (CHILD) {10075B71F3}\u003e (greet c1) ;; -- before child ;; -- before person ;; ur so cute ;; -- after person ;; -- after child (defmethod greet :around ((obj child)) (format t \"Hello my dear~\u0026\")) ;; #\u003cSTANDARD-METHOD GREET :AROUND (CHILD) {10076658E3}\u003e (greet c1) ;; Hello my dear ;; call-next-method (defmethod greet :around ((obj child)) (format t \"Hello my dear~\u0026\") (when (next-method-p) (call-next-method))) ;; #\u003cstandard-method greet :around (child) {100AF76863}\u003e (greet c1) ;; Hello my dear ;; -- before child ;; -- before person ;; ur so cute ;; -- after person ;; -- after child ;;;;;;;;;;;;;;;;; ;; Adding in \u0026key ;;;;;;;;;;;;;;;;; ;; In order to add \"\u0026key\" to our generic method, we need to remove its definition first. (fmakunbound 'greet) ;; with Slime: C-c C-u (slime-undefine-function) (defmethod greet ((obj person) \u0026key talkative) (format t \"Hello ~a~\u0026\" (name obj)) (when talkative (format t \"blah\"))) (defgeneric greet (obj \u0026key \u0026allow-other-keys) (:documentation \"say hi\")) (defmethod greet (obj \u0026key \u0026allow-other-keys) (format t \"Are you a person ? You are a ~a.~\u0026\" (type-of obj))) (defmethod greet ((obj person) \u0026key talkative \u0026allow-other-keys) (format t \"Hello ~a !~\u0026\" (name obj)) (when talkative (format t \"blah\"))) (greet p1 :talkative t) ;; ok (greet p1 :foo t) ;; still ok ;;;;;;;;;;;;;;;;;;;;;;; (defgeneric greet (obj) (:documentation \"say hello\") (:method (obj) (format t \"Are you a person ? You are a ~a~\u0026.\" (type-of obj))) (:method ((obj person)) (format t \"Hello ~a !~\u0026\" (name obj))) (:method ((obj child)) (format t \"ur so cute~\u0026\"))) ;;;;;;;;;;;;;;;; ;;; Specializers ;;;;;;;;;;;;;;;; (defgeneric feed (obj meal-type) (:method (obj meal-type) (declare (ignorable meal-type)) (format t \"eating~\u0026\"))) (defmethod feed (obj (meal-type (eql :dessert))) (declare (ignorable meal-type)) (format t \"mmh, dessert !~\u0026\")) (feed c1 :dessert) ;; mmh, dessert ! (defmethod feed ((obj child) (meal-type (eql :soup))) (declare (ignorable meal-type)) (format t \"bwark~\u0026\")) (feed p1 :soup) ;; eating (feed c1 :soup) ;; bwark ","date":"2022-10-04","objectID":"/fundamental_clos/:13:1","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Generic functions (defgeneric,defmethod) åœ¨lispæ–¹æ³•ä¸­ generic function æ˜¯ä¸€ä¸ªç›¸å…³è”çš„æ–¹æ³•é›†åˆã€‚æ‰€æœ‰åŒåçš„æ–¹æ³•éƒ½å±äºåŒä¸€ä¸ªgeneric function defmethod å’Œ defun å¾ˆç›¸ä¼¼ã€‚ä»–å°†å‡½æ•°åå’Œå‡½æ•°ä½“ç›¸å…³è”ï¼Œä½†æ˜¯å‡½æ•°ä½“åªæœ‰å½“å‚æ•°çš„ç±»å‹å’Œlambda listå®šä¹‰çš„ç±»å‹ç›¸åŒ¹é…æ—¶æ‰ä¼šè¢«æ‰§è¡Œã€‚ ä»–ä»¬å¯ä»¥æœ‰optional,keyword å’Œ \u0026restå‚æ•° lambda list lambda list å…¶å®å°±æ˜¯å‚æ•°åˆ—è¡¨ defgeneric ç”¨æ¥å®šä¹‰generic function, å¦‚æœæˆ‘ä»¬ä½¿ç”¨defmethod çš„æ—¶å€™æ²¡æœ‰å¯¹åº”çš„defgenericæ—¶ï¼Œä¸€ä¸ªgeneric functionå°±ä¼šè¢«è‡ªåŠ¨åˆ›å»º ä½¿ç”¨defgenerics æ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ï¼Œæˆ‘ä»¬å¯ä»¥æ·»åŠ é»˜è®¤çš„å®ç°ï¼Œç”šè‡³æ˜¯documentation (defgeneric greet (obj) (:documentation \"says hi\") (:method (obj) (format t \"Hi\"))) ä¸€ä¸ªæ–¹æ³•çš„lambda list æ‰€éœ€è¦çš„å‚æ•°å¯èƒ½æœ‰ä¸‰ç§å½¢å¼ a simple variable: (defmethod greet (foo) ...) è¿™ä¸ªmethod å¯ä»¥æ¥å—ä»»ä½•çš„å‚æ•° ä¸€ä¸ªvariable å’Œä¸€ä¸ªspecializer (defmethod greet ((foo person)) ...) åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œfoo è¢«ç»‘å®šåªæœ‰ç‰¹å®šçš„class æ¯”å¦‚person å’Œå…¶ subclassæ‰èƒ½ä½¿ç”¨è¿™ä¸ªæ–¹æ³• å¦‚æœå‚æ•°ä¸specializerä¸åŒ¹é…ï¼Œé‚£ä¹ˆå°±ä¼šæŠ¥é”™ å¯¹äºoptional \u0026key å‚æ•°æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨specialize a variable å’Œä¸€ä¸ªeql specializer (defmethod feed ((obj child) (meal-type (eql :soup))) (declare (ignorable meal-type)) (format t \"bwark~\u0026\")) (feed cl :soup) ;; \"bwark\" ä½ å¯ä»¥å®šä¹‰å¾ˆå¤šåŒåçš„å‡½æ•°ï¼Œåªè¦ä»–ä»¬çš„specializersä¸åŒã€‚ç³»ç»Ÿä¼šé€‰æ‹©æœ€å…·ä½“çš„å‡½æ•°è¿›è¡Œè°ƒç”¨ã€‚é€šç”¨å‡½æ•°è°ƒç”¨çš„ä¼˜å…ˆçº§æ˜¯ å‚æ•°å†³å®šäº†ä¸€ä¸ªæˆ–å¤šä¸ªå¯ç”¨æ–¹æ³•ï¼Œå¦‚æœåœ¨è°ƒç”¨ä¸­çš„å‚æ•°å’Œå‚æ•°çš„specializersåŒ¹é…ï¼Œé‚£ä¹ˆå‚æ•°å¯ç”¨ å¦‚æœæ²¡æœ‰å¯ç”¨æ–¹æ³•ï¼Œå°±ä¼šæŠ¥é”™. å¦‚æœåªæœ‰ä¸€ä¸ªï¼Œç«‹åˆ»è°ƒç”¨ å¦‚æœå¤šäºä¸€ä¸ªï¼Œæœ€å…·ä½“çš„ä¼šè¢«è°ƒç”¨ã€‚ æœ€å…·ä½“å¯ç”¨çš„æ–¹æ³•ç”±ä¼ å…¥å‚æ•°æ‰€å±ç±»åˆ«çš„ä¼˜å…ˆçº§å†³å®šã€‚ç”±å·¦å¾€å³å®¡è§†å‚æ•°ã€‚å¦‚æœæœ‰ä¸€ä¸ªå¯ç”¨æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œæ­¤å‚æ•°ç‰¹åŒ–ç»™æŸä¸ªç±»ï¼Œå…¶ç±»çš„ä¼˜å…ˆçº§é«˜äºå…¶å®ƒå¯ç”¨æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œåˆ™æ­¤æ–¹æ³•å°±æ˜¯æœ€å…·ä½“çš„å¯ç”¨æ–¹æ³•ã€‚å¹³æ‰‹æ—¶æ¯”è¾ƒç¬¬äºŒä¸ªå‚æ•°ï¼Œä»¥æ­¤ç±»æ¨ã€‚ notes It is an error to define a method with the same function name as an ordinary function. If you really want to do that, use the shadowing mechanism. To add or remove keys or rest arguments to an existing generic methodâ€™s lambda list, you will need to delete its declaration with fmakunbound (or C-c C-u (slime-undefine-function) with the cursor on the function in Slime) and start again. Otherwise, youâ€™ll see: Methods can be redefined (exactly as for ordinary functions). The order in which methods are defined is irrelevant, although any classes on which they specialize must already exist. An unspecialized argument is more or less equivalent to being specialized on the class t. The only difference is that all specialized arguments are implicitly taken to be â€œreferred toâ€ (in the sense of declare ignore.) Each defmethod form generates (and returns) a CLOS instance, of class standard-method. An eql specializer wonâ€™t work as is with strings. Indeed, strings need equal or equalp to be compared. But, we can assign our string to a variable and use the variable both in the eql specializer and for the function call. All the methods with the same function name belong to the same generic function. All slot accessors and readers defined by defclass are methods. They can override or be overridden by other methods on the same generic function. ","date":"2022-10-04","objectID":"/fundamental_clos/:13:2","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Multimethods mutlimethods æ˜¾å¼çš„æŒ‡å‡ºï¼Œå‡½æ•°çš„parametersä¸æ­¢ä¸€ä¸ªã€‚è€Œä¸”æˆ‘ä»¬å¾ˆéš¾ç¡®å®šä»–åˆ°åº•å±äºé‚£ä¸ªclass #+begin_src lisp (defgeneric hug (a b) (:documentation â€œHug between two personsâ€)) (defmethod hug ((a person) (b person)) :person-person-hug) (defmethod hug ((a person) (b child)) :person-child-hug) #+end_src ","date":"2022-10-04","objectID":"/fundamental_clos/:14:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"æ§åˆ¶setters (setf-ing methods) åœ¨lisp ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰setf counterparts of functions or methods. æˆ‘ä»¬å¯èƒ½æƒ³åœ¨å¦‚ä½•æ›´æ–°objectä¸Š è·å¾—æ›´å¤šçš„æ§åˆ¶ (defmethod (setf name) (new-val (obj person)) (if (equalp new-val \"jame bond\") (format t \"Dude that`s not possible.~\u0026\") (setf (slot-value obj 'name) new-val))) (setf (name p1) \"james bond\") ;; -\u003e no rename ","date":"2022-10-04","objectID":"/fundamental_clos/:15:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Dispatch mechanism and next methods è¿™æ®µä¸è®²äº†ï¼Œç°ä»£è¯­è¨€ç”¨çš„ä¸å¤šï¼Œæ„Ÿè§‰æœ‰ç‚¹ç³Ÿç²•äº†ã€‚æœ‰å…´è¶£è‡ªå·±å»çœ‹å§ Dispatch mechanism and next methods ","date":"2022-10-04","objectID":"/fundamental_clos/:16:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Method qualifiers (before,after,around) è¿™ä¸ªä¹Ÿæ˜¯ç‰›ç‰›ç‰›ï¼Œä½†æ˜¯æˆ‘å­¦è¿‡çš„è¯­è¨€éƒ½æ²¡è¿™ä¸ªã€‚ä¹Ÿæ˜¯è‡ªå·±å»çœ‹å§ Method qualifiers ","date":"2022-10-04","objectID":"/fundamental_clos/:17:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"Other method combinations è¿™ä¸ªæ›´ç¦»è°±ï¼Œè‡ªå·±å»çœ‹ other method combinations ","date":"2022-10-04","objectID":"/fundamental_clos/:18:0","tags":["common-lisp"],"title":"Common-Lisp Fundamental CLOS","uri":"/fundamental_clos/"},{"categories":["lisp"],"content":"common lisp çš„é”™è¯¯å’Œå¼‚å¸¸å¤„ç†","date":"2022-10-04","objectID":"/error_and_exception_handlering/","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"è¿™ä¸€èŠ‚ååŠæ®µéœ€è¦CLOSçš„çŸ¥è¯†, æ‰€ä»¥ä¸ºäº†ä¸äº§ç”Ÿç–‘æƒ‘ï¼Œåœ¨è¯»åˆ°define-conditionçš„æ—¶å€™å…ˆå»çœ‹çœ‹CLOS CLOS ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:0:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"Ignoring all errors, returning nil æœ‰æ—¶å€™ä½ çŸ¥é“å‡½æ•°ä¼šå¤±è´¥ï¼Œå¹¶ä¸”ä½ æƒ³å¿½ç•¥è¿™ä¸ªé”™è¯¯ï¼Œå¯ä»¥ä½¿ç”¨ignore-errors (ignore-errors (/ 3 0)) ; in: IGNORE-ERRORS (/ 3 0) ; (/ 3 0) ; ; caught STYLE-WARNING: ; Lisp error during constant folding: ; arithmetic error DIVISION-BY-ZERO signalled ; Operation was (/ 3 0). ; ; compilation unit finished ; caught 1 STYLE-WARNING condition NIL #\u003cDIVISION-BY-ZERO {1008FF5F13}\u003e 3/0 æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œæˆ‘ä»¬æ”¶åˆ°äº†è­¦å‘Šã€‚ä½†æ˜¯å‡½æ•°ä¼šæ­£å¸¸è¿”å›nilï¼Œå‡½æ•°æ‰§è¡Œçš„çŠ¶æ€è¢«è¿”å›ï¼Œå¤±è´¥äº†ã€‚ ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:1:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"Catching any condition (handler-case) ignore-errorsæ˜¯å»ºç«‹åœ¨handler-caseä¸Šçš„ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡æ•è·erré‡å†™ä¸Šé¢çš„ä¾‹å­,ä½†æ˜¯æˆ‘ä»¬å¯ä»¥è¿”å›æˆ‘ä»¬æƒ³è¿”å›çš„ä¸œè¥¿ (handler-case (/ 3 0) (error (c) (format t \"We caught a condition.~\u0026\") (values 0 c))) ; in: HANDLER-CASE (/ 3 0) ; (/ 3 0) ; ; caught STYLE-WARNING: ; Lisp error during constant folding: ; Condition DIVISION-BY-ZERO was signalled. ; ; compilation unit finished ; caught 1 STYLE-WARNING condition We caught a condition. 0 #\u003cDIVISION-BY-ZERO {1004846AE3}\u003e å¯ä»¥çœ‹åˆ°æˆ‘ä»¬è¿”å›äº†0 å’Œ c handler-caseçš„é€šç”¨æ¨¡æ¿æ˜¯ (handler-case (code that errors out) (condition-type (the-condition) ;; \u003c-- optional argument (code)) (another-condition (the-condition) ...)) æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨t æ¥æ•è·æ¡ä»¶ (handler-case (progn (format t \"This won`t work...~%\") (/3 0)) (t (c) (format t \"Got an exception: ~a~%\" c) (values 0 c))) ;; â€¦ ;; This won't workâ€¦ ;; Got an exception: arithmetic error DIVISION-BY-ZERO signalled ;; Operation was (/ 3 0). ;; 0 ;; #\u003cDIVISION-BY-ZERO {100608F0F3}\u003e ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:2:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"æ•è·ä¸€ä¸ªç‰¹æ®Šçš„æ¡ä»¶ æˆ‘ä»¬å¯ä»¥æŒ‡å®šå“ªäº›æ¡ä»¶éœ€è¦å¤„ç† (handler-case (/ 3 0) (division-by-zero (c) (format t \"Caught division by zero: ~a~%\" c))) ;; â€¦ ;; Caught division by zero: arithmetic error DIVISION-BY-ZERO signalled ;; Operation was (/ 3 0). ;; NIL è¿™ä¸ªå’Œtry/catchå½¢å¼éå¸¸åƒï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥åšæ›´å¤šçš„äº‹æƒ… ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:3:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"handler-case vs handler-bind handler-caseå’Œå…¶ä»–è¯­è¨€çš„try/catchéå¸¸åƒ handler-bind ç”¨åœ¨å“ªäº›å½“é”™è¯¯å‡ºç°æ—¶æˆ‘ä»¬éœ€è¦ç»å¯¹æ§åˆ¶çš„æƒ…å†µä¸‹ã€‚ä»–å…è®¸æˆ‘ä»¬äº¤äº’çš„ä½¿ç”¨debuggerå’Œç¼–ç¨‹åŒ–çš„restart, ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:4:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"defining and make conditions æˆ‘ä»¬å¯ä»¥ä½¿ç”¨define-condition å®šä¹‰condtionsï¼Œä½¿ç”¨make-condition åˆå§‹åŒ–ä»–ä»¬ (define-condition my-division-by-zero (error) ()) (make-condition 'my-division-by-zero) ;; #\u003cMY-DIVISION-BY-ZERO {1005A5FE43}\u003e å®šä¹‰conditionæ—¶ï¼Œæœ€å¥½ç»™å‡ºæ›´å¤šçš„ä¿¡æ¯ (define-condition my-division-by-zero (error) ((dividend :initarg :dividend :initform nil :reader dividend)) ;; \u003c-- we'll get the dividend with (dividend condition). See the CLOS tutorial if needed. (:documentation \"Custom error when we encounter a division by zero.\")) ;; good practice ;) ","date":"2022-10-04","objectID":"/error_and_exception_handlering/:5:0","tags":["common_lisp"],"title":"Common-lisp Error and Exception Handling","uri":"/error_and_exception_handlering/"},{"categories":["lisp"],"content":"common lisp çš„æ–‡ä»¶å’Œæ–‡ä»¶å¤¹æ“ä½œ","date":"2022-10-04","objectID":"/file_and_directory/","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"æœ¬èŠ‚ä¸»è¦ä»‹ç»UIOPä¸­çš„ä¸€äº›æœ‰å…³æ–‡ä»¶å’Œæ–‡ä»¶æ“ä½œæ–¹é¢çš„ä½¿ç”¨ã€‚è·å–ä½ ä¹Ÿåº”è¯¥ç›´æ¥çœ‹ä¸€çœ‹UIOPçš„å®˜æ–¹æ–‡æ¡£. UIOP å½“ç„¶ï¼Œä¹Ÿåˆ«å¿˜äº† Files and File I/O in Practicial Common Lisp ","date":"2022-10-04","objectID":"/file_and_directory/:0:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"æµ‹è¯•æ–‡ä»¶æ˜¯å¦å­˜åœ¨ probe-file ä¸“é—¨ç”¨æ¥æµ‹è¯•æ–‡ä»¶æ˜¯å¦å­˜åœ¨ã€‚å¦‚æœè¿”å›Nilæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›truenameåˆ™æ–‡ä»¶å­˜åœ¨ truename Many file systems permit more than one filename to designate a particular file. Even where multiple names are possible, most file systems have a convention for generating a canonical filename in such situations. Such a canonical filename (or the pathname representing such a filename) is called a truename. ä¸ºäº†å¯ç§»æ¤æ€§ï¼Œå¯ä»¥ä½¿ç”¨è¿”å›pathnameçš„uiop:probe-file* æˆ–è€…uiop:file-exists-pï¼ˆå¦‚æœæ–‡ä»¶å­˜åœ¨çš„è¯ï¼‰ $ ln -s /etc/passwd foo (probe-file \"/etc/passwd\") #p\"/etc/passwd\" (probe-file \"foo\") #p\"/etc/passwd\" (probe-file \"bar\") NIL ","date":"2022-10-04","objectID":"/file_and_directory/:1:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"å±•å¼€~ï¼ˆå®¶ç›®å½•ç¯å¢ƒå˜é‡ï¼‰ æˆ‘ä»¬ä½¿ç”¨uiop:native-namestring: (uiop:native-namestring \"~/.emacs.d/\") å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œä»–ä¹Ÿä¼šè¢«å±•å¼€ (uiop:native-namestring \"~/foo987.txt\") ;; \"/home/me/foo987.txt\" åœ¨è®¸å¤šlispå®ç°ä¸Š(CCL,ABCL,ECL,CLISP,LispWorks),namestring å¾ˆåƒã€‚åœ¨ SBCLä¸Šï¼Œå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œæˆ–è€…ç›®å½•ä¸å­˜åœ¨ï¼Œnamestringä¸ä¼šå±•å¼€path è€Œæ˜¯ç›´æ¥è¿”å›å‚æ•° è¦æµ‹è¯•æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¹Ÿå¯ä»¥ä½¿ç”¨truename,ä½†æ˜¯åœ¨SBCLä¸Šï¼Œå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œä¼šç›´æ¥è¿”å›é”™è¯¯ã€‚ ","date":"2022-10-04","objectID":"/file_and_directory/:2:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"åˆ›å»ºæ–‡ä»¶å¤¹ (ensure-directories-exist \"fbbboo/bar/baz/\") è¿™æ ·ä¼šåˆ›å»ºfbbboo bar baz ä¸è¦å¿˜è®°åœ¨å°¾éƒ¨åŠ ä¸Šæ–œæ  ","date":"2022-10-04","objectID":"/file_and_directory/:3:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"åˆ é™¤æ–‡ä»¶å¤¹ uiop:delete-directory-tree å’Œä¸€ä¸ªpathname(#p),ä¸€ä¸ªå°¾éƒ¨æ–œæ  å’Œ:validate (uiop:delete-directory-tree #p\"dirtest/\" :validate t) ä¹Ÿå¯ä»¥ä½¿ç”¨pathname å‡½æ•°åˆ›å»ºä¸€ä¸ªpathname (defun rmdir (path) (uiop:delete-directory-tree (pathname path) :validate t)) uiop è¿˜æœ‰ä¸€ä¸ªdelete-empty-directory ç”¨æ¥åˆ é™¤ç©ºçš„æ–‡ä»¶å¤¹ ","date":"2022-10-04","objectID":"/file_and_directory/:4:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"åˆå¹¶æ–‡ä»¶å’Œæ–‡ä»¶å¤¹ merge-pathnames ä¸“ç”¨æ¥åˆå¹¶è·¯å¾„ï¼Œå¦‚æœä½ æƒ³åœ¨åé¢æ·»åŠ ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œç¬¬äºŒä¸ªå‚æ•°å¿…é¡»å¸¦ä¸Šæœ«å°¾æ–œæ  (merge-pathnames \"otherpath\" \"/home/vince/projects/\") ;; =\u003e #p\"/home/vince/projects/otherpath\" è¿™é‡Œotherpathè¢«å½“åšæ–‡ä»¶ (merge-pathnames \"otherpath\" \"/home/vince/projects\") ;; #P\"/home/vince/otherpath\" ;; ^^ no \"projects\", because it was seen as a file. (merge-pathnames \"otherpath/\" \"/home/vince/projects\") ;; #P\"/home/vince/otherpath/projects\" ;; ^^ inserted here ","date":"2022-10-04","objectID":"/file_and_directory/:5:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"è·å–å½“å‰ç›®å½•(CWD) ä½¿ç”¨uiop/os:getcwd: (uiop/os:getcwd) ;; #P\"/home/vince/projects/cl-cookbook/\" ;; ^ with a trailing slash, useful for merge-pathnames ","date":"2022-10-04","objectID":"/file_and_directory/:6:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"è·å–ä»¥lispå·¥ç¨‹ä¸ºæ ¹ç›®å½•çš„ç›¸å¯¹è·¯å¾„çš„ç»å¯¹è·¯å¾„ ä½¿ç”¨asdf:system-relative-pathname system path. (asdf:system-relative-pathname \"mysystem\" \"src/web\") ;; =\u003e #P\"/home/vince/projects/mysystem/src/web/\" ","date":"2022-10-04","objectID":"/file_and_directory/:7:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"opening a file æ‰“å¼€æ–‡ä»¶å…¶å®ä¹‹å‰æœ‰å†™è¿‡ï¼Œè¿™é‡Œä¸èµ˜è¿°ã€‚ç›´æ¥ç»™å‡ºcookbook çš„è¿æ¥ï¼ˆä¸»è¦ï¼Œæˆ‘è‡ªå·±å·²ç»çœ‹è¿‡äº†,ä¸æƒ³å¤šå†™å“ˆå“ˆå“ˆå“ˆï¼‰ opening a file ä¹Ÿå¯ä»¥å»çœ‹çœ‹æˆ‘ä¹‹å‰å†™çš„Input-Output ","date":"2022-10-04","objectID":"/file_and_directory/:8:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"Reading files ","date":"2022-10-04","objectID":"/file_and_directory/:9:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"å°†æ–‡ä»¶è¯»å…¥string æˆ– è¡Œlistä¸­ read-file-string (uiop:read-file-string \"file.txt\") read-file-lines (uiop:read-file-lines \"file.txt\") ","date":"2022-10-04","objectID":"/file_and_directory/:9:1","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"read-line or read-char è¿™ä¸¤ä¸ªå‡½æ•°çš„æ€§èƒ½ä¸é«˜ï¼Œå¯ä»¥åŠ å…¥ç¼“å†²åŒºè§£å†³è¿™ä¸ªé—®é¢˜ (with-output-to-string (out) (with-open-file (in \"/path/to/big/file\") (loop with buffer = (make-array 8192 :element-type 'character) for n-characters = (read-sequence buffer in) while (\u003c 0 n-characters) do (write-sequence buffer out :start 0 :end n-characters)))) ","date":"2022-10-04","objectID":"/file_and_directory/:9:2","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"ä»¥utf-8çš„æ ¼å¼è¯»å– (with-open-file (in \"/path/to/big/file\" :external-format :utf-8) ) ","date":"2022-10-04","objectID":"/file_and_directory/:9:3","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"å°†SBCLçš„é»˜è®¤å­—ç¬¦é›†è®¾ä¸ºutf-8 åœ¨~/.sbclrcä¸­åŠ å…¥ (setf sb-impl::*default-external-format* :utf-8) æˆ–è€… (setf sb-alien::*default-c-string-external-format* :utf-8) ","date":"2022-10-04","objectID":"/file_and_directory/:9:4","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"å‘æ–‡ä»¶ä¸­å†™å…¥å†…å®¹ (with-open-file (f \u003cpathname\u003e :direction :output :if-exists :supersede :if-does-not-exist :create) (write-sequence s f)) å¦‚æœæ–‡ä»¶å­˜åœ¨ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨:append æ¥è¿½åŠ å†…å®¹ ä½¿ç”¨åº“ Alexandria æœ‰ä¸€ä¸ªå‡½æ•°å«write-string-into-file (alexandria:write-string-into-file content \"file.txt\") ","date":"2022-10-04","objectID":"/file_and_directory/:9:5","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"è·å–æ–‡ä»¶åç¼€ (pathname-type \"~/foo.org\") ;; =\u003e \"org\" ","date":"2022-10-04","objectID":"/file_and_directory/:10:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"è·å–æ–‡ä»¶å±æ€§(size,access time,â€¦.) Osicat(in quicklisp)æ˜¯ä¸€ä¸ªè½»é‡çº§æ“ä½œç³»ç»Ÿæ¥å£ã€‚ä½¿ç”¨Osicat å¯ä»¥è·å–ç¯å¢ƒå˜é‡ï¼Œæ“ä½œfiles directories pathnames (ql:quickload \"osicat\") (let ((stat (osicat-posix:stat #P\"./files.md\"))) (osicat-posix:stat-size stat)) ;; =\u003e 10629 å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‡½æ•°è·å–æ›´å¤šçš„å±æ€§ osicat-posix:stat-dev osicat-posix:stat-gid osicat-posix:stat-ino osicat-posix:stat-uid osicat-posix:stat-mode osicat-posix:stat-rdev osicat-posix:stat-size osicat-posix:stat-atime osicat-posix:stat-ctime osicat-posix:stat-mtime osicat-posix:stat-nlink osicat-posix:stat-blocks osicat-posix:stat-blksize ","date":"2022-10-04","objectID":"/file_and_directory/:11:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"åˆ—å‡ºæ‰€æœ‰çš„æ–‡ä»¶å’Œæ–‡ä»¶å¤¹ æœ‰äº›å‡½æ•°å¯ä»¥è¿”å›pathnames (namestring #p\"/foo/bar/baz.txt\") ==\u003e \"/foo/bar/baz.txt\" (directory-namestring #p\"/foo/bar/baz.txt\") ==\u003e \"/foo/bar/\" (file-namestring #p\"/foo/bar/baz.txt\") ==\u003e \"baz.txt\" ","date":"2022-10-04","objectID":"/file_and_directory/:12:0","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"è¿”å›æ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶(ä¸åŒ…æ‹¬æ–‡ä»¶å¤¹) (uiop:directory-files \"./\") è¿”å›ä¸€è¿ä¸²çš„pathnames: (#P\"/home/vince/projects/cl-cookbook/.emacs\" #P\"/home/vince/projects/cl-cookbook/.gitignore\" #P\"/home/vince/projects/cl-cookbook/AppendixA.jpg\" #P\"/home/vince/projects/cl-cookbook/AppendixB.jpg\" #P\"/home/vince/projects/cl-cookbook/AppendixC.jpg\" #P\"/home/vince/projects/cl-cookbook/CHANGELOG\" #P\"/home/vince/projects/cl-cookbook/CONTRIBUTING.md\" [â€¦] ","date":"2022-10-04","objectID":"/file_and_directory/:12:1","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"},{"categories":["lisp"],"content":"è¿”å›æ‰€æœ‰çš„å­æ–‡ä»¶å¤¹ (uiop:subdirectories \"/Users/qibinyang/test\") (#P\"/Users/qibinyang/test/assertTest/\" #P\"/Users/qibinyang/test/center/\" #P\"/Users/qibinyang/test/client1/\" #P\"/Users/qibinyang/test/client2/\" #P\"/Users/qibinyang/test/test/\") ","date":"2022-10-04","objectID":"/file_and_directory/:12:2","tags":["common-lisp"],"title":"Common-Lisp File and Directory","uri":"/file_and_directory/"}]