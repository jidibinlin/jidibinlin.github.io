[{"categories":["lisp"],"content":"有关common lisp 的循环，和一些小技巧","date":"2022-04-22","objectID":"/loop-iteration-mapping/","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"Introduction: loop,iterate,for,mapcar,series ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:0","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"loop loop 是一个内置的用来迭代的宏, 它最简单的形式是(loop (print “hello”)): 这个语句会无限打印\"hello\" 一个简单的迭代List的例子 (loop for x in '(1 2 3) do (print x)) 这个例子会返回Nil但是会打印他应该打印的 如果你需要将结果收集成一个list使用collect (loop for x in '(1 2 3) collect (* x 10)) loop 表达式有四个部分 设置要被迭代的变量 结束迭代的条件表达式 每次迭代要做的事情 每次退出时要做的事情 除此之外,loop表达式还能返回一个值 正常来说，我们很少使用所有的部分，但是我们可以随意组合他们 ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:1","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"iterate iterate 是一个很流行的迭代宏，要比loop更容易懂，但是拓展性要差一些。iterate并不是内置的，要先导入a。 (ql:quickload \"iterate\") (ues-package :iterate) iterate看起来是这样的 (iter (for in from 1 to 5) (collect (* i i))) warning 如果同时使用iterate 和 loop 会有命名冲突 使用display-iterate-clauses可以解决这个问题 (display-iterate-clauses '(for)) ;; FOR PREVIOUS \u0026OPTIONAL INITIALLY BACK Previous value of a variable ;; FOR FIRST THEN Set var on first, and then on subsequent iterations ;; ... ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:2","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"for for是一个可拓展的迭代宏，通常要比loop短。 for的最大好处就是，可以用在任何数据类型上(lists,vectors,hash-tables…) (for:for ((x over \u003cyour data structure\u003e)) (print ...)) for是一个第三方库，需要先quickload (ql:quickload \"for\") ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:3","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"map族 后面还有很多mapcar 和 map这样的例子。map 族还有mapcon,mapcan,maplist,mapc 和 mapl. (mapcar (lambda (it) (+ it 10)) '(1 2 3)) ;; =\u003e (11 12 13) map 更加通用 他可以接受List 和 vectors 作为参数，需要在第一个参数指定结果类型 (map 'vector (lambda (it) (+ it 10)) '(1 2 3)) ;; #(11 12 13) (map 'list (lambda (it) (+ it 10)) #(1 2 3)) ;; (11 12 13) (map 'string (lambda (it) (code-char it)) '#(97 98 99)) ;; \"abc\" 简写lambda函数 是不是觉得写lambda太烦， 其实有一些库可以提供简写lambda函数方法你可以去这里看看简写lambda的库有哪些lambda shorthand libraries 这里给出一个cl-punch的例子 (mapcar ^(* _ 10) '(1 2 3)) ;; =\u003e (10 20 30) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:4","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"series 最后 你可能会喜欢series,一个库通过结合sequences,streams,和loop 来描述自己. Series 表达式看起来就像是在操作序列，但是可以获得相比loop 更高的效率。 Series第一次出现在 “Common Lisp the Language” (collect (mapping ((x (scan-range :from 1 :upto 5))) (* x x))) ;; =\u003e (1 4 9 16 25) Generators The Way I Want Them Generated Library 这是一个lazy sequences 库，和series类似，景观他很年轻，切不完全，但是他有很多现代化的API 比如take,filter,for,fold 并且易用 range :from 20) ;; #\u003cGTWIWTG::GENERATOR! {1001A90CA3}\u003e (take 4 (range :from 20)) ;; (20 21 22 23) ","date":"2022-04-22","objectID":"/loop-iteration-mapping/:1:5","tags":["common-lisp"],"title":"common lisp 循环操作","uri":"/loop-iteration-mapping/"},{"categories":["lisp"],"content":"common-lisp 中与number相关的知识点","date":"2022-04-22","objectID":"/numbers/","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"integer types CL 提供一个true integer类型，叫bignum,只受内存控制。 为了效率考虑，integers 可以被限制成fixnum type。integers 的范围可以这样查看 most-positive-fixnum 4611686018427387903 most-negative-fixnum -4611686018427387904 integer 相关的函数有 isqrt, 返回小于且最接近于指定数的平方根 (isqrt 10) ;; =\u003e 3 (isqurt 4) ;; =\u003e 2 gcd 返回最大的公分母 lcm 返回最小的公倍数 CL还提供了表示16进制和其他进制的方法 #xFF ;; =\u003e 255 #2r1010 ;; =\u003e 10 #4r33 ;; =\u003e 15 #8r11 ;; =\u003e 9 #16rFF ;; =\u003e 255 #36rz ;; =\u003e 35 ","date":"2022-04-22","objectID":"/numbers/:1:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"有理数 ratio 类型由两个bignums组成 * (/ (1+ (expt 2 100)) (expt 2 100)) 1267650600228229401496703205377/1267650600228229401496703205376 ratio 是 rational 的子类型 ","date":"2022-04-22","objectID":"/numbers/:2:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"浮点类型 CL 提供精度由小到大排列的short-float, single-float, double-float, and long-float 类型 常量short-float-epsilon, single-float-epsilon, double-float-epsilon and long-float-epsilon 表示了浮点类型的精度 ","date":"2022-04-22","objectID":"/numbers/:3:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"floating point literals (浮点字面量) *read-default-float-format*控制了浮点数读取的默认类型，默认是single-float,如果你想读入双精度的浮点数，你需要d0后缀 (type-of 1.24) ;; =\u003e SINGLE-FLOAT (type-of 1.24d0) ;; =\u003e DOUBLE-FLOAT Other suffixes are s (short), f (single float), d (double float), l (long float) and e (default; usually single float). 默认的type 是可以修改的 (setq *read-default-float-format* 'double-float) (type-of 1.24) ;; =\u003e DOUBLE-FLOAT warning 和其他语言不同的是，在十进制后面加小数点并不能将该数表示成浮点数 (type-of 10.) ;; =\u003e (INTEGER 0 4611686018427387903) (type-of 10.0) ;; =\u003e SINGLE-FLOAT ","date":"2022-04-22","objectID":"/numbers/:3:1","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"Float point errors 这个错误一般发生在小数点溢出的时候 (exp 1000) ;; Evaluation aborted on #\u003cFLOATING-POINT-OVERFLOW {10041720B3}\u003e. 这个错误可以被捕获和解决，或者他的行为可以被改变 (sb-int:set-floating-point-modes :traps '(:INVALID :DIVIDE-BY-ZERO)) (exp 1000) ;; =\u003e #.SB-EXT:SINGLE-FLOAT-POSITIVE-INFINITY (/ 1 (exp 1000)) ;; =\u003e 0.0 现在不会报任何的错误 在sbcl中，float-point 的模式可以被检查 (sb-int:get-floating-point-modes) ;; =\u003e (:TRAPS (:OVERFLOW :INVALID :DIVIDE-BY-ZERO) :ROUNDING-MODE :NEAREST ;; :CURRENT-EXCEPTIONS NIL :ACCRUED-EXCEPTIONS NIL :FAST-MODE NIL) ","date":"2022-04-22","objectID":"/numbers/:3:2","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"高精度计算 quicklisp 中有一个computable-reals库用于高精度计算 (ql:quickload :computable-reals) (use-package :computable-reals) (sqrt-r 2) ;; =\u003e +1.41421356237309504880... (sin-r (/r +pi-r+ 2)) ;; =\u003e +1.00000000000000000000... ","date":"2022-04-22","objectID":"/numbers/:3:3","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"复数 see https://lispcookbook.github.io/cl-cookbook/numbers.html#complex-types ","date":"2022-04-22","objectID":"/numbers/:4:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"Rounding floating-point and rational numbers ceiling,floor,round 和 truncate 可以将float数转换成integer. see https://lispcookbook.github.io/cl-cookbook/numbers.html#reading-numbers-from-strings ","date":"2022-04-22","objectID":"/numbers/:5:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"比较数字 这个真的没啥要将的，除了lisp使用前缀表达式。 直接看common lisp cookbook吧 see https://lispcookbook.github.io/cl-cookbook/numbers.html#comparing-numbers ","date":"2022-04-22","objectID":"/numbers/:6:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"随机数 random 函数用来生成随机数 (random 10) ;; =\u003e 7 (type-of (random 10)) ;; =\u003e (INTEGER 0 4611686018427387903) (type-of (random 10.0)) ;; =\u003e SINGLE-FLOAT (type-of (random 10d0)) ;; =\u003e DOUBLE-FLOAT 随机种子被存放在*random-state*中 使用make-random-state可以生成新的随机状态 如果想时候相同的随机集合多次，可以使用(make-random-state nil) (dotimes (i 3) (let ((*random-state* (make-random-state nil))) (format t \"~a~%\" (loop for i from 0 below 10 collecting (random 10))))) (8 3 9 2 1 8 0 0 4 1) (8 3 9 2 1 8 0 0 4 1) (8 3 9 2 1 8 0 0 4 1) ","date":"2022-04-22","objectID":"/numbers/:7:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"按位操作 这个地方common lisp cookbook 写的很好 see https://lispcookbook.github.io/cl-cookbook/numbers.html#bit-wise-operation ","date":"2022-04-22","objectID":"/numbers/:8:0","tags":["common-lisp"],"title":"common lisp numbers","uri":"/numbers/"},{"categories":["lisp"],"content":"有关common-lisp string的知识以及操作","date":"2022-04-22","objectID":"/strings/","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"你应该知道，string 在 common lisp 中它既是arrays 也是 sequences. 也就是说，arrays 和 sequences的操作都可以应用在string上。如果你找不到某个string特有的函数，你应该去找一找arrays 和 sequences的函数。 还有一些额外的libraries 托管在 quicklisp上，这里只给出英文介绍 ASDF3, which is included with almost all Common Lisp implementations, includes Utilities for Implementation- and OS- Portability (UIOP), which defines functions to work on strings (strcat, string-prefix-p, string-enclosed-p, first-char, last-char, split-string, stripln). Some external libraries available on Quicklisp bring some more functionality or some shorter ways to do. str defines trim, words, unwords, lines, unlines, concat, split, shorten, repeat, replace-all, starts-with?, ends-with?, blankp, emptyp, … Serapeum is a large set of utilities with many string manipulation functions. cl-change-case has functions to convert strings between camelCase, param-case, snake_case and more. They are also included into str. mk-string-metrics has functions to calculate various string metrics efficiently (Damerau-Levenshtein, Hamming, Jaro, Jaro-Winkler, Levenshtein, etc), and cl-ppcre can come in handy, for example ppcre:replace-regexp-all. See the regexp section. Last but not least, when you’ll need to tackle the format construct, don’t miss the following resources: the official CLHS documentation a quick reference a CLHS summary on HexstreamSoft plus a Slime tip: type C-c C-d ~ plus a letter of a format directive to open up its documentation. Again more useful with ivy-mode or helm-mode. ","date":"2022-04-22","objectID":"/strings/:0:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"创建 字符串 最简单的，我们可以使用双引号创建string.但是其实我们还有别的方法: 使用format nil (defparameter person \"you\") (format nil \"hello ~a\" person) ;; =\u003e \"hello you\" make-string count 创建指定长度的字符串。 :initial-element 字符会被重复count次 (make-string 3 :initial-element #\\♥) ;; =\u003e \"♥♥♥\" ","date":"2022-04-22","objectID":"/strings/:1:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"访问子串 string 是一个sequence,你可以使用subseq 来访问它的子串 先给出一个比较易懂的签名 (subseq my-string start end) 这里是调用 * (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* * (subseq *my-string* 8) \"Marx\" * (subseq *my-string* 0 7) \"Groucho\" * (subseq *my-string* 1 5) \"rouc\" 也可以像序列那样用setf 和 subseq 配合来操作字符串 * (defparameter *my-string* (string \"Harpo Marx\")) *MY-STRING* * (subseq *my-string* 0 5) \"Harpo\" * (setf (subseq *my-string* 0 5) \"Chico\") \"Chico\" * *my-string* \"Chico Marx\" string isn`t stretchable 字符串的长度是不可变的，如果新的子串的长度和原始子串的长度不同，短的那一个将决定多少个字符将被替换， * (defparameter *my-string* (string \"Karl Marx\")) *MY-STRING* * (subseq *my-string* 0 4) \"Karl\" * (setf (subseq *my-string* 0 4) \"Harpo\") \"Harpo\" * *my-string* \"Harp Marx\" * (subseq *my-string* 4) \" Marx\" * (setf (subseq *my-string* 4) \"o Marx\") \"o Marx\" * *my-string* \"Harpo Mar\" ","date":"2022-04-22","objectID":"/strings/:2:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"访问单个字符 char函数专门用来访问字符串中的单个字符，char也可以和setf配合使用 (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (char *my-string* 11) #\\x (char *my-string* 7) #\\Space (char *my-string* 6) #\\o (setf (char *my-string* 6) #\\y) #\\y *my-string* \"Grouchy Marx\" 还有一个schar也可以做到同样的事情，但是在特定情况下，schar会更快一些 因为strings 既是 arrays 也是 sequence. 你也可以用更加通用的aref 和 elt (但是char的效率会更高) (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (aref *my-string* 3) #\\u (elt *my-string* 8) #\\M ","date":"2022-04-22","objectID":"/strings/:3:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"从string中删除和替换 可以使用 sequence的函数来对string中的子串进行删除和替换操作 从string中删除一个字符 (remove #\\o \"Harpo Marx\") \"Harp Marx\" (remove #\\a \"Harpo Marx\") \"Hrpo Mrx\" (remove #\\a \"Harpo Marx\" :start 2) \"Harpo Mrx\" (remove-if #'upper-case-p \"Harpo Marx\") \"arpo arx\" 使用substitute(non destructive) 或者 replace (destructive) 来替换一个字符 (substitute #\\u #\\o \"Groucho Marx\") \"Gruuchu Marx\" (substitute-if #\\_ #'upper-case-p \"Groucho Marx\") \"_roucho _arx\" (defparameter *my-string* (string \"Zeppo Marx\")) *MY-STRING* (replace *my-string* \"Harpo\" :end1 5) \"Harpo Marx\" *my-string* \"Harpo Marx\" ","date":"2022-04-22","objectID":"/strings/:4:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"拼接字符串 (Concatenating string) concatenate 是sequence的通用函数，在对string进行操作时，应该指定返回值的类型 (concatenate 'string \"karl\" \" \" \"Marx\") ;; =\u003e \"Karl Marx\" (concatenate 'list \"Karl\" \" \" \"Marx\") ;; =\u003e (#\\K #\\a #\\r #\\l #\\Space #\\M #\\a #\\r #\\x) 使用UIOP库的话，可以用strcat: (uiop:strcat \"karl\" \" \" marx\") 或者是str library 使用concat: (str:concat \"foo\" \"bar\") ","date":"2022-04-22","objectID":"/strings/:5:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"一次操作一个字符 使用Map函数一次操作一个字符 (defparameter *my-string* (string \"Groucho Marx\")) *MY-STRING* (map 'string #'(lambda (c) (print c)) *my-string*) #\\G #\\r #\\o #\\u #\\c #\\h #\\o #\\Space #\\M #\\a #\\r #\\x \"Groucho Marx\" 或者使用loop 函数 (loop for char across \"Zeppo\" collect char) (#\\Z #\\e #\\p #\\p #\\o) ","date":"2022-04-22","objectID":"/strings/:6:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"根据word 或 character翻转string 使用reverse (或者destructive 版的 nreverse) 来根据character反转字符串 (defparameter *my-string* (string \"DSL\")) *MY-STRING* (reverse *my-string*) \"LSD\" 在CL中 没有直接根据word反转字符串的函数，你可以使用第三方库 比如SPLIT-SEQUENCE 或者你自己实现一套解决方案 我们可以使用str库 (defparameter *singing* \"singing in the rain\") *SINGING* (str:words *SINGING*) ;; =\u003e (\"singing\" \"in\" \"the\" \"rain\") (str:unwords (reverse (str:words *singing*))) ;; =\u003e \"rain the in singing\" ","date":"2022-04-22","objectID":"/strings/:7:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"Breaking strings into graphenes,sentences,lines and words These functions use SBCL’s sb-unicode: they are SBCL specific. sb-unicode:sentences 将string 以段落切割，根据他默认的段落分割规则 sb-unicode:lines 将string 分割成行（长度不会超过:margin 指定的参数 默认80） (sb-unicode:lines \"A first sentence. A second somewhat long one.\" :margin 10) ;; =\u003e (\"A first\" ;; \"sentence.\" ;; \"A second\" ;; \"somewhat\" ;; \"long one.\") sb-unicode:words 和 sb-unicode:graphenes 可以自己去查看 确保运行在sbcl中 #+sbcl (runs on sbcl) #-sbcl (runs on other implementations) ","date":"2022-04-22","objectID":"/strings/:8:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"Controlling Case 控制大小写 Common lisp 提供了大量的函数来控制字符串的大小写 (string-upcase \"cool\") ;; =\u003e \"COOL\" (string-upcase \"Cool\") ;; =\u003e \"COOL\" (string-downcase \"COOL\") ;; =\u003e \"cool\" (string-downcase \"Cool\") ;; =\u003e \"cool\" (string-capitalize \"cool\") ;; =\u003e \"Cool\" (string-capitalize \"cool example\") ;; =\u003e \"Cool Example\" 这些函数可以接受:start 和 :key 所以你可以只对字符串的指定部分进行操作。 这些函数也有destructive的版本都以n开头 (string-capitalize \"cool example\" :start 5) ;; =\u003e \"cool Example\" (string-capitalize \"cool example\" :end 5) ;; =\u003e \"Cool example\" (defparameter *my-string* (string \"BIG\")) ;; =\u003e *MY-STRING* (defparameter *my-downcase-string* (nstring-downcase *my-string*)) ;; =\u003e *MY-DOWNCASE-STRING* *my-downcase-string* ;; =\u003e \"big\" *my-string* ;; =\u003e \"big\" warning 对于 string-upcase,string-downcase 和 string-capitalize,string 是没有被修改的。但是如果在string中没有任何字符需要转换，那么返回值有可能是源string 或者 源string的副本 tips 在CL中 n开头的函数一般是destructive的 ","date":"2022-04-22","objectID":"/strings/:9:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"使用format函数控制 To lower case: (format t \"~(~a~)\" \"HELLO WORLD\") ;; =\u003e hello world Capitalize every word: (format t \"~:(~a~)\" \"HELLO WORLD\") ;; =\u003e Hello World Capitalize the first word: (format t \"~@(~a~)\" \"hello world\") ;; =\u003e Hello world To upper case (format t \"~@:(~a~)\" \"hello world\") ;; =\u003e HELLO WORLD ","date":"2022-04-22","objectID":"/strings/:9:1","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"将字符串左右的空格截掉 其实不单单可以截掉空格，还可以丢弃一些不需要的字符。string-trim,string-left-trim,string-right-trim 返回一个子串，子串不包含第一个参数中的字符。 (string-trim \" \" \" trim me \") ;; =\u003e \"trim me\" (string-trim \" et\" \" trim me \") ;; =\u003e \"rim m\" (string-left-trim \" et\" \" trim me \") ;; =\u003e \"rim me \" (string-right-trim \" et\" \" trim me \") ;; =\u003e \" trim m\" (string-right-trim '(#\\Space #\\e #\\t) \" trim me \") ;; = \u003e\" trim m\" (string-right-trim '(#\\Space #\\e #\\t #\\m) \" trim me \") ","date":"2022-04-22","objectID":"/strings/:10:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在symbol 和 字符串之间转换 intern 将string转化成symbol (in-package \"COMMON-LISP-USER\") ;; =\u003e #\u003cThe COMMON-LISP-USER package, 35/44 internal, 0/9 external\u003e (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL ;; =\u003e:INTERNAL (export 'MY-SYMBOL) ;; =\u003e T (intern \"MY-SYMBOL\") ;; =\u003e MY-SYMBOL ;; =\u003e :EXTERNAL (intern \"My-Symbol\") ;; =\u003e |My-Symbol| ;; =\u003e NIL (intern \"MY-SYMBOL\" \"KEYWORD\") ;; =\u003e :MY-SYMBOL ;; =\u003e NIL (intern \"MY-SYMBOL\" \"KEYWORD\") ;; =\u003e :MY-SYMBOL ;; =\u003e :EXTERNAL symbol-name 和 string 将symbol 转换成 string (symbol-name 'MY-SYMBOL) ;; =\u003e \"MY-SYMBOL\" (symbol-name 'my-symbol) ;; =\u003e \"MY-SYMBOL\" (symbol-name '|my-symbol|) ;; =\u003e \"my-symbol\" (string 'howdy) ;; =\u003e \"HOWDY\" ","date":"2022-04-22","objectID":"/strings/:11:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在string 和 character之间转换 coerce 将string(长度为1)转换成character. (coerce \"a\" 'character) ;; =\u003e #\\a (coerce (subseq \"cool\" 2 3) 'character) ;; =\u003e #\\o coerce 将字符串转换中字符list (coerce \"cool\" 'list) ;; =\u003e (#\\c #\\o #\\o #\\l) coerce 将字符list转换成string (coerce '(#\\h #\\e #\\y) 'string) ;; =\u003e \"hey\" coerce 将array 转换成string (defparameter *my-array* (make-array 5 :initial-element #\\x)) ;; =\u003e *MY-ARRAY* *my-array* ;; =\u003e #(#\\x #\\x #\\x #\\x #\\x) (coerce *my-array* 'string) ;; =\u003e \"xxxxx\" ","date":"2022-04-22","objectID":"/strings/:12:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在string中寻找一个元素 使用find,position 和他们的-if后缀的函数 查找string中的character (find #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e #\\t (find #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e #\\T (find #\\z \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e NIL (find-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;;=\u003e #\\1 (find-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :from-end t) ;; =\u003e #\\0 (position #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e 17 (position #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e 0 (position-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;; =\u003e 37 (position-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :from-end t) ;; =\u003e 43 使用count族函数计算字符在字符串中出现的次数 (count #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equal) ;; =\u003e 2 (count #\\t \"The Hyperspec contains approximately 110,000 hyperlinks.\" :test #'equalp) ;; =\u003e 3 (count-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\") ;; =\u003e 6 (count-if #'digit-char-p \"The Hyperspec contains approximately 110,000 hyperlinks.\" :start 38) ;; =\u003e 5 ","date":"2022-04-22","objectID":"/strings/:13:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"在字符串中查找一个子串 (search \"we\" \"If we can't be free we can at least be cheap\") ;; =\u003e 3 (search \"we\" \"If we can't be free we can at least be cheap\" :from-end t) ;; =\u003e 20 (search \"we\" \"If we can't be free we can at least be cheap\" :start2 4) ;; =\u003e 20 (search \"we\" \"If we can't be free we can at least be cheap\" :end2 5 :from-end t) ;; =\u003e 3 (search \"FREE\" \"If we can't be free we can at least be cheap\") ;; =\u003e NIL (search \"FREE\" \"If we can't be free we can at least be cheap\" :test #'char-equal) ;; =\u003e 15 ","date":"2022-04-22","objectID":"/strings/:14:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"将string 转换成number to integer 会返回两个值，一个是被转换后的值，另一个是转换停止的位置 (parse-integer \"42\") ;; =\u003e 42 ;; =\u003e 2 (parse-integer \"42\" :start 1) ;; =\u003e 2 ;; =\u003e 2 (parse-integer \"42\" :end 1) ;; =\u003e 4 ;; =\u003e 1 (parse-integer \"42\" :radix 8) ;; =\u003e 34 ;; =\u003e2 (parse-integer \" 42 \") ;; =\u003e 42 ;; =\u003e 3 (parse-integer \" 42 is forty-two\" :junk-allowed t) ;; =\u003e 42 ;; =\u003e 3 (parse-integer \" 42 is forty-two\") Error in function PARSE-INTEGER: There's junk in this string: \" 42 is forty-two\". 转换成任意number: read-from-string (read-from-string \"#X23\") ;; =\u003e 35,4 (read-from-string \"4.5\") ;; =\u003e 4.5,3 (read-from-string \"6/8\") ;; =\u003e 3/4,3 (read-from-string \"#C(6/8 1)\") ;; =\u003e #C(3/4 1),9 (read-from-string \"1.2e2\") ;; =\u003e 120.00001,5 (read-from-string \"symbol\") ;; SYMBOL.6 (defparameter *foo* 42) ;; =\u003e *FOO* (read-from-string \"#.(setq *foo* \\\"gotcha\\\")\") ;; =\u003e \"gotcha\",23 *foo* ;; =\u003e \"gotcha\" ","date":"2022-04-22","objectID":"/strings/:15:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"转换成float parse-float 库提供转换成float的函数 (ql:quickload \"parse-float\") (parse-float:parse-float \"1.2e2\") ;; =\u003e 120.00001,5 ","date":"2022-04-22","objectID":"/strings/:16:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"number 转 string (write-to-string 250) ;; =\u003e \"250\" (write-to-string 250.02) ;; =\u003e \"250.02\" (write-to-string 250 :base 5) ;; =\u003e \"2000\" (write-to-string (/ 1 3)) ;; =\u003e \"1/3\" ","date":"2022-04-22","objectID":"/strings/:17:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"字符串比较 equal 和 equalp 都可以比较两个字符串是否相同，但是equal是大小写敏感的，而equalp不是。还有一些string专用的函数。 (string= \"Marx\" \"Marx\") ;; =\u003e T (string= \"Marx\" \"marx\") ;; =\u003e NIL (string-equal \"Marx\" \"marx\") ;; =\u003e T (string\u003c \"Groucho\" \"Zeppo\") ;; =\u003e 0 (string\u003c \"groucho\" \"Zeppo\") ;; =\u003e NIL (string-lessp \"groucho\" \"Zeppo\") ;; =\u003e 0 (mismatch \"Harpo Marx\" \"Zeppo Marx\" :from-end t :test #'char=) ;; =\u003e 3 ","date":"2022-04-22","objectID":"/strings/:18:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"String formatting see https://lispcookbook.github.io/cl-cookbook/strings.html#string-formatting ","date":"2022-04-22","objectID":"/strings/:19:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"捕获哪些东西被打印进了stream 在(with-output-to-string (mystream) …) 中任何打印进stream中的内容都会被捕获 (defun greet (name \u0026key (stream t)) ;; by default, print to standard output. (format stream \"hello ~a\" name)) (let ((output (with-output-to-string (stream) (greet \"you\" :stream stream)))) (format t \"Output is: '~a'. It is indeed a ~a, aka a string.~\u0026\" output (type-of output))) ;; Output is: 'hello you'. It is indeed a (SIMPLE-ARRAY CHARACTER (9)), aka a string. ;; NIL ","date":"2022-04-22","objectID":"/strings/:20:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"删除标点符号 使用(str:remove-punctuation s) 或者 (str:no-case s) (str:remove-punctuation \"HEY! What's up ??\") ;; \"HEY What s up\" (str:no-case \"HEY! What's up ??\") ;; \"hey what s up\" ","date":"2022-04-22","objectID":"/strings/:21:0","tags":["common-lisp"],"title":"common lisp strings","uri":"/strings/"},{"categories":["lisp"],"content":"关于common lisp的一些常用数据结构 list sequences hash-table Alist structures Tree Set 介绍及其基本操作","date":"2022-04-19","objectID":"/data_structures/","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Lists ","date":"2022-04-19","objectID":"/data_structures/:1:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Building lists. Cons cells,list list(列表) 也是一个 sequence(序列). list 由cons组成。 cons 有两个cell 一个叫 “car” 一个 叫 “cdr” 我们可以像这样构建一个简单的list (cons 1 2) ;;=\u003e (1 . 2) ;; 这是一个dotted pair 表示一个cons 它的底层结构可以抽象成这样 [o|o]--- 2 | 1 如果第一个cons的cdr 是另一个cons 并且最后一个cons 的cdr 是nil ,那么我们就得到了一个list (cons 1 (cons 2 nil)) ;; =\u003e (1 2) 底层结构是这样的 [o|o]---[o|/] ^ ^ 1 2 为什么不是dotted pair lisp printer 遇到这种结构的时候会自动将逗号省略。但是list还是由一个个dotted pair组成的。 更简单的 可以用list 函数来构建list (list 1 2) ;; =\u003e (1 2) 或者使用一个引用符号' '(1 2) ;; =\u003e (1 2) ","date":"2022-04-19","objectID":"/data_structures/:1:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Circular lists 循环列表 cons 的两个cell 可以 c存放任何值，所以也可以存放自己，或者列表的最后一个元素的cdr存储列表的第一个元素.这个时候就构成了循环列表。 引文最后一个元素的cdr 存的是列表的开始。 在开始之前，我们要将*print-circle* 设为t告诉printer 不要无限答应循环列表。 (setf *print-circle* t) 首先定义一个能构造循环列表的函数 (defun circular! (items) \"Modifies the last cdr of list ITEMS, returning a circular list\" (setf (cdr (last items)) items)) (circular! (list 1 2 3)) (fifth (circular! (list 1 2 3))) ;; =\u003e 2 对于循环列表list-length将会返回nil reader 也可以构建一个循环列表，使用sharpsign equal-sign notation. 一个object(对象) 可以以#n=作为前缀，n是一个无符号十进制整数。可以用#n#去引用已经定义的对象 '#42=(1 2 3 . #42#) ;; =\u003e #1=(1 2 3 . #1#) ","date":"2022-04-19","objectID":"/data_structures/:1:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"car/cdr or first/rest (and second… to tenth) (car (cons 1 2)) ;; return the car cell of a cons. here return 1 (cdr (cons 1 2)) ;; return the cdr cell of a cons.here return 2 (first '(1 2 3 4 5)) ;; return the car of first. here return 1 (second '(1 2 3 4 5)) ;; return the car of second. here return 2 (third '(1 2 3 4 5)) ;; return the car of third. here return 3 . . . (tenth '(1 2 3 4 5 6 7 8 9 10)) ;; return the car of tenth. here return 10 (rest '(rest)) ;; return (2 3) rest return cdr of the first cons setf 可以用来给列表中的元素赋值 (defparameter ll '(1 2 3 4)) (setf (first ll) 2) ll ;; now ll is (2 2 3 4) ","date":"2022-04-19","objectID":"/data_structures/:1:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"last,butlast,nbutlast(\u0026optional n) (last '(1 2 3)) ;; return last of cons of (1 2 3). here return (3) ;; =\u003e (3) (car (last '(1 2 3))) ;; or (first (last ...)) ;; =\u003e 3 (butlast '(1 2 3));; return the list except the last ;; =\u003e (1 2) ","date":"2022-04-19","objectID":"/data_structures/:1:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"reverse,nreverse 倒序 reverse 和 nreverse 都返回一个新的序列(sequence) nreverse 是毁灭性的(destructive)。前缀 n 代表 non-consing,代表他是直接在原有List上进行修改。 (defparameter mylist '(1 2 3)) ;; =\u003e (1 2 3) (reverse mylist) ;; =\u003e (3 2 1) mylist ;; =\u003e (1 2 3) (nreverse mylist) ;; =\u003e (3 2 1) mylist ;; =\u003e (1) in SBCL but implementation dependent. destructive 如果一个函数会修改他的他的操作元素 我们就说他是destructive的 ","date":"2022-04-19","objectID":"/data_structures/:1:5","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"append append 会将两个list合并成一个list (append (list 1 2) (list 3 4)) ;; =\u003e (1 2 3 4) append 的坑 append 返回的List会共享原有的list的cons 所以在其返回的list进行修改，也会影响原有的list ","date":"2022-04-19","objectID":"/data_structures/:1:6","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"push (item,place) push 是destructive的 他会将新的元素插入list的最前面 (defparameter mylist '(1 2 3)) (push 0 mylist) ;;=\u003e (0 1 2 3) mylist ;;=\u003e (0 1 2 3) (defparameter x ’(a (b c) d)) ;; =\u003e (A (B C) D) (push 5 (cadr x)) ;; =\u003e (5 B C) x ;; =\u003e (A (5 B C) D) CL 没有默认的尾插函数，如果想要尾插你可以先将list 进行 reverse 或者使用别的数据结构 ","date":"2022-04-19","objectID":"/data_structures/:1:7","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"pop pop 是 desctructive 和 push 相对 push 会往里面插入 而pop会将最前面的元素返回并删除 ","date":"2022-04-19","objectID":"/data_structures/:1:8","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"nthcdr (index ,list) 返回第n个cons 的 cdr。 (defparameter mylist '(1 2 3)) (nthcdr 1 mylist) ;; =\u003e (2) ","date":"2022-04-19","objectID":"/data_structures/:1:9","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"复合的car 和 cdr 我们可以复合 a 和 d 来做一些方便的操作。比如cadr 就是 返回 the car of cdr caar 就是返回 the car of car 这些操作通常在嵌套list中有些意义 (caar (list 1 2 3));; ==\u003e error (caar (list (list 1 2) 3)) ;; ==\u003e 1 (cadr (list (list 1 2) (list 3 4))) ;; ==\u003e (3 4) (caadr (list (list 1 2) (list 3 4))) ;; == \u003e 3 ","date":"2022-04-19","objectID":"/data_structures/:1:10","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"destructuring-bind (parameter*,list) 这个函数将List中的元素与参数绑定，我们可以析构tree,plists (destructuring-bind (x y z) (list 1 2 3) (list :x x :y y :z z)) ;; =\u003e (:X 1 :Y 2 :Z 3) 内部的sublist也可以绑定 (destructuring-bind (x (y1 y2) z) (list 1 (list 2 20) 3) (list :x x :y1 y1 :y2 y2 :z z)) ;; =\u003e (:X 1 :Y1 2 :Y2 20 :Z 3) parameter list 还可以用\u0026optional,\u0026rest 和 \u0026key (destructuring-bind (x (y1 \u0026optional y2) z) (list 1 (list 2) 3) (list :x x :y1 y1 :y2 y2 :z z)) ;; =\u003e (:X 1 :Y1 2 :Y2 NIL :Z 3) (destructuring-bind (\u0026key x y z) (list :z 1 :y 2 :x 3) (list :x x :y y :z z)) ;; =\u003e (:X 3 :Y 2 :Z 1) \u0026whole parameter 会被绑定到整个list. 他必须再第一个 其余的参数必须在它后面 (destructuring-bind (\u0026whole whole-list \u0026key x y z) (list :z 1 :y 2 :x 3) (list :x x :y y :z z :whole whole-list)) ;; =\u003e (:X 3 :Y 2 :Z 1 :WHOLE (:Z 1 :Y 2 :X 3)) ","date":"2022-04-19","objectID":"/data_structures/:1:11","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"null,listp 断言 null 和 not 相同，但是看起来更好 用来判断一个列表是否为空 listp 判断一个对象是否是一个cons cell ","date":"2022-04-19","objectID":"/data_structures/:1:12","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"ldiff,tailp,list*,make-list,fill,revappend,nreconc,consp,atom 只介绍几个常用的，其余的可以去查文档（太多了，不想写（小声bb） 很多其实不常用，就不写了） make-list 构造一个list (make-list 3 :initial-element \"ta\") ;; =\u003e (\"ta\" \"ta\" \"ta\") fill 用指定对象填充list (make-list 3) ;; =\u003e (NIL NIL NIL) (fill * \"hello\") ;; =\u003e (\"hello\" \"hello\" \"hello\") tailp 用来判断是否有共享的列表结构，也就是是否有相同的cons cell(use EQL for predicate),而不仅仅是cons cell的内容 (tailp t '(1 2 3 4 . t)) ;; =\u003e T (tailp nil '(1 2 3 4 . nil)) ;; =\u003e T (tailp nil '(1 2 3 4)) ;; =\u003e T (tailp #1=\"e\" '(1 2 3 4 . #1#)) ;; =\u003e T (defparameter *tail* (list 3 4 5)) (defparameter *larger* (list* 1 2 *tail*)) (defparameter *replica* (copy-list *larger*)) (tailp *tail* *replica*) ;; ==\u003e nil (tailp *tail* *larger*) ;; ==\u003e t ","date":"2022-04-19","objectID":"/data_structures/:1:13","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"member (elt,list) 返回以elt开始的剩下的元素 默认使用eql作为比较函数 接受:test :test-not :key(functions or symbols) (member 2 '(1 2 3)) ","date":"2022-04-19","objectID":"/data_structures/:1:14","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"替换tree中的对象:subst,sublis subst 和 subst-if 在tree中查找所有和element相同的元素 并 用另一个element 替换 (可以用:test 指定判断相同的函数) (subst 'one 1 '(1 2 3)) ;; =\u003e (one 2 3) (subst '(1 . one) '(1 . 1) '((1 . 1) (2 . 2) (3 . 3)) :test #'equal) ;; ((1 . ONE) (2 . 2) (3 . 3)) sublis 第一个参数是一个list(每个元素都是一个 dot list),每个dot list 有2个元素(x . y) 表示将 x 替换 为 y sublis 接受:test 和 :key 参数 :test 是一个接受key 和 subtree为参数的函数 (sublis '((t . \"foo\")) (\"one\" 2 (\"three\" (4 5))) :key #'stringp) ;; (\"foo\" 2 (\"foo\" (4 5))) ","date":"2022-04-19","objectID":"/data_structures/:1:15","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Sequences 序列 lists vectors strings 都是序列 大多数和序列有关的函数都接受keyword 参数。所有keyword 参数都是可选的，并且可以以任意顺序出现 :test参数默认使用eql (对于strings 来说 用:equal) :key 参数可以接受nil 和 单参数的函数（这个函数声明了我们具体要怎么看待序列中的每个元素） (defparameter my-alist (list (cons 'foo \"foo\") (cons 'bar \"bar\"))) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) (find 'bar my-alist) ;; =\u003e NIL (find 'bar my-alist :key 'car) ","date":"2022-04-19","objectID":"/data_structures/:2:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"断言: every , some…. every 的作用是判断列表中的元素是否都满足某个条件 (都满足就返回真) (defparameter foo '(1 2 3)) (every #'evenp foo) ;; =\u003e NIL some 则只需要一些元素满足条件即可 (一些满足就返回真) (defparameter foo '(1 2 3)) (every #'evenp foo) ;; =\u003e NIL notany 只要不是所有都满足就返回真 ","date":"2022-04-19","objectID":"/data_structures/:2:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"常用函数 alexandria库 《common lisp cookbook》中一直提到有一个\"alexandria\"的库里面有很多非常实用的函数，是对common lisp 的一种扩充，可以去看一看 length(sequence) 返回序列的长度 elt(sequence,index) find by index count (foo sequence) 返回 sequence中 出现foo的次数 可接受:from-end,:start,:end 相关的还有count-if,count-not(test-function sequence) subseq (sequence start,[end]) 返回子序列左闭右开[start,end): (subseq (list 1 2 3) 0) ;; (1 2 3) (subseq (list 1 2 3) 1 2) ;; (2) end不能大于( + (length sequence) 1) 因为这样会越界: (defparameter my-list '(1 2 3 4)) (subseq my-list 0 (+ length(my-list) 1)) ;; =\u003e Error: the bounding indices 0 and 5 are bad for a sequence of length 3. 如果果可能越界，用alexandria-2:subseq*: (alexandria-2:subseq* (list 1 2 3) 0 99) subseq 是\"setf\" able 的 但是只有当新的序列的长度和要被替换的序列长度一致的时候才会生效 (defparameter my-list '(1 2 3 4)) ;; =\u003e(1 2 3 4) (setf (subseq my-list 0 2) '(2 3)) my-list ;; =\u003e (2 2 3 4) sort,stable-sort(sequence,test[,key function]) 这两个函数时destructive的，所以在排序前，可能会优先使用copy-seq 拷贝一份出来 (sort (copy-seq seq) :test #'string\u003c) 就像名字中说的一样 sort是不稳定的而stable-sort是稳定的 find,position(foo,sequence) - get index also find-if,find-if-not,position-if,position-if-not(test sequence) (find 20 '(10 20 30)) ;; 20 (position 20 '(10 20 30)) ;; 1 search and mismatch (sequence-a, sequence-b) search 会在sequence-b 中寻找和sequence-a 一样的subsequence。他会返回sequence-a 在 sequence-b 中的位置，如果没找到就是nil. 参数有 from-end,end1,end2 以及上面提到的test 和 key (search '(20 30) '(10 20 30 40)) ;; 1 (search '(\"b\" \"c\") '(\"a\" \"b\" \"c\")) ;; nil (search '(\"b\" \"c\") '(\"a\" \"b\" \"c\") :test #'equal) ;;1 (search \"bc\" \"abc\") ;;1 mismatch 返回两个序列开始不一样的地方 (mismatch '(10 20 99) '(10 20 30)) ;; 2 (mismatch \"hellolisper\" \"helloworld\") ;; 5 (mismatch \"same\" \"same\") ;; NIL (mismatch \"foo\" \"bar\") ;; 0 substitute,nsubstitute[if,if-not] 返回一个同类型的序列，这个序列将会用新的元素替代就的元素 (substitute #\\o #\\x \"hellx\") ;; =\u003e \"hello\" (substitute :a :x '(:a :x :x)) ;; =\u003e (:A :A :A) (substitute \"a\" \"x\" '(\"a\" \"x\" \"x\") :test #'string=) ;; =\u003e (\"a\" \"a\" \"a\") replace (sequence-a,sequence-b,\u0026key start1,end1) 破坏性的用sequence-b 中的元素替换sequence-a中的元素 完整的函数签名: (replace sequence1 sequence2 \u0026rest args \u0026key (start1 0) (end1 nil) (start2 0)(end2 nil)) (replace \"xxx\" \"foo\") \"foo\" (replace \"xxx\" \"foo\" :start1 1) \"xfo\" (replace \"xxx\" \"foo\" :start1 1 :start2 1) \"xoo\" (replace \"xxx\" \"foo\" :start1 1 :start2 1 :end2 2) \"xox\" remove,delete(foo sequence) 返回一个不包含foo的新sequence 接受:start/end 和 :count参数 (remove \"foo\" '(\"foo\" \"bar\" \"foo\") :test 'equal) ;; =\u003e (\"bar\") remove-duplicates,delete-duplicates(sequence) 去重操作 delete与remove 不同的地方在于 delete会直接操作原始的sequence 接受 from-end test test-not start end key (remove-duplicates '(:foo :foo :bar)) (:FOO :BAR) (remove-duplicates '(\"foo\" \"foo\" \"bar\")) (\"foo\" \"foo\" \"bar\") (remove-duplicates '(\"foo\" \"foo\" \"bar\") :test #'string-equal) (\"foo\" \"bar\") mapping (map,mapcar,remove-if[-not],…) mapcar 只能用于list 而map 适用于vector list 但是由于map 可以用于多种结构 所以要指定返回值类型实参。(map ’list function vector) mapcar 可以接受多个list 映射操作会在最短的list被操作完是中断 (defparameter foo '(1 2 3)) (map 'list (lambda (it) (* 10 it)) foo) reduce (function,sequence). 首先会将function作用于列表第一个和第二个元素，然后将function作用于这个结果与下一个元素直到处理完所有元素 如果指定了特殊参数:initial-value. 首先就不会将function作用于列表的第一个和第二个元素，而是首先将function作用于:initial-value 和第一个值 (reduce '- '(1 2 3 4)) ;; =\u003e -8 (reduce '- '(1 2 3 4) :initial-value 100) ;; =\u003e 90 Creating lists with variables 由于quote ’ 会保护表达式不被求值，所以我们得用list来新建列表，但是list 函数所有的参数都会先被求值然后再构造成列表. 如果只是想特定的变量被求职，我们可以使用backquote ` 来构造List 先来个正常的quote (defparameter *var* \"bar\") ;; First try: '(\"foo\" *var* \"baz\") ;; no backquote ;; =\u003e (\"foo\" *VAR* \"baz\") ;; nope 再来个backquote `(\"foo\" ,*var* \"baz\") ;; backquote, comma ;; =\u003e (\"foo\" \"bar\" \"baz\") ;; good 在backquote 后面 以comma , 开头的变量会被正常求值 如果变量是一个list的话 (defparameter *var* '(\"bar\" \"baz\")) ;;First try: `(\"foo\" ,*var*) ;; =\u003e (\"foo\" (\"bar\" \"baz\")) ;; nested list `(\"foo\" ,@*var*) ;; =\u003e (\"foo\" \"bar\" \"baz\") ","date":"2022-04-19","objectID":"/data_structures/:2:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"集合操作Set 首先，一个集合不会包含两个同样的元素，并且集合内部是无需的. 大多数函数都有循环利用已经有的变量的函数版本(破坏性的) 区别于正常的 他们以\"n\"开头. 他们都可以接受:key 和 :test 参数 intersection list的交集 (defparameter list-a '(0 1 2 3)) (defparameter list-b '(0 2 4)) (intersection list-a list-b) ;; =\u003e (2 0) set-difference 作差 (set-difference list-a list-b) ;; =\u003e (3 1) (set-difference list-b list-a) ;; =\u003e (4) union 并集 (union list-a list-b) ;; =\u003e (3 1 0 2 4) ;; order can be different in your lisp 补集 set-exclusive-or (set-exclusive-or list-a list-b) ;; =\u003e (4 3 1) adjoin 添加 会返回新的集合，原有集合不会被修改 (adjoin 3 list-a) ;; =\u003e (0 1 2 3) (adjoin 5 list-a) ;; =\u003e (5 0 1 2 3) ;; \u003c-- element added in front. list-a ;; =\u003e (0 1 2 3) ;; \u003c-- original list unmodified. subsetp 是否为子集 (subsetp '(1 2 3) list-a) ;; =\u003e T (subsetp '(1 1 1) list-a) ;; =\u003e T (subsetp '(3 2 1) list-a) ;; =\u003e T (subsetp '(0 3) list-a) ;; =\u003e T ","date":"2022-04-19","objectID":"/data_structures/:2:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Fset-immutable data structure 也可以去quicklisp 看看FSet库 ","date":"2022-04-19","objectID":"/data_structures/:2:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"array 和 vector Arrays 的访问时间复杂度是常数时间的 他们可以是fixed 或者 adjustable的。 一个simple array 既不能被displaced(置换) 也不能被adjust(调整) 更不会有fill-pointer 除非我们用:displaced-to, :adjust-array,:fill-pointer 指定, Vector 不同于 array的地方在于 他的维度只能固定再1维 vector 也是一个序列(sequence) ","date":"2022-04-19","objectID":"/data_structures/:3:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"创建和调整array make-array(sizes-list :adjustable :initial-element ) common lisp 至少可以指定7个维度，买个维度可以至少容纳1023个元素，如果提供了:initial-element 那么这个值会作为初始值 (make-array '(2 3) :initial-element nil) adjust-array(array,sizes-list :element-type : initial-element) adjust-array 用于调整函数的维度 ","date":"2022-04-19","objectID":"/data_structures/:3:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"访问 : aref (array i [j…]) aref (array i j k …) 取指定索引上的元素 row-major-aref(array i) 和 (aref i i i ….) 相同 用来去主轴上的元素 返回的结果都可以被setf 赋值 (defparameter myarray (make-array '(2 2 2) :initial-element 1)) myarray ;; =\u003e #3A(((1 1) (1 1)) ((1 1) (1 1))) (aref myarray 0 0 0) ;; =\u003e 1 (setf (aref myarray 0 0 0) 9) ;; =\u003e 9 (row-major-aref myarray 0) ;; =\u003e 9 ","date":"2022-04-19","objectID":"/data_structures/:3:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"sizes array-total-size(array): 返回array 中一共有多少个元素 array-dimensions(array): 返回array每一维的长度 array-dimension(array i): 返回第i维的长度 array-rank: 返回函数一共有多少维 (defparameter myarray (make-array '(2 2 2))) ;; =\u003e MYARRAY myarray ;; =\u003e #3A(((0 0) (0 0)) ((0 0) (0 0))) (array-rank myarray) ;; =\u003e 3 (array-dimensions myarray) ;; =\u003e (2 2 2) (array-dimension myarray 0) ;; =\u003e 2 (array-total-size myarray) ;; =\u003e 8 ","date":"2022-04-19","objectID":"/data_structures/:3:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Vector 创建vector 可以使用vector 或者读取宏 #(). 他会返回一个simple vector (vector 1 2 3) ;; =\u003e #(1 2 3) #(1 2 3) ;; =\u003e #(1 2 3) vector-push (foo vector): 将fill-pointer 指向的元素替换成foo vector-push-extend (foo vector [extension-num])t: 与vector-push相似，但是如果fill-pointer比较大，他会拓展数组 vector-pop (vector): 返回fill-pointer 指向的元素 并删除 fill-pointer (vector). setfable.: 返回array的fill-pointer and see also the sequence functions. fill-pointer fill-pointer 就是vector-push要push的index位置（或者vector-push-extend）.也叫填充句柄。如果一个元素他的index大于这个fill-pointer 那么他就是active的 如果小于fill-pointer 就是inactive的 ","date":"2022-04-19","objectID":"/data_structures/:3:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Hash Table ","date":"2022-04-19","objectID":"/data_structures/:4:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"创建一个hash table make-hash-table 创建一个hash table。make-hash-table 没有必要参数。:test 参数指定用来判断key是否相同的函数 Note see shorter notations in the Serapeum or Rutils libraries. For example, Serapeum has dict, and Rutils a #h reader macro. ","date":"2022-04-19","objectID":"/data_structures/:4:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"获取hash table 中的元素 gethash 接受两个必要参数 一个要获取的元素的key 一个hash table. 它返回key绑定的value 和 一个bool 值表示是否在hash table中找到这个值. 它还有一个可选参数default 表示找不到时的默认值 (defparameter my-table (make-hash-table)) (gethash 'bar my-table 'default-value) ;; =\u003e default-value,NIL 获取 hashtable中所有的value or key (ql:quickload \"alexandria\") (alexandria:hash-table-keys my-table) ","date":"2022-04-19","objectID":"/data_structures/:4:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"向hash table 添加一个元素 可以使用gethash+setf 向hash table 中添加元素 CL-USER\u003e (defparameter *my-hash* (make-hash-table)) *MY-HASH* CL-USER\u003e (setf (gethash 'one-entry *my-hash*) \"one\") \"one\" CL-USER\u003e (setf (gethash 'another-entry *my-hash*) 2/4) 1/2 CL-USER\u003e (gethash 'one-entry *my-hash*) \"one\" T CL-USER\u003e (gethash 'another-entry *my-hash*) 1/2 T ","date":"2022-04-19","objectID":"/data_structures/:4:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"判断hash table 中某个key是否存在 gethash 的第一个返回值会返回对应key绑定的value 但是有的时候我们可能会刻意让这个value 为 nil。 所以使用第一个返回值是不可靠的。第二个返回值会明确告诉我们这个键值对是否存在，所以判断是否存在可以这样。 (if (nth-value 1 (gethash 'bar my-table)) \"Key exists\" \"Key does not exist\") ","date":"2022-04-19","objectID":"/data_structures/:4:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"从hash table 中删除 remhash (remove-hash的缩写) 专门用来删除一个哈希表条目。当hash table中有这个条目的时候 返回T 否则就返回 NIL (defparameter *my-hash* (make-hash-table)) ;; ==\u003e ,*MY-HASH* (setf (gethash 'first-key *my-hash*) 'one) ;; =\u003e ONE (gethash 'first-key *my-hash*) ;; =\u003e ONE,T (remhash 'first-key *my-hash*) ;; =\u003eT (gethash 'first-key *my-hash*) ;; =\u003e NIL,NIL CL-USER\u003e (gethash 'no-entry *my-hash*) ;; =\u003e NIL,NIL CL-USER\u003e (remhash 'no-entry *my-hash*) ;; =\u003e NIL CL-USER\u003e (gethash 'no-entry *my-hash*) ;; =\u003e NIL,NIL ","date":"2022-04-19","objectID":"/data_structures/:4:5","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"clear a hash table 使用clrhash 清空一个hash table (defparameter my-hash (make-hash-table)) (setf (gethash 'first-key my-hash) 'one) (setf (gethash 'second-key my-hash) 'two) my-hash ;; =\u003e #\u003chash-table :TEST eql :COUNT 2 {10097BF4E3}\u003e (clrhash my-hash) ;; =\u003e #\u003chash-table :TEST eql :COUNT 0 {10097BF4E3}\u003e (gethash 'first-key myhash) ;; =\u003e NIL,NIL (gethash 'second-key myhash) ;; =\u003e NIL,NIL ","date":"2022-04-19","objectID":"/data_structures/:4:6","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"遍历hash table 使用maphash 遍历 (defparameter my-hash (make-hash-table)) (setf (gethash 'first-key *my-hash*) 'one) (setf (gethash 'second-key *my-hash*) 'two) (setf (gethash 'third-key *my-hash*) nil) (setf (gethash nil *my-hash*) 'nil-value) (defun print-hash-entry (key value) (format t \"The value associated with the key ~S is ~S~%\" key value)) (maphash #'print-hash-entry *my-hash*) ;; =\u003e The value associated with the key FIRST-KEY is ONE ;; =\u003e The value associated with the key SECOND-KEY is TWO ;; =\u003e The value associated with the key THIRD-KEY is NIL ;; =\u003e The value associated with the key NIL is NIL-VALUE 使用with-hash-table-iterator with-hash-table-iterator 是一个宏 他会为hash-table 创建迭代器，每次迭代会返回三个返回值 第一个返回值返回是否有这个entry 第二个返回值返回key 第三个返回值返回value 如果遍历到了最后，只会返回一个nil (with-hash-table-iterator (my-iterator my-hash) (loop (multiple-value-bind (entry-p key value) (my-iterator) (if entry-p (print-hash-entry key value) (return))))) ;; =\u003e The value associated with the key FIRST-KEY is ONE ;; =\u003e The value associated with the key SECOND-KEY is TWO ;; =\u003e The value associated with the key THIRD-KEY is NIL ;; =\u003e The value associated with the key NIL is NIL-VALUE ;; =\u003e NIL 遍历keys 或者 values 如果只想遍历keys 或者 values 可以使用Alexandria的maphash-keys 和 maphash-values ","date":"2022-04-19","objectID":"/data_structures/:4:7","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"计算hash table 中的entry 数量 可以使用hash-table-count (defparameter *my-hash* (make-hash-table)) (hash-table-count *my-hash*) ;; =\u003e 0 (setf (gethash 'first *my-hash*) 1) (setf (gethash 'second *my-hash*) 2) (setf (gethash 'third *my-hash*) 3) (hash-table-count *my-hash*) (setf (gethash 'second *my-hash*) 'two) (hash-table-count *my-hash*) ;; =\u003e 3 (clrhash *my-hash*) (hash-table-count *my-hash*) ","date":"2022-04-19","objectID":"/data_structures/:4:8","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"线程安全的hash table common lisp 的标准中，hash-table不是线程安全的，但是在SBCL中，我们可以给make-hash-table传一个 :synchronized 参数来构造一个线程安全的hash table (defparameter *my-hash* (make-hash-table :synchronized t)) 但是在修改时，需要使用sb-ext:with-locked-hash-table将操作保护起来 (sb-ext:with-locked-hash-table (my-hash) (setf (gethash :a my-hash) :new-value)) cl-gserver library cl-gserver 实现了一套actors/agent system 可以简化多线程变成的困难 ","date":"2022-04-19","objectID":"/data_structures/:4:9","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Alist (associated list) 一个association list 就是一个存放cons cells 的list (defparameter *my-alist* (list (cons 'foo \"foo\") (cons 'bar \"bar\"))) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) 内部构造就像这样 [o|o]---[o|/] | | | [o|o]---\"bar\" | | | BAR | [o|o]---\"foo\" | FOO ","date":"2022-04-19","objectID":"/data_structures/:5:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"构造 Construct 第一种方法 (setf *my-alist* '((:foo . \"foo\") (:bar . \"bar\"))) 第二种方法是使用pairlis (pairlis '(:foo :bar) '(\"foo\" \"bar\")) ;; =\u003e ((:BAR . \"bar\") (:FOO . \"foo\")) Alist 就是一个list 所以一个key可以绑定多个值 (setf *alist-with-duplicate-keys* '((:a . 1) (:a . 2) (:b . 3) (:a . 4) (:c . 5))) ","date":"2022-04-19","objectID":"/data_structures/:5:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"访问 Access 要获取一个key 我们使用assoc (可以指定 :test 如果key的类型为strings默认用 equal) 它会返回整个cons cell, 所以可以配合cdr 或者second 获取对应的值。Alexandria 还提供了assoc-value list key 这个函数更加的方便 (alexandria:assoc-value my-alist :foo) ;; =\u003e :foo , (:foo . \"foo\") assoc-if(predicate alist) 找到第一个满足predicate的cons cell (setf alist '((1 . :a) (2 . :b) (3 . :c))) (assoc-if #'evenp alist) rassoc 按值查找 (setf alist '((1 . :a) (2 . :b) (4 . :d) )) (rassoc :a alist) ;; =\u003e (1 . :a) 去重 使用remove-if-not 这个函数的作用是返回一个只包含不满足predicate的列表 (remove-if-not #'(lambda (entry) (eq :a entry)) alist-with-duplicate-keys :key #'car) ","date":"2022-04-19","objectID":"/data_structures/:5:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"插入和删除 push 插入一个entry (push (cons 'team \"team\") my-alist) ;; =\u003e ((TEAM . \"team\") (FOO . \"foo\") (BAR . \"bar\")) 删除remove pop 等 remove 需要指定key 关键字 告诉remove 怎么读取entry (remove 'team my-alist) ;; =\u003e ((TEAM . \"team\") (FOO . \"foo\") (BAR . \"bar\")) ;; didn't remove anything (remove 'team my-alist :key 'car) ;; =\u003e ((FOO . \"foo\") (BAR . \"bar\")) ;; returns a copy ","date":"2022-04-19","objectID":"/data_structures/:5:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"更新entries replace a value *my-alist* ;; =\u003e '((:FOO . \"foo\") (:BAR . \"bar\")) (assoc :foo *my-alist*) ;; =\u003e (:FOO . \"foo\") (setf (cdr (assoc :foo *my-alist*)) \"new-value\") ;; =\u003e \"new-value\" *my-alist* ;; =\u003e '((:foo . \"new-value\") (:BAR . \"bar\")) replace a key *my-alist* ;; =\u003e '((:FOO . \"foo\") (:BAR . \"bar\"))) (setf (car (assoc :bar *my-alist*)) :new-key) ;; =\u003e :NEW-KEY *my-alist* ;; =\u003e '((:FOO . \"foo\") (:NEW-KEY . \"bar\"))) ","date":"2022-04-19","objectID":"/data_structures/:5:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Plist (property list) plist 是一个简单地list 内部又 key ,value 交错组成。他的key是一个symbol (defparameter my-plist (list 'foo \"foo\" 'bar \"bar\")) 底层结构就像这样 [o|o]---[o|o]---[o|o]---[o|/] | | | | FOO \"foo\" BAR \"bar\" 我们可以使用getf (list elt)来获取一个元素（返回value） (defparameter my-plist (list 'foo \"foo\" 'bar \"bar\")) ;; =\u003e (FOO \"foo\" BAR \"bar\") (setf (getf my-plist 'foo) \"foo!!!\") ;; =\u003e \"foo!!!\" remf 用来删除一个元素 (remf my-plist 'foo) ;; =\u003e (BAR \"bar\") ","date":"2022-04-19","objectID":"/data_structures/:6:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Structures 结构体 structures 可以将数据存储在具名的slots中，并且支持单继承。 CLOS (Common Lisp Object System)提供一个更灵活的Classes. 但是structures 可以提供更好的性能 ","date":"2022-04-19","objectID":"/data_structures/:7:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"定义 使用defstruct (defstruct person id name age) 在创建时 slots 默认值为nil 要想自定义默认值 (defstruct person id (name \"john doe\") age) 也可以指定默认类型 (defstruct person id (name \"john doe\" :type string) age) ","date":"2022-04-19","objectID":"/data_structures/:7:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"创建 使用make-\u003cstructure-name\u003e, 对于上面的person 使用make-person (defparameter me (make-person)) ;; =\u003e ME me ;;=\u003e #S(PERSON :ID NIL :NAME \"john doe\" :AGE NIL) 也可以使用关键字指定参数值 (defparameter me (make-person :name 123)) 还可以自定义构造函数，但是一旦自定义了构造函数，那么默认构造函数就将不发再被使用 (defstruct (person (:constructor create-person (id name age))) id name age) ","date":"2022-04-19","objectID":"/data_structures/:7:2","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"访问slot的值 structure被定义后，会自动定义 \u003cname-of-the-struct\u003e-+slot-name这样的函数 (person-name me) ","date":"2022-04-19","objectID":"/data_structures/:7:3","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"设置slot的值 使用setf来设置值 (setf (person-name me) \"Cookbook author\") ","date":"2022-04-19","objectID":"/data_structures/:7:4","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"判断类型 就像默认构造，默认也会生成断言函数来判断类型 (person-p me) ","date":"2022-04-19","objectID":"/data_structures/:7:5","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"限制 在定义改变后，实例并不会更新 (defstruct person id (name \"john doe\" :type string) email) attempt to redefine the STRUCTURE-OBJECT class PERSON incompatibly with the current definition [Condition of type SIMPLE-ERROR] Restarts: 0: [CONTINUE] Use the new definition of PERSON, invalidating already-loaded code and instances. 1: [RECKLESSLY-CONTINUE] Use the new definition of PERSON as if it were compatible, allowing old accessors to use new instances and allowing new accessors to use old instances. 2: [CLOBBER-IT] (deprecated synonym for RECKLESSLY-CONTINUE) 3: [RETRY] Retry SLIME REPL evaluation request. 4: [*ABORT] Return to SLIME's top level. 5: [ABORT] abort thread (#\u003cTHREAD \"repl-thread\" RUNNING {1002A0FFA3}\u003e) CLOS CLOS是没有这种限制的 后面会介绍到 ","date":"2022-04-19","objectID":"/data_structures/:7:6","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Tree tree-equal,copy-tree. 会自顶向下递归进入cons cell 的car 和 cdr ","date":"2022-04-19","objectID":"/data_structures/:8:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"Sycamore purely functional weight-balanced binary trees https://github.com/ndantam/sycamore Features: Fast, purely functional weight-balanced binary trees. Leaf nodes are simple-vectors, greatly reducing tree height. Interfaces for tree Sets and Maps (dictionaries). Ropes Purely functional pairing heaps Purely functional amortized queue. ","date":"2022-04-19","objectID":"/data_structures/:8:1","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"控制打印多少数据 \\*print-length\\*, \\*print-level\\*) print-length 和 print-level默认都为nil 默认，如果你有一个非常长的list, 那么在REPL中打印就会非常的长。使用print-length 控制打印元素的最大数量 (setf *print-length* 2) (list :A :B :C :D :E) ;; (:A :B ...) print-level用来控制打印的深度 (let ((*print-level* 2)) (print '(:a (:b (:c (:d :e)))))) ;; (:A (:B #)) \u003c= *print-level* in action ;; (:A (:B (:C (:D :E)))) \u003c= the list is returned, the let binding is not in effect anymore. ","date":"2022-04-19","objectID":"/data_structures/:9:0","tags":["common-lisp"],"title":"common lisp 数据结构","uri":"/data_structures/"},{"categories":["lisp"],"content":"定义一个函数 可以使用defunc 关键字定义一个有名字的函数: (defun \u003cname\u003e (list of arguments) \"docstring\" (function body)) 用学语言必学的打印hello world! 来举例 (defun hello-world () ;; define a function named hello-world (format t \"hello world!\")) ;; print hello world! and return nil 调用 (hello-world) ;; \"hello world!\" \u003c-- output printed by `foramt' function ;; nil \u003c-- return value return by format why docstring common lisp 可以再函数体开始之前 改写 docstring 为函数添加文档 lisp习惯使用这种方式来给函数写一些帮助文档，类似readme这种自述文件 docstring 是对函数的描述 about the return value common lisp 的函数默认会return 最后一个表达式的值 再这里就是 (format t \"hello world!\") 的返回值也就是nil ","date":"2022-04-17","objectID":"/function/:1:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"函数返回值 ","date":"2022-04-17","objectID":"/function/:2:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"required arguments 函数的必要参数 先看这个函数定义 (defun hello (name) ;;name 就是必要参数 \"say hello to `name'.\" (format t \"hello ~a !~\u0026\" name) ;; 这里直接使用name参数 ) 直接调用 (hello \"me\") ;; hello me! \u003c-- printed by `format' ;; Nil \u003c-- return value format 的格式控制符 common lisp format 类似c语言的printf。但是common lisp的格式控制符是以 ~ 为开头的 而且字符的意义也不同 比如C语言中 \\n 代表换行 而format中 ~\u0026就代表换行符。 ","date":"2022-04-17","objectID":"/function/:2:1","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"Optional arguments 函数的可选参数: \u0026optional 可选参数是定义再 \u0026optional 关键字后面。并且要保持有序，必须一个跟着一个出现。这里有点懵逼吧。废话不多说，直接上例子。 (defun hello (name \u0026optional age gender) (format t \"name: ~a age ~a gender ~a ~\u0026\" name age gender) ) 这条函数定义中 name 是必要函数，age 和 gender是可选参数。name是必填的，就是你在调用这个函数的时候，name是必须的。而 age 和 gender 你可以选择提供或者省略。但是当你想提供 gender 这个参数的时候，你必须也要提供 age 这个参数。不严谨的说，一个可选参数要想出现，就必须建立在他前面的一个可变参数已经提供的情况下。 (hello \"me\") ;; supply required argument name. avoid optional arguments age and gender (hello \"me\" 7) ;; supply required argument name, optional argument age and void gender (hello \"me\" 7 \"female\") ;; supply name age and gender (hello \"me\" \"female\") ;; wrong for practice。 You may use hello in this way grammaly but female won`t supplied to the gender arguments 如果可选参数再调用的时候没有绑定值 那值就为 nil (hello \"me\") ;; name: me age NIL gender NIL ","date":"2022-04-17","objectID":"/function/:2:2","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"Named paramenters 具名参数: \u0026key 有时候记住参数的顺序非常不方便，lisp 提供了使用参数名来提供参数的方式. 在\u0026key 后面跟上参数名即可定义具名参数 (defun hello (name \u0026key happy) \"if `happy' is `t,print a smiley\" (format t \"hello ~a\" name) (when happy (format t \":) ~\u0026\"))) 调用的时候用 :name value 这样的形式指定参数,定义了具名参数但是调用的时候不指定value 那具名参数的value 会为nil (hello \"me\") ;; ignore the happy paramenter,happy will be set to nil defaultly (hello \"me\" :happy t) ;; bind happy to t (hello \"me\" :happy nil) ;; bind happy to nil (hello \"me\" :happy) ;; wrong! this form is definitely wrong lisp中的 t and nil lisp 中用 t 代表true nil 代表false 和 空 有关函数参数数量的想法 具名参数是为了解决记住参数的顺序不方便而诞生的，但是如果函数的参数过多的话，会导致函数的行为会变得复杂多样。clean code 中并不鼓励函数参数的数量超过3个 你也可以定义多个具名参数 (defun hello (name \u0026key happy lisper cookbook-contributor-p) ...) 使用示例 (hello \"me\" :lisper t) (hello \"me\" :lisper t :happy t) (hello \"me\" :cookbook-contributor-p t :happy t) keys can be variable 类似 :happy 这样的符号其实可以作为一个变量的值就像这样。 (let ((key :happy) ;; bind :happy to key (val t)) ;; bind t to val (hello \"me\" key val)) ;; quote key and val let 可以声明一些只能在let代码快中使用的变量这个后面会细说 ","date":"2022-04-17","objectID":"/function/:2:3","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"混合可选和具名参数 先看一个例子 (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) 如果你直接这么定义函数，lisp的解释器会报warning ; in: DEFUN HELLO ; (SB-INT:NAMED-LAMBDA HELLO ; (\u0026OPTIONAL NAME \u0026KEY HAPPY) ; (BLOCK HELLO (FORMAT T \"hello ~a \" NAME) (WHEN HAPPY (FORMAT T \":)~\u0026\")))) ; ; caught STYLE-WARNING: ; \u0026OPTIONAL and \u0026KEY found in the same lambda list: (\u0026OPTIONAL (NAME \"John\") \u0026KEY ; HAPPY) ; ; compilation unit finished ; caught 1 STYLE-WARNING condition 虽然也能调用 (hello \"me\" :happy t) ;; hello me :) ;;nil 这种情况不能直接跳过optional的参数 直接指定key 参数 还是上面这个函数 (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) 如果你尝试省略name 直接指定 :happy 就会报错 (hello :happy t) ;; odd number of \u0026KEY arguments 因为optional 的参数必须是有序出现的，如果前面的参数未出现，就不能直接指定后面的参数。但是当指定完所有的optional参数后，你就可以按照key参数的规则去指定key参数 看这个函数定义(一个不恰当的例子) (defun hello (\u0026optional name \u0026key happy age) (format t \"hello ~a \" name) (when happy (format t \":)~\u0026\"))) (hello \"me\" :age 1) 这里直接忽略happy 关键字 指定age ","date":"2022-04-17","objectID":"/function/:2:4","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"key parameters 的默认值 可以使用一对包含键值的括号来指定默认值 (happy t) (defun hello (name \u0026key (happy t))) 这样happy 的默认值就被设成了t ","date":"2022-04-17","objectID":"/function/:2:5","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"如何确定具名参数(key parameter) 是否被指定 前面有提到过，具名参数如果不指定，就会默认为NIL。那问题就是，如何知道具名参数的调用者是否故意指定这个参数为NIL呢。因为参数为NIL可能会有自己特殊的意义，所以需要判断是否是调用者故意设为NIL. 我们使用二元组 tuple 设置默认值 \u0026key (:happy t) 我们可以使用三元组 triple来解决参数知否被故意指定为NIL \u0026key (:happy t happy-p) (defun hello (name \u0026key (happy nil happy-p)) (format t \"Key supplied? ~a~\u0026\" happy-p) (format t \"hello ~a \" name) (when happy-p (if happy (format t \":)\") (format t \":(\")))) (hello \"me\" :happy t) ;; Ky supplied? T ;; hllo me :) 从返回的结果可以看到 如果指定了:happy 那么happy-p 会被自动设置为 t 即被指定状态 lisp 中有关断言命名的convenstion(传统) lisp 中习惯对用来做判断的函数或变量后面加一个p 比如 stringp :用来判断是否为字符串的函数 listp : 用来判断是否为列表类型的函数 p是predicate的缩写 意为断言 ","date":"2022-04-17","objectID":"/function/:2:6","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"可变数量参数: \u0026rest 的时候，你会想要定义一些函数，可以接受很多个参数，但是具体多少个，你也不清楚。比如你想定义个函数把所有的参数都相加进行求和。 (defun sum (arg1 arg2 arg3 ... to arg100....)) 这样太累了，你不可能一个一个的敲。我们可以这样 (defun hello (\u0026rest numbers) (apply #'+ numbers)) 调用 (hello 1 2 3 4) ;; 10 \u003c-- returned by hello apply 函数 apply 的第一个参数接收一个拥有两个参数的回调函数 第二个参数接受一个列表（这里为了方便理解代码这么说，其实这是不严谨的） 就像这样 (apply #'func '(arg1 arg2 arg3)) arg1 arg2 arg3 将会作为func 的参数传递给func 并进行运算. 也就是说 apply的操作是将 list 展开成一个个参数并传给func。 比如(apply #+ ‘(1 2 3 4)) 和 (+ 1 2 3 4) 是等价的。 列表 ‘(1 2 3 4) 被展开成 1 2 3 4 传递给了func ","date":"2022-04-17","objectID":"/function/:2:7","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"允许额外的key: \u0026allow-other-keys 先看下下面的例子 (defun hello (name \u0026key happy) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; Error: unknown keyword argument 再看看这个 (defun hello (name \u0026key happy \u0026allow-other-keys) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; hello me 这里我们并没有给出 :lisper 这个关键字的定义 但是函数仍然允许我们这么调用而不是直接报错 《common lisp cook book》 中给出过一个实用的案例 (defun open-supersede (f \u0026rest other-keys \u0026key \u0026allow-other-keys) (print other-keys) (apply #'open f :if-exists :supersede other-keys)) 这个函数的定义要求必须有一个f参数，以及任意数量的other-keys 其实 \u0026key 以及\u0026allow-other-keys 被忽略了只做提示用（告诉调用者可以接受其他具名参数）。因为有\u0026rest 这个标志符在 除了f外 参数都会传到other-keys里面。所以\u0026key \u0026allow-other-keys就失去了语法上的意义。起码在编译器看来，他是无意义的。 但是如果你不按照函数签名指示的方式调用，内层的函数就很有可能报错，所以即使\u0026key \u0026allow-other-keys被编译器忽略(这种函数在定义时，甚至可以忽略\u0026key \u0026allow-other-keys关键字，功能并不会因为没有他们而受影响)，你也应该按照签名去调用函数。因为内层的函数需要依赖这个签名规则。 来看这个函数调用 (open-supersede \"test.log\" :if-does-not-exist :create) ;;(:IF-DOES-NOT-EXIST :CREATE) \u003c\u003c-- 由(print other-keys)打印 可以看到具名参数都被传给了\u0026rest 必要的函数文档 在写这种函数的时候，应该写上docstring 因为函数签名已经不能很好的描述函数了，我们应该加上docstring来描述函数，不要让调用者疑惑。 ","date":"2022-04-17","objectID":"/function/:2:8","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"函数返回值 common lisp 的返回值默认是函数的最后一个执行语句 你也可以使用(return-from \u003cfunction name\u003e \u003cname\u003e \u003cvalue\u003e) 显示的从具体函数内返回。注意这里是直接从\u003cfunction name\u003e 指定的函数中返回,不仅仅是从当前运行的函数中返回，也有可能直接从外层函数返回。 多数时候我们并不使用return-from ","date":"2022-04-17","objectID":"/function/:3:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"多返回值：values,multiple-value-bind and nth-value 我们使用values来构造一个多返回值 (defun foo (a b c) (values a b c)) 因为函数的最后一条语句的结果会被返回，所以values构造的多返回值会被直接返回给上层 (setf res (foo :a :b :c)) ;; :A \u003c\u003c-- res 为:A 这里res为:A而不是 :A :B :C 是因为这里的返回值接受者只有res 所以只有第一个:A 被接受 :B :C 都被自动忽略掉了. 接受多返回值得方法为multiple-value-bind。 multiple-value-bind 使用multiple-value-bind来解构多返回值。 (multiple-value-bind (res1 res2 res3) (foo :a :b :c) (format t \"res1 is ~a, res2 is ~a, res3 is ~a ~\u0026\" res1 res2 res3)) ;res1 is A, res2 is B res3 is C ;nil 通用格式 (multiple-value-bind (var-1 .. var-n) expr body) multiple-value-bind绑定的变量是局部的 使用multiple-value-bind的变量再它外面是访问不到的, 也就是说上面的例子中 res1 只能再(multipe-value-bind)的内部使用。而无法再外部使用 nth-value nth-value 是可以直接拿到指定索引的返回值 (nth-value 0 (values :a :b :c)) ;; =\u003e :A (nth-value 2 (values :a :b :c)) ;; =\u003e :C (nth-value 9 (values :a :b :c)) ;; =\u003e NIL 但是如果将 nth-value 用在List上，结果就不一样了 (nth-value 0 '(:a :b :c)) ;; =\u003e (:A :B :C) (nth-value 1 '(:a :b :c)) ;; =\u003e NIL Note (values) 将不会返回任何值 multiple-value-list multiple-value-list 将返回值构造成list (multiple-value-list (values 1 2 3)) ;; (1 2 3) 相反的操作有将list 构造成多返回值 (value-list '(1 2 3)) ","date":"2022-04-17","objectID":"/function/:3:1","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"匿名函数 lambda 使用lambda函数创建匿名函数 (lambda (x) (print x)) 我们可以用funcall 或者 apply 来调用匿名函数 如果一个未被引用的括号表达式内部第一个元素是一个匿名函数，那么这个匿名函数就会被调用 ((lambda (x) (print x)) \"hello\") 引用 lisp中 引用是指以’为开头的表达式或符号。‘将保护表达式或符号维持其本身。 比如(func arg) 这种形式的表达式将会自动被当做函数执行,有些情况我们并不想让他执行（比如传一个list 给函数做参数的时候的时候） (defun hello (arg)) (hello (1 2 3)) ;; illegal function call 这里(1 2 3) 将会被求值 并不会真的传一个(1 2 3) 给arg且会报 illegal function call 这样的错误。因为没有被’ 保护的函数会被自动当成函数并且运算。 所以正确的形式应该是 (defun hello (arg)) (hello '(1 2 3)) ‘就是保护表达式或变量维持其本身 ","date":"2022-04-17","objectID":"/function/:4:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"使用funcall 和 apply 调用函数 funcall 和 apply 类似，都是将参数规整成正确的形式然后传给回调函数 (funcall #'func arg1 arg2 .. argn) ;; ^^ 回调 要传给func的参数 不同点在于， funcall 不会自动展开list 列表 而apply 可以将列表展开成一个个参数传给回调func (funcall #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) 会原封不动的传给func (apply #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) 会被展开成 arg3 arg4 最后的形式就是 (apply #'func arg1 arg2 arg3 arg4) ","date":"2022-04-17","objectID":"/function/:4:1","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"使用 single quote ’ 还是 sharpsign-quote #’ 来引用函数? single quote ’ 和 sharpsign-quote #‘的不同在于 #’ 使用的是词法作用域(lexical scope) 会更安全点 (defun foo (x) (* x 100)) (flet ((foo (x) (1+ x))) (funcall #'foo 1)) ;; =\u003e 2, as expected ;; ;; But: (flet ((foo (x) (1+ x))) (funcall 'foo 1)) ;; =\u003e 100 lexical scope 词法作用域的意思是，当找一个变量或函数的时候（函数此时作为值进行传递）会默认去定义的地方去找而不是再函数运行的环境中去找。 上面的foo 一个是在外面声明的 一个是使用flet 保护起来的foo 对于funcall 来说 #’会去找flet 出来的foo 因为词法作用域要求在定义的地方去找需要的函数。 single quote ’ 使用的是动态作用域 会默认去运行环境中找所以 即使第二个flet 也声明了 foo 但是funcall 的时候还是去到外层寻找foo #’ 其实就是(function … )的语法糖 (function +) ;; #\u003cFUNCTION +\u003e (flet ((foo (x) (1+ x))) (print (function foo)) (funcall (function foo) 1)) ;; #\u003cFUNCTION (FLET FOO) {1001C0ACFB}\u003e ;; 2 ","date":"2022-04-17","objectID":"/function/:4:2","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"高级函数 能够返回函数的函数 (functions that return functions) (defun adder (n) (lambda (x) (+ x n))) 这样就定义了一个能够返回一个函数对象的adder函数 要想调用这个函数对象我们需要funcall 或者 apply (adder 5) ;; #\u003cCLOSURE (LAMBDA (X) :IN ADDER) {100994ACDB}\u003e (funcall (adder 5) 3) ;; 8 如果你想以正常的思维去调用这个函数对象，会报错 ((adder 3) 5) ;;In: (ADDER 3) 5 ;;((ADDER 3) 5) ;;Error: Illegal function call. 在common lisp 中 对于变量和方法 他们有不同的命名空间。 比如一个变量和一个函数可以有同一个名字, 这取决于他被运算的环境 ;; The symbol foo is bound to nothing: CL-USER\u003e (boundp 'foo) NIL CL-USER\u003e (fboundp 'foo) NIL ;; We create a variable: CL-USER\u003e (defparameter foo 42) FOO * foo 42 ;; Now foo is \"bound\": CL-USER\u003e (boundp 'foo) T ;; but still not as a function: CL-USER\u003e (fboundp 'foo) NIL ;; So let's define a function: CL-USER\u003e (defun foo (x) (* x x)) FOO ;; Now the symbol foo is bound as a function too: CL-USER\u003e (fboundp 'foo) T ;; Get the function: CL-USER\u003e (function foo) #\u003cFUNCTION FOO\u003e ;; and the shorthand notation: * #'foo #\u003cFUNCTION FOO\u003e ;; We call it: (funcall (function adder) 5) #\u003cCLOSURE (lambda (X) :IN ADDER) {100991761B}\u003e ;; and call the lambda: (funcall (funcall (function adder) 5) 3) 8 可以认为，每个symbol 在CL(common lisp)中多有多个cell(空间)存储不同的信息，比如有的表示一个value-cell 你可以用boundp 来测试是否绑定了一个value. 你可以使用symbol-value访问value-cell. 还有其他cell 比如function-cell 可以保存symbol 的function. 你可以用fboundp来测试，使用symbol-function 来访问这个function. 如果symbol 被运算，那它就被当做是一个variable 并且他的value-cell将被返回。如果是符合形式，即cons,被求值并且他的car是一个symbol，那么使用这个symbol的function-cell. 所以上面的((addr 3) 5)的调用会报错。因为(addr 3) 既不是符号 也不是lambda表达式. ;;; continued from above CL-USER\u003e (fboundp '*my-fun*) NIL CL-USER\u003e (setf (symbol-function '*my-fun*) (adder 3)) #\u003cCLOSURE (lambda (X) :IN ADDER) {10099A5EFB}\u003e CL-USER\u003e (fboundp '*my-fun*) T CL-USER\u003e (*my-fun* 5) 8 ","date":"2022-04-17","objectID":"/function/:5:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"Closures 闭包 Closures 允许捕获词法绑定的值 (let ((limit 3) (counter -1)) (defun my-counter() (if (\u003c counter limit) (incf counter) (setf counter 0)))) (my-counter) 0 (my-counter) 1 (my-counter) 2 (my-counter) 3 (my-counter) 0 lexical 这里可以看见，counter 和 limit 是在let后就已经存在的值。my-counter 会去找被let的limit 和 counter. let就是将let定义的值与下面的函数体(body)做绑定。 还可以这样 (defun repeater (n) (let ((counter -1)) (lambda () (if (\u003c counter n) (incf counter) (setf counter 0))))) (defparameter *my-repeater* (repeater 3)) (defparameter *my-repeater2* (repeater 2)) (funcall *my-repeater*) 0 (funcall *my-repeater*) 1 (funcall *my-repeater*) 2 (funcall *my-repeater2*) 0 (funcall *my-repeater*) 3 (funcall *my-repeater*) 0 这里可以看到my-repeater 和my-repeater之间是相互隔离的 各自拥有自己的counter. 这是因为repeater 被执行了两次而 lambda 表达式被定义了两次，而被let包裹的函数会去其定义的环境中寻找值，所以两者的counter是隔离的。 ","date":"2022-04-17","objectID":"/function/:6:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"TODO setf functions ","date":"2022-04-17","objectID":"/function/:7:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"柯里化 currying 维基百科上的解释是，把接受多个参数的函数转换成接受一个单一参数的函数 (defun curry (function \u0026rest args) (lambda (\u0026rest more-args) (apply function (append args more-args)))) 这个函数再第一次调用的时候会返回lambda函数 (funcall (curry #'+ 3) 5) ;;8 ","date":"2022-04-17","objectID":"/function/:8:0","tags":["common-lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["leetcode"],"content":"leetcode-三数之和的解法","date":"2022-04-04","objectID":"/3sumcloset/","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"description ","date":"2022-04-04","objectID":"/3sumcloset/:1:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"analyze 这道题先排序，防止重复枚举，并且利用有序性，来使双指针的逼近产生可能。双指针的逼近其实和那题最大容量是类似的。 假设每轮枚举到的数分别为a,b,c，第二轮第三轮枚举的指针分别为i,pb,pc,令pb指向i+1,pc指向len(nums)-1 若a+b+c \u003e target 则应该让pc左移，因为排完序后，pb不动的情况下 只有pc左移才会使a+b+c的值减小 才有可能更加靠近target 若a+b+c \u003c target 则应该让pb右移，因为pc不动的情况下，只有pb右移，a+b+c的值才会增大，才有可能更加靠近target ","date":"2022-04-04","objectID":"/3sumcloset/:2:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"implementation package main import ( \"fmt\" \"math\" \"sort\" ) func threeSumClosest(nums []int, target int) int { result := math.MaxInt64 distance := math.MaxFloat64 sort.Ints(nums) for i := 0; i \u003c len(nums); i++ { if i \u003e 0 \u0026\u0026 nums[i] == nums[i-1] { continue } third := len(nums) - 1 for j := i + 1; j \u003c len(nums); j++ { if j \u003e i+1 \u0026\u0026 nums[j] == nums[j-1] { continue } for nums[i]+nums[j]+nums[third] \u003e target \u0026\u0026 third \u003e j { if third \u003c len(nums)-1 \u0026\u0026 nums[third] == nums[third+1] { third-- continue } sum := nums[i] + nums[j] + nums[third] tmpDistance := math.Abs(float64(sum - target)) if tmpDistance \u003c= distance { distance = tmpDistance result = sum } third-- } if third == j { break } if nums[i]+nums[j]+nums[third] \u003c= target { sum := nums[i] + nums[j] + nums[third] tmpDistance := math.Abs(float64(sum - target)) if tmpDistance \u003c= distance { distance = tmpDistance result = sum } } } } return result } ","date":"2022-04-04","objectID":"/3sumcloset/:3:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"summery 这道题，乍一看，我就往dp上面去想了。看看这题，跟那题三数只和很相似，就想着能不能在第二轮和第三轮的时候来一次优化。但是我看了半天也没看出来，优先排序这个思路是有的，想着第二轮第三轮进行优化的思路也是对的。但是具体如何优化我却想不到。想着应该跟那个target有关系，但是我方向错了，根本就不是我想的那样。后来一看题解，恍然大悟，这些数组题，双指针的，尤其要三轮演绎的，一般都是想让你进行二三轮的优化，利用双指针逼近不断找到最优解。至于如何逼近，就是问题的关键点了，只要找到能够让指针逼近的关系，这道题自然就解开了。 ","date":"2022-04-04","objectID":"/3sumcloset/:4:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最优解优于全局最优解，则刷新全局最优解。","date":"2022-04-04","objectID":"/container_with_most_water/","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"1 Description https://leetcode-cn.com/problems/container-with-most-water/ ","date":"2022-04-04","objectID":"/container_with_most_water/:1:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"2.analyze problem 这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最优解优于全局最优解，则刷新全局最优解。 ","date":"2022-04-04","objectID":"/container_with_most_water/:2:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"2.1 slove step 分配两个指针，分别指向数组的头尾 [1,8,6,2,5,4,8,3,7] l r 计算面积并与全局最优解做比较，如果大于全局最优解，刷新全局最优解。并且移动对应数字较小的那个指针(向对应数字较大的方向移动) [1,8,6,2,5,4,8,3,7] l r 重复上述操作直到指针相遇 ","date":"2022-04-04","objectID":"/container_with_most_water/:2:1","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"2.2 certify 需要该解法需要证明的是，为什么每次移动对应值较小的指针是正确的。 双指针代表的是 可以作为容器边界的所有位置的范围 移动指针就代表这个指针不可能再作为容器的边界了。 为什么指向较小值的指针不可能再作为容器的边界了 。 假设当前左指针和右指针指向的数分别为\\(x\\) 和\\(y\\), 不失一般性，我们假设 \\(x \\leq y\\) 两个指针之间的距离为t。那么，他们组成的容器的容量为： \\[\\begin{equation} min(x,y)*t = x*t \\end{equation}\\] 如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 \\(x*t\\) 。为什么呢，这里我们只考虑当指针还指向左右边界的时候。 我们任意向左移动右指针，指向的数为 \\(y_{1}\\) ，两个指针之间的距离为 \\(t_{1}\\) ，\\(t_{1} \u003c t\\) ，并且 \\(min(x,y_{1}) \\le min(x,y)\\) 如果 \\(y_{1} \\le y\\), then \\(min(x,y_{1}) \\le min(x,y)\\) ; 如果 \\(y_{1} \\ge y\\), then \\(min(x,y_{1}) =x= min(x,y)\\) ; 所以有 \\[\\begin{equation} min(x,y_{t})*t_{1} \u003c min(x,y)*t \\end{equation}\\] 这表明指向较小值的指针不可以再作为容器的边界，因为无论如何移动较大的指针，容器的容量都不会再变大。这个边界应该被舍弃。 ","date":"2022-04-04","objectID":"/container_with_most_water/:2:2","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"3 implementation //c++ version #include \u003calgrothim\u003e#include \u003ciostream\u003e#include \u003cmath\u003e using namespace std; class Solution { public: int maxArea(vector\u003cint\u003e \u0026height) { int left = 0; int right = height.size()-1; int compacity = 0; while (left \u003c right) { int min = fmin(height[left], height[right]); int length = right - left; int tmpCompacity = min * length; if (tmpCompacity \u003e= compacity) compacity = tmpCompacity; if (height[left] \u003e= height[right]) right--; else left++; } return compacity; } }; int main(int argc, char *argv[]) { return 0; } //go version import \"math\" func maxArea(height []int) int { front := 0 end := len(height)-1 var maxCompacity float64 = 0 for front \u003c end { longSide := math.Min(float64(height[front]),float64(height[end])) shotSide := float64(end-front) tmpCompacity := longSide*shotSide maxCompacity = math.Max(tmpCompacity,maxCompacity) if height[front] \u003e= height[end] { end-- }else{ front++ } } return int(maxCompacity) } ","date":"2022-04-04","objectID":"/container_with_most_water/:3:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"4 summery 这道题用到了双指针+贪心算法。以后都可以用双指针对撞的思想去求解这类问题，重点在于如何找到应该移动的指针。当因子分布再数组的两边的时候，可以考虑使用双指针的方法求解。这题的贪心并不明显，只在更新最大的容量的时候进行了贪心。贪心的思想是每一步只选择当前认为的最优解。 ","date":"2022-04-04","objectID":"/container_with_most_water/:4:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"Description Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. Example 3: Input: nums1 = [0,0], nums2 = [0,0] Output: 0.00000 Example 4: Input: nums1 = [], nums2 = [1] Output: 1.00000 Example 5: Input: nums1 = [2], nums2 = [] Output: 2.00000 Constraints: nums1.length == m nums2.length == n 0 \u003c= m \u003c= 1000 0 \u003c= n \u003c= 1000 1 \u003c= m + n \u003c= 2000 -106 \u003c= nums1[i], nums2[i] \u003c= 106 ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:1:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode"],"content":"Analyse 这道题最简单的想法就是先归并到一个数组，然后再把中位数找到，但是此时的时间复杂度为\\(o(m+n)\\) 不符合题意。题目要求的是 \\(o(\\log(m+n))\\) 。 此时我们能想到的应该就只有二分法了，对于有序数组，二分法总能非常有效的降低算法的复杂度。但是如何二分成为一个问题。 中位数指的是一个数列中间的数。设 len = len(array) 这里的/为整除 \\begin{equation} \\label{中位数公式} medium = \\begin{cases} \\frac{array[len/2-1] + array[len/2]}{2} \u0026len\\mod 2=0 \\\\ \\frac{array[len/2-1]}{2}\u0026 len\\mod 2\\neq 0 \\end{cases} \\end{equation} 这道题是寻找两个有序数组的中位数，我们可以姑且假设他们已经合并后的数组为 nums3 我们要在nums3中寻找中位数。此时 nums3 的长度我们 是知道的(m+n) 那么其中位数的应该为第 k= \\(\\frac{m+n}{2}\\) 个数（这里我们先只看奇数情况。这时我们可以对k进行二分处理，分别找到两个s数组中第 \\(\\frac{k}{2}\\) 个数进行比较，然后排除较小的以及它所在数组中在它前面的数。因为他们是不可能成为中位数的。 对于 nums1[k/2-1] 和 nums2[k/2-1] 在它们之前的只有 k/2-1 + k/2-1 = k -2 个数。即使算上较小的那个数，也只能到第k-1个数。 所以他们是不可能成为第k个数的。这时我们让 k = k-A(A为已经排除的数的个数) 然后继续对剩下的数组进行同样的操作。 这里会出现两种情况 如果 nums1[k/2-1] \u003e= nums2[k/2-1] 则直接排除nums1[k/2-1] 及其前面的数 如果 nums1[k/2-1] \u003c nums2[k/2-1] 则直接排除nums2[k/2-1] 及其前面的数 在排除过程中我们还会遇到几种情况 k/2-1 越界，这种情况取最后一个元素 k=1 直接返回较小的元素 数组为空，直接去非空数组中寻找即可 ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:2:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode"],"content":"Implement //c++ version #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e int main(int argc, char *argv[]) { Solution s; vector\u003cint\u003e nums1 = new vector\u003cint\u003e(); vector\u003cint\u003e nums2 = new vector\u003cint\u003e(); for(int i = 1;i\u003c10;i++){ nums1.push_back(i); } for(int i= 1;i\u003c10;i=i+2){ nums2.push_back(i); } s.findMedianSortedArrays(nums1,nums2); return 0; } class Solution { public: double findMedianSortedArrays(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { int k = nums1.size() + nums2.size(); if(k%2 == 0){ return min(getKthElement(nums1, nums2, k/2+1),getKthElement(nums1, nums2,k/2))/2.0; }else{ return getKthElement(nums1,nums2,k/2); } } double getKthElement(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2,int k){ int index1 = 0; int index2 = 0; int m = nums1.size(); int n = nums2.size(); while (true){ if (index1 == m){ return nums2[index2+k-1]; } if(index2 == n){ return nums1[index1 +k -1]; } if(k == 1){ return min(nums1[index1],nums2[index2]); } int newIndex1 = min(index1+k/2-1,m-1); int newIndex2 = min(index2+k/2-1,n-1); if(nums1[newIndex1] \u003e= nums2[newIndex2]){ k -= newIndex2 - index2 +1; index2 = newIndex2+1; }else{ k -= newIndex1 - index1 +1; index1 = newIndex1+1; } } } }; //GO version package main import ( \"fmt\" \"math\" ) func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { k := int(math.Ceil((float64(len(nums1)) + float64(len(nums2))) / 2)) if (len(nums1)+len(nums2))%2 == 0 { foo1 := getKthElement(nums1, nums2, k) foo2 := getKthElement(nums1, nums2, k+1) return float64(foo1+foo2) / 2 } else { return float64(getKthElement(nums1, nums2, k)) } } func getKthElement(nums1 []int, nums2 []int, k int) int { if len(nums1) == 0 { return nums2[k-1] } if len(nums2) == 0 { return nums1[k-1] } compareIdx := k / 2 if compareIdx == 0 { return min(nums1[0], nums2[0]) } nums1Idx := min(len(nums1)-1, compareIdx-1) nums2Idx := min(len(nums2)-1, compareIdx-1) if nums1[nums1Idx] \u003e= nums2[nums2Idx] { if len(nums2) \u003c= compareIdx { return getKthElement(nums1, []int{}, k-(nums2Idx+1)) } return getKthElement(nums1, nums2[compareIdx:], k-(nums2Idx+1)) } else { if len(nums1) \u003c= compareIdx { return getKthElement([]int{}, nums2, k-(nums1Idx+1)) } return getKthElement(nums1[compareIdx:], nums2, k-(nums1Idx+1)) } } func min(x, y int) int { if x \u003c y { return x } return y } ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:3:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode"],"content":"summery 这道题对二分的运用比较灵活，主要是二分的对象变了，但是思想还在。正常的二分是对数组的长度进行二分，而此题的二分却是先确定中位数的位置，再利用二分的思想去到两个数组中分别寻找排除，非常巧妙，受益匪浅。 ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:4:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"}]