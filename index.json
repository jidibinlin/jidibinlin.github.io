[{"categories":["lisp"],"content":"定义一个函数 可以使用defunc 关键字定义一个有名字的函数: (defun \u003cname\u003e (list of arguments) \"docstring\" (function body)) 用学语言必学的打印hello world! 来举例 (defun hello-world () ;; define a function named hello-world (format t \"hello world!\")) ;; print hello world! and return nil 调用 (hello-world) ;; \"hello world!\" \u003c-- output printed by `foramt' function ;; nil \u003c-- return value return by format why docstring common lisp 可以再函数体开始之前 改写 docstring 为函数添加文档 lisp习惯使用这种方式来给函数写一些帮助文档，类似readme这种自述文件 docstring 是对函数的描述 about the return value common lisp 的函数默认会return 最后一个表达式的值 再这里就是 (format t \"hello world!\") 的返回值也就是nil ","date":"2022-04-17","objectID":"/function/:1:0","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"函数返回值 ","date":"2022-04-17","objectID":"/function/:2:0","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"required arguments 函数的必要参数 先看这个函数定义 (defun hello (name) ;;name 就是必要参数 \"say hello to `name'.\" (format t \"hello ~a !~\u0026\" name) ;; 这里直接使用name参数 ) 直接调用 (hello \"me\") ;; hello me! \u003c-- printed by `format' ;; Nil \u003c-- return value format 的格式控制符 common lisp format 类似c语言的printf。但是common lisp的格式控制符是以 ~ 为开头的 而且字符的意义也不同 比如C语言中 \\n 代表换行 而format中 ~\u0026就代表换行符。 ","date":"2022-04-17","objectID":"/function/:2:1","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"Optional arguments 函数的可选参数: \u0026optional 可选参数是定义再 \u0026optional 关键字后面。并且要保持有序，必须一个跟着一个出现。这里有点懵逼吧。废话不多说，直接上例子。 (defun hello (name \u0026optional age gender) (format t \"name: ~a age ~a gender ~a ~\u0026\" name age gender) ) 这条函数定义中 name 是必要函数，age 和 gender是可选参数。name是必填的，就是你在调用这个函数的时候，name是必须的。而 age 和 gender 你可以选择提供或者省略。但是当你想提供 gender 这个参数的时候，你必须也要提供 age 这个参数。不严谨的说，一个可选参数要想出现，就必须建立在他前面的一个可变参数已经提供的情况下。 (hello \"me\") ;; supply required argument name. avoid optional arguments age and gender (hello \"me\" 7) ;; supply required argument name, optional argument age and void gender (hello \"me\" 7 \"female\") ;; supply name age and gender (hello \"me\" \"female\") ;; wrong for practice。 You may use hello in this way grammaly but female won`t supplied to the gender arguments 如果可选参数再调用的时候没有绑定值 那值就为 nil (hello \"me\") ;; name: me age NIL gender NIL ","date":"2022-04-17","objectID":"/function/:2:2","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"Named paramenters 具名参数: \u0026key 有时候记住参数的顺序非常不方便，lisp 提供了使用参数名来提供参数的方式. 在\u0026key 后面跟上参数名即可定义具名参数 (defun hello (name \u0026key happy) \"if `happy' is `t,print a smiley\" (format t \"hello ~a\" name) (when happy (format t \":) ~\u0026\"))) 调用的时候用 :name value 这样的形式指定参数,定义了具名参数但是调用的时候不指定value 那具名参数的value 会为nil (hello \"me\") ;; ignore the happy paramenter,happy will be set to nil defaultly (hello \"me\" :happy t) ;; bind happy to t (hello \"me\" :happy nil) ;; bind happy to nil (hello \"me\" :happy) ;; wrong! this form is definitely wrong lisp中的 t and nil lisp 中用 t 代表true nil 代表false 和 空 有关函数参数数量的想法 具名参数是为了解决记住参数的顺序不方便而诞生的，但是如果函数的参数过多的话，会导致函数的行为会变得复杂多样。clean code 中并不鼓励函数参数的数量超过3个 你也可以定义多个具名参数 (defun hello (name \u0026key happy lisper cookbook-contributor-p) ...) 使用示例 (hello \"me\" :lisper t) (hello \"me\" :lisper t :happy t) (hello \"me\" :cookbook-contributor-p t :happy t) keys can be variable 类似 :happy 这样的符号其实可以作为一个变量的值就像这样。 (let ((key :happy) ;; bind :happy to key (val t)) ;; bind t to val (hello \"me\" key val)) ;; quote key and val let 可以声明一些只能在let代码快中使用的变量这个后面会细说 ","date":"2022-04-17","objectID":"/function/:2:3","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"混合可选和具名参数 先看一个例子 (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) 如果你直接这么定义函数，lisp的解释器会报warning ; in: DEFUN HELLO ; (SB-INT:NAMED-LAMBDA HELLO ; (\u0026OPTIONAL NAME \u0026KEY HAPPY) ; (BLOCK HELLO (FORMAT T \"hello ~a \" NAME) (WHEN HAPPY (FORMAT T \":)~\u0026\")))) ; ; caught STYLE-WARNING: ; \u0026OPTIONAL and \u0026KEY found in the same lambda list: (\u0026OPTIONAL (NAME \"John\") \u0026KEY ; HAPPY) ; ; compilation unit finished ; caught 1 STYLE-WARNING condition 虽然也能调用 (hello \"me\" :happy t) ;; hello me :) ;;nil 这种情况不能直接跳过optional的参数 直接指定key 参数 还是上面这个函数 (defun hello (\u0026optional name \u0026key happy) (format t \"hello ~a\" name) (when happy (format t \":)~\u0026\"))) 如果你尝试省略name 直接指定 :happy 就会报错 (hello :happy t) ;; odd number of \u0026KEY arguments 因为optional 的参数必须是有序出现的，如果前面的参数未出现，就不能直接指定后面的参数。但是当指定完所有的optional参数后，你就可以按照key参数的规则去指定key参数 看这个函数定义(一个不恰当的例子) (defun hello (\u0026optional name \u0026key happy age) (format t \"hello ~a \" name) (when happy (format t \":)~\u0026\"))) (hello \"me\" :age 1) 这里直接忽略happy 关键字 指定age ","date":"2022-04-17","objectID":"/function/:2:4","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"key parameters 的默认值 可以使用一对包含键值的括号来指定默认值 (happy t) (defun hello (name \u0026key (happy t))) 这样happy 的默认值就被设成了t ","date":"2022-04-17","objectID":"/function/:2:5","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"如何确定具名参数(key parameter) 是否被指定 前面有提到过，具名参数如果不指定，就会默认为NIL。那问题就是，如何知道具名参数的调用者是否故意指定这个参数为NIL呢。因为参数为NIL可能会有自己特殊的意义，所以需要判断是否是调用者故意设为NIL. 我们使用二元组 tuple 设置默认值 \u0026key (:happy t) 我们可以使用三元组 triple来解决参数知否被故意指定为NIL \u0026key (:happy t happy-p) (defun hello (name \u0026key (happy nil happy-p)) (format t \"Key supplied? ~a~\u0026\" happy-p) (format t \"hello ~a \" name) (when happy-p (if happy (format t \":)\") (format t \":(\")))) (hello \"me\" :happy t) ;; Ky supplied? T ;; hllo me :) 从返回的结果可以看到 如果指定了:happy 那么happy-p 会被自动设置为 t 即被指定状态 lisp 中有关断言命名的convenstion(传统) lisp 中习惯对用来做判断的函数或变量后面加一个p 比如 stringp :用来判断是否为字符串的函数 listp : 用来判断是否为列表类型的函数 p是predicate的缩写 意为断言 ","date":"2022-04-17","objectID":"/function/:2:6","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"可变数量参数: \u0026rest 的时候，你会想要定义一些函数，可以接受很多个参数，但是具体多少个，你也不清楚。比如你想定义个函数把所有的参数都相加进行求和。 (defun sum (arg1 arg2 arg3 ... to arg100....)) 这样太累了，你不可能一个一个的敲。我们可以这样 (defun hello (\u0026rest numbers) (apply #'+ numbers)) 调用 (hello 1 2 3 4) ;; 10 \u003c-- returned by hello apply 函数 apply 的第一个参数接收一个拥有两个参数的回调函数 第二个参数接受一个列表（这里为了方便理解代码这么说，其实这是不严谨的） 就像这样 (apply #'func '(arg1 arg2 arg3)) arg1 arg2 arg3 将会作为func 的参数传递给func 并进行运算. 也就是说 apply的操作是将 list 展开成一个个参数并传给func。 比如(apply #+ ‘(1 2 3 4)) 和 (+ 1 2 3 4) 是等价的。 列表 ‘(1 2 3 4) 被展开成 1 2 3 4 传递给了func ","date":"2022-04-17","objectID":"/function/:2:7","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"允许额外的key: \u0026allow-other-keys 先看下下面的例子 (defun hello (name \u0026key happy) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; Error: unknown keyword argument 再看看这个 (defun hello (name \u0026key happy \u0026allow-other-keys) (format t \"hello ~a~\u0026\" name)) (hello \"me\" :lisper t) ;; hello me 这里我们并没有给出 :lisper 这个关键字的定义 但是函数仍然允许我们这么调用而不是直接报错 《common lisp cook book》 中给出过一个实用的案例 (defun open-supersede (f \u0026rest other-keys \u0026key \u0026allow-other-keys) (print other-keys) (apply #'open f :if-exists :supersede other-keys)) 这个函数的定义要求必须有一个f参数，以及任意数量的other-keys 其实 \u0026key 以及\u0026allow-other-keys 被忽略了只做提示用（告诉调用者可以接受其他具名参数）。因为有\u0026rest 这个标志符在 除了f外 参数都会传到other-keys里面。所以\u0026key \u0026allow-other-keys就失去了语法上的意义。起码在编译器看来，他是无意义的。 但是如果你不按照函数签名指示的方式调用，内层的函数就很有可能报错，所以即使\u0026key \u0026allow-other-keys被编译器忽略(这种函数在定义时，甚至可以忽略\u0026key \u0026allow-other-keys关键字，功能并不会因为没有他们而受影响)，你也应该按照签名去调用函数。因为内层的函数需要依赖这个签名规则。 来看这个函数调用 (open-supersede \"test.log\" :if-does-not-exist :create) ;;(:IF-DOES-NOT-EXIST :CREATE) \u003c\u003c-- 由(print other-keys)打印 可以看到具名参数都被传给了\u0026rest 必要的函数文档 在写这种函数的时候，应该写上docstring 因为函数签名已经不能很好的描述函数了，我们应该加上docstring来描述函数，不要让调用者疑惑。 ","date":"2022-04-17","objectID":"/function/:2:8","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"函数返回值 common lisp 的返回值默认是函数的最后一个执行语句 你也可以使用(return-from \u003cfunction name\u003e \u003cname\u003e \u003cvalue\u003e) 显示的从具体函数内返回。注意这里是直接从\u003cfunction name\u003e 指定的函数中返回,不仅仅是从当前运行的函数中返回，也有可能直接从外层函数返回。 多数时候我们并不使用return-from ","date":"2022-04-17","objectID":"/function/:3:0","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"多返回值：values,multiple-value-bind and nth-value 我们使用values来构造一个多返回值 (defun foo (a b c) (values a b c)) 因为函数的最后一条语句的结果会被返回，所以values构造的多返回值会被直接返回给上层 (setf res (foo :a :b :c)) ;; :A \u003c\u003c-- res 为:A 这里res为:A而不是 :A :B :C 是因为这里的返回值接受者只有res 所以只有第一个:A 被接受 :B :C 都被自动忽略掉了. 接受多返回值得方法为multiple-value-bind。 multiple-value-bind 使用multiple-value-bind来解构多返回值。 (multiple-value-bind (res1 res2 res3) (foo :a :b :c) (format t \"res1 is ~a, res2 is ~a, res3 is ~a ~\u0026\" res1 res2 res3)) ;res1 is A, res2 is B res3 is C ;nil 通用格式 (multiple-value-bind (var-1 .. var-n) expr body) multiple-value-bind绑定的变量是局部的 使用multiple-value-bind的变量再它外面是访问不到的, 也就是说上面的例子中 res1 只能再(multipe-value-bind)的内部使用。而无法再外部使用 nth-value nth-value 是可以直接拿到指定索引的返回值 (nth-value 0 (values :a :b :c)) ;; =\u003e :A (nth-value 2 (values :a :b :c)) ;; =\u003e :C (nth-value 9 (values :a :b :c)) ;; =\u003e NIL 但是如果将 nth-value 用在List上，结果就不一样了 (nth-value 0 '(:a :b :c)) ;; =\u003e (:A :B :C) (nth-value 1 '(:a :b :c)) ;; =\u003e NIL Note (values) 将不会返回任何值 multiple-value-list multiple-value-list 将返回值构造成list (multiple-value-list (values 1 2 3)) ;; (1 2 3) 相反的操作有将list 构造成多返回值 (value-list '(1 2 3)) ","date":"2022-04-17","objectID":"/function/:3:1","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"匿名函数 lambda 使用lambda函数创建匿名函数 (lambda (x) (print x)) 我们可以用funcall 或者 apply 来调用匿名函数 如果一个未被引用的括号表达式内部第一个元素是一个匿名函数，那么这个匿名函数就会被调用 ((lambda (x) (print x)) \"hello\") 引用 lisp中 引用是指以’为开头的表达式或符号。‘将保护表达式或符号维持其本身。 比如(func arg) 这种形式的表达式将会自动被当做函数执行,有些情况我们并不想让他执行（比如传一个list 给函数做参数的时候的时候） (defun hello (arg)) (hello (1 2 3)) ;; illegal function call 这里(1 2 3) 将会被求值 并不会真的传一个(1 2 3) 给arg且会报 illegal function call 这样的错误。因为没有被’ 保护的函数会被自动当成函数并且运算。 所以正确的形式应该是 (defun hello (arg)) (hello '(1 2 3)) ‘就是保护表达式或变量维持其本身 ","date":"2022-04-17","objectID":"/function/:4:0","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"使用funcall 和 apply 调用函数 funcall 和 apply 类似，都是将参数规整成正确的形式然后传给回调函数 (funcall #'func arg1 arg2 .. argn) ;; ^^ 回调 要传给func的参数 不同点在于， funcall 不会自动展开list 列表 而apply 可以将列表展开成一个个参数传给回调func (funcall #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) 会原封不动的传给func (apply #'func arg1 arg2 '(arg3 arg4));; '(arg3 arg4) 会被展开成 arg3 arg4 最后的形式就是 (apply #'func arg1 arg2 arg3 arg4) ","date":"2022-04-17","objectID":"/function/:4:1","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"使用 single quote ’ 还是 sharpsign-quote #’ 来引用函数? single quote ’ 和 sharpsign-quote #‘的不同在于 #’ 使用的是词法作用域(lexical scope) 会更安全点 (defun foo (x) (* x 100)) (flet ((foo (x) (1+ x))) (funcall #'foo 1)) ;; =\u003e 2, as expected ;; ;; But: (flet ((foo (x) (1+ x))) (funcall 'foo 1)) ;; =\u003e 100 lexical scope 词法作用域的意思是，当找一个变量或函数的时候（函数此时作为值进行传递）会默认去定义的地方去找而不是再函数运行的环境中去找。 上面的foo 一个是在外面声明的 一个是使用flet 保护起来的foo 对于funcall 来说 #’会去找flet 出来的foo 因为词法作用域要求在定义的地方去找需要的函数。 single quote ’ 使用的是动态作用域 会默认去运行环境中找所以 即使第二个flet 也声明了 foo 但是funcall 的时候还是去到外层寻找foo #’ 其实就是(function … )的语法糖 (function +) ;; #\u003cFUNCTION +\u003e (flet ((foo (x) (1+ x))) (print (function foo)) (funcall (function foo) 1)) ;; #\u003cFUNCTION (FLET FOO) {1001C0ACFB}\u003e ;; 2 ","date":"2022-04-17","objectID":"/function/:4:2","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"高级函数 能够返回函数的函数 (functions that return functions) (defun adder (n) (lambda (x) (+ x n))) 这样就定义了一个能够返回一个函数对象的adder函数 要想调用这个函数对象我们需要funcall 或者 apply (adder 5) ;; #\u003cCLOSURE (LAMBDA (X) :IN ADDER) {100994ACDB}\u003e (funcall (adder 5) 3) ;; 8 如果你想以正常的思维去调用这个函数对象，会报错 ((adder 3) 5) ;;In: (ADDER 3) 5 ;;((ADDER 3) 5) ;;Error: Illegal function call. 在common lisp 中 对于变量和方法 他们有不同的命名空间。 比如一个变量和一个函数可以有同一个名字, 这取决于他被运算的环境 ;; The symbol foo is bound to nothing: CL-USER\u003e (boundp 'foo) NIL CL-USER\u003e (fboundp 'foo) NIL ;; We create a variable: CL-USER\u003e (defparameter foo 42) FOO * foo 42 ;; Now foo is \"bound\": CL-USER\u003e (boundp 'foo) T ;; but still not as a function: CL-USER\u003e (fboundp 'foo) NIL ;; So let's define a function: CL-USER\u003e (defun foo (x) (* x x)) FOO ;; Now the symbol foo is bound as a function too: CL-USER\u003e (fboundp 'foo) T ;; Get the function: CL-USER\u003e (function foo) #\u003cFUNCTION FOO\u003e ;; and the shorthand notation: * #'foo #\u003cFUNCTION FOO\u003e ;; We call it: (funcall (function adder) 5) #\u003cCLOSURE (lambda (X) :IN ADDER) {100991761B}\u003e ;; and call the lambda: (funcall (funcall (function adder) 5) 3) 8 可以认为，每个symbol 在CL(common lisp)中多有多个cell(空间)存储不同的信息，比如有的表示一个value-cell 你可以用boundp 来测试是否绑定了一个value. 你可以使用symbol-value访问value-cell. 还有其他cell 比如function-cell 可以保存symbol 的function. 你可以用fboundp来测试，使用symbol-function 来访问这个function. 如果symbol 被运算，那它就被当做是一个variable 并且他的value-cell将被返回。如果是符合形式，即cons,被求值并且他的car是一个symbol，那么使用这个symbol的function-cell. 所以上面的((addr 3) 5)的调用会报错。因为(addr 3) 既不是符号 也不是lambda表达式. ;;; continued from above CL-USER\u003e (fboundp '*my-fun*) NIL CL-USER\u003e (setf (symbol-function '*my-fun*) (adder 3)) #\u003cCLOSURE (lambda (X) :IN ADDER) {10099A5EFB}\u003e CL-USER\u003e (fboundp '*my-fun*) T CL-USER\u003e (*my-fun* 5) 8 ","date":"2022-04-17","objectID":"/function/:5:0","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"Closures 闭包 Closures 允许捕获词法绑定的值 (let ((limit 3) (counter -1)) (defun my-counter() (if (\u003c counter limit) (incf counter) (setf counter 0)))) (my-counter) 0 (my-counter) 1 (my-counter) 2 (my-counter) 3 (my-counter) 0 lexical 这里可以看见，counter 和 limit 是在let后就已经存在的值。my-counter 会去找被let的limit 和 counter. let就是将let定义的值与下面的函数体(body)做绑定。 还可以这样 (defun repeater (n) (let ((counter -1)) (lambda () (if (\u003c counter n) (incf counter) (setf counter 0))))) (defparameter *my-repeater* (repeater 3)) (defparameter *my-repeater2* (repeater 2)) (funcall *my-repeater*) 0 (funcall *my-repeater*) 1 (funcall *my-repeater*) 2 (funcall *my-repeater2*) 0 (funcall *my-repeater*) 3 (funcall *my-repeater*) 0 这里可以看到my-repeater 和my-repeater之间是相互隔离的 各自拥有自己的counter. 这是因为repeater 被执行了两次而 lambda 表达式被定义了两次，而被let包裹的函数会去其定义的环境中寻找值，所以两者的counter是隔离的。 ","date":"2022-04-17","objectID":"/function/:6:0","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"TODO setf functions ","date":"2022-04-17","objectID":"/function/:7:0","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["lisp"],"content":"柯里化 currying 维基百科上的解释是，把接受多个参数的函数转换成接受一个单一参数的函数 (defun curry (function \u0026rest args) (lambda (\u0026rest more-args) (apply function (append args more-args)))) 这个函数再第一次调用的时候会返回lambda函数 (funcall (curry #'+ 3) 5) ;;8 ","date":"2022-04-17","objectID":"/function/:8:0","tags":["common_lisp"],"title":"common lisp 函数","uri":"/function/"},{"categories":["leetcode"],"content":"leetcode-三数之和的解法","date":"2022-04-04","objectID":"/3sumcloset/","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"description ","date":"2022-04-04","objectID":"/3sumcloset/:1:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"analyze 这道题先排序，防止重复枚举，并且利用有序性，来使双指针的逼近产生可能。双指针的逼近其实和那题最大容量是类似的。 假设每轮枚举到的数分别为a,b,c，第二轮第三轮枚举的指针分别为i,pb,pc,令pb指向i+1,pc指向len(nums)-1 若a+b+c \u003e target 则应该让pc左移，因为排完序后，pb不动的情况下 只有pc左移才会使a+b+c的值减小 才有可能更加靠近target 若a+b+c \u003c target 则应该让pb右移，因为pc不动的情况下，只有pb右移，a+b+c的值才会增大，才有可能更加靠近target ","date":"2022-04-04","objectID":"/3sumcloset/:2:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"implementation package main import ( \"fmt\" \"math\" \"sort\" ) func threeSumClosest(nums []int, target int) int { result := math.MaxInt64 distance := math.MaxFloat64 sort.Ints(nums) for i := 0; i \u003c len(nums); i++ { if i \u003e 0 \u0026\u0026 nums[i] == nums[i-1] { continue } third := len(nums) - 1 for j := i + 1; j \u003c len(nums); j++ { if j \u003e i+1 \u0026\u0026 nums[j] == nums[j-1] { continue } for nums[i]+nums[j]+nums[third] \u003e target \u0026\u0026 third \u003e j { if third \u003c len(nums)-1 \u0026\u0026 nums[third] == nums[third+1] { third-- continue } sum := nums[i] + nums[j] + nums[third] tmpDistance := math.Abs(float64(sum - target)) if tmpDistance \u003c= distance { distance = tmpDistance result = sum } third-- } if third == j { break } if nums[i]+nums[j]+nums[third] \u003c= target { sum := nums[i] + nums[j] + nums[third] tmpDistance := math.Abs(float64(sum - target)) if tmpDistance \u003c= distance { distance = tmpDistance result = sum } } } } return result } ","date":"2022-04-04","objectID":"/3sumcloset/:3:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"summery 这道题，乍一看，我就往dp上面去想了。看看这题，跟那题三数只和很相似，就想着能不能在第二轮和第三轮的时候来一次优化。但是我看了半天也没看出来，优先排序这个思路是有的，想着第二轮第三轮进行优化的思路也是对的。但是具体如何优化我却想不到。想着应该跟那个target有关系，但是我方向错了，根本就不是我想的那样。后来一看题解，恍然大悟，这些数组题，双指针的，尤其要三轮演绎的，一般都是想让你进行二三轮的优化，利用双指针逼近不断找到最优解。至于如何逼近，就是问题的关键点了，只要找到能够让指针逼近的关系，这道题自然就解开了。 ","date":"2022-04-04","objectID":"/3sumcloset/:4:0","tags":["leetcode","double-point"],"title":"leetcode-最接近目标值得三数之和","uri":"/3sumcloset/"},{"categories":["leetcode"],"content":"这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最优解优于全局最优解，则刷新全局最优解。","date":"2022-04-04","objectID":"/container_with_most_water/","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"1 Description https://leetcode-cn.com/problems/container-with-most-water/ ","date":"2022-04-04","objectID":"/container_with_most_water/:1:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"2.analyze problem 这道题的核心是双指针和贪心算法，通过不断移动两个指针，找到局部最优解，如果局部最优解优于全局最优解，则刷新全局最优解。 ","date":"2022-04-04","objectID":"/container_with_most_water/:2:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"2.1 slove step 分配两个指针，分别指向数组的头尾 [1,8,6,2,5,4,8,3,7] l r 计算面积并与全局最优解做比较，如果大于全局最优解，刷新全局最优解。并且移动对应数字较小的那个指针(向对应数字较大的方向移动) [1,8,6,2,5,4,8,3,7] l r 重复上述操作直到指针相遇 ","date":"2022-04-04","objectID":"/container_with_most_water/:2:1","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"2.2 certify 需要该解法需要证明的是，为什么每次移动对应值较小的指针是正确的。 双指针代表的是 可以作为容器边界的所有位置的范围 移动指针就代表这个指针不可能再作为容器的边界了。 为什么指向较小值的指针不可能再作为容器的边界了 。 假设当前左指针和右指针指向的数分别为\\(x\\) 和\\(y\\), 不失一般性，我们假设 \\(x \\leq y\\) 两个指针之间的距离为t。那么，他们组成的容器的容量为： \\[\\begin{equation} min(x,y)*t = x*t \\end{equation}\\] 如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 \\(x*t\\) 。为什么呢，这里我们只考虑当指针还指向左右边界的时候。 我们任意向左移动右指针，指向的数为 \\(y_{1}\\) ，两个指针之间的距离为 \\(t_{1}\\) ，\\(t_{1} \u003c t\\) ，并且 \\(min(x,y_{1}) \\le min(x,y)\\) 如果 \\(y_{1} \\le y\\), then \\(min(x,y_{1}) \\le min(x,y)\\) ; 如果 \\(y_{1} \\ge y\\), then \\(min(x,y_{1}) =x= min(x,y)\\) ; 所以有 \\[\\begin{equation} min(x,y_{t})*t_{1} \u003c min(x,y)*t \\end{equation}\\] 这表明指向较小值的指针不可以再作为容器的边界，因为无论如何移动较大的指针，容器的容量都不会再变大。这个边界应该被舍弃。 ","date":"2022-04-04","objectID":"/container_with_most_water/:2:2","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"3 implementation //c++ version #include \u003calgrothim\u003e#include \u003ciostream\u003e#include \u003cmath\u003e using namespace std; class Solution { public: int maxArea(vector\u003cint\u003e \u0026height) { int left = 0; int right = height.size()-1; int compacity = 0; while (left \u003c right) { int min = fmin(height[left], height[right]); int length = right - left; int tmpCompacity = min * length; if (tmpCompacity \u003e= compacity) compacity = tmpCompacity; if (height[left] \u003e= height[right]) right--; else left++; } return compacity; } }; int main(int argc, char *argv[]) { return 0; } //go version import \"math\" func maxArea(height []int) int { front := 0 end := len(height)-1 var maxCompacity float64 = 0 for front \u003c end { longSide := math.Min(float64(height[front]),float64(height[end])) shotSide := float64(end-front) tmpCompacity := longSide*shotSide maxCompacity = math.Max(tmpCompacity,maxCompacity) if height[front] \u003e= height[end] { end-- }else{ front++ } } return int(maxCompacity) } ","date":"2022-04-04","objectID":"/container_with_most_water/:3:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"4 summery 这道题用到了双指针+贪心算法。以后都可以用双指针对撞的思想去求解这类问题，重点在于如何找到应该移动的指针。当因子分布再数组的两边的时候，可以考虑使用双指针的方法求解。这题的贪心并不明显，只在更新最大的容量的时候进行了贪心。贪心的思想是每一步只选择当前认为的最优解。 ","date":"2022-04-04","objectID":"/container_with_most_water/:4:0","tags":["leetcode","double-point"],"title":"leetcode-盛水最多的容器","uri":"/container_with_most_water/"},{"categories":["leetcode"],"content":"Description Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. Example 3: Input: nums1 = [0,0], nums2 = [0,0] Output: 0.00000 Example 4: Input: nums1 = [], nums2 = [1] Output: 1.00000 Example 5: Input: nums1 = [2], nums2 = [] Output: 2.00000 Constraints: nums1.length == m nums2.length == n 0 \u003c= m \u003c= 1000 0 \u003c= n \u003c= 1000 1 \u003c= m + n \u003c= 2000 -106 \u003c= nums1[i], nums2[i] \u003c= 106 ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:1:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode"],"content":"Analyse 这道题最简单的想法就是先归并到一个数组，然后再把中位数找到，但是此时的时间复杂度为\\(o(m+n)\\) 不符合题意。题目要求的是 \\(o(\\log(m+n))\\) 。 此时我们能想到的应该就只有二分法了，对于有序数组，二分法总能非常有效的降低算法的复杂度。但是如何二分成为一个问题。 中位数指的是一个数列中间的数。设 len = len(array) 这里的/为整除 \\begin{equation} \\label{中位数公式} medium = \\begin{cases} \\frac{array[len/2-1] + array[len/2]}{2} \u0026len\\mod 2=0 \\\\ \\frac{array[len/2-1]}{2}\u0026 len\\mod 2\\neq 0 \\end{cases} \\end{equation} 这道题是寻找两个有序数组的中位数，我们可以姑且假设他们已经合并后的数组为 nums3 我们要在nums3中寻找中位数。此时 nums3 的长度我们 是知道的(m+n) 那么其中位数的应该为第 k= \\(\\frac{m+n}{2}\\) 个数（这里我们先只看奇数情况。这时我们可以对k进行二分处理，分别找到两个s数组中第 \\(\\frac{k}{2}\\) 个数进行比较，然后排除较小的以及它所在数组中在它前面的数。因为他们是不可能成为中位数的。 对于 nums1[k/2-1] 和 nums2[k/2-1] 在它们之前的只有 k/2-1 + k/2-1 = k -2 个数。即使算上较小的那个数，也只能到第k-1个数。 所以他们是不可能成为第k个数的。这时我们让 k = k-A(A为已经排除的数的个数) 然后继续对剩下的数组进行同样的操作。 这里会出现两种情况 如果 nums1[k/2-1] \u003e= nums2[k/2-1] 则直接排除nums1[k/2-1] 及其前面的数 如果 nums1[k/2-1] \u003c nums2[k/2-1] 则直接排除nums2[k/2-1] 及其前面的数 在排除过程中我们还会遇到几种情况 k/2-1 越界，这种情况取最后一个元素 k=1 直接返回较小的元素 数组为空，直接去非空数组中寻找即可 ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:2:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode"],"content":"Implement //c++ version #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e int main(int argc, char *argv[]) { Solution s; vector\u003cint\u003e nums1 = new vector\u003cint\u003e(); vector\u003cint\u003e nums2 = new vector\u003cint\u003e(); for(int i = 1;i\u003c10;i++){ nums1.push_back(i); } for(int i= 1;i\u003c10;i=i+2){ nums2.push_back(i); } s.findMedianSortedArrays(nums1,nums2); return 0; } class Solution { public: double findMedianSortedArrays(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { int k = nums1.size() + nums2.size(); if(k%2 == 0){ return min(getKthElement(nums1, nums2, k/2+1),getKthElement(nums1, nums2,k/2))/2.0; }else{ return getKthElement(nums1,nums2,k/2); } } double getKthElement(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2,int k){ int index1 = 0; int index2 = 0; int m = nums1.size(); int n = nums2.size(); while (true){ if (index1 == m){ return nums2[index2+k-1]; } if(index2 == n){ return nums1[index1 +k -1]; } if(k == 1){ return min(nums1[index1],nums2[index2]); } int newIndex1 = min(index1+k/2-1,m-1); int newIndex2 = min(index2+k/2-1,n-1); if(nums1[newIndex1] \u003e= nums2[newIndex2]){ k -= newIndex2 - index2 +1; index2 = newIndex2+1; }else{ k -= newIndex1 - index1 +1; index1 = newIndex1+1; } } } }; //GO version package main import ( \"fmt\" \"math\" ) func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { k := int(math.Ceil((float64(len(nums1)) + float64(len(nums2))) / 2)) if (len(nums1)+len(nums2))%2 == 0 { foo1 := getKthElement(nums1, nums2, k) foo2 := getKthElement(nums1, nums2, k+1) return float64(foo1+foo2) / 2 } else { return float64(getKthElement(nums1, nums2, k)) } } func getKthElement(nums1 []int, nums2 []int, k int) int { if len(nums1) == 0 { return nums2[k-1] } if len(nums2) == 0 { return nums1[k-1] } compareIdx := k / 2 if compareIdx == 0 { return min(nums1[0], nums2[0]) } nums1Idx := min(len(nums1)-1, compareIdx-1) nums2Idx := min(len(nums2)-1, compareIdx-1) if nums1[nums1Idx] \u003e= nums2[nums2Idx] { if len(nums2) \u003c= compareIdx { return getKthElement(nums1, []int{}, k-(nums2Idx+1)) } return getKthElement(nums1, nums2[compareIdx:], k-(nums2Idx+1)) } else { if len(nums1) \u003c= compareIdx { return getKthElement([]int{}, nums2, k-(nums1Idx+1)) } return getKthElement(nums1[compareIdx:], nums2, k-(nums1Idx+1)) } } func min(x, y int) int { if x \u003c y { return x } return y } ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:3:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"},{"categories":["leetcode"],"content":"summery 这道题对二分的运用比较灵活，主要是二分的对象变了，但是思想还在。正常的二分是对数组的长度进行二分，而此题的二分却是先确定中位数的位置，再利用二分的思想去到两个数组中分别寻找排除，非常巧妙，受益匪浅。 ","date":"2022-03-30","objectID":"/median_of_two_sorted_arrays/:4:0","tags":["leetcode","array","binary_search","divide_and_conquer"],"title":"返回两个有序数组中中间的数","uri":"/median_of_two_sorted_arrays/"}]